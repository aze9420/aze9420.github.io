{"pages":[{"title":"","text":"","link":"/404/index.html"},{"title":"about","text":"这是我的博客，欢迎你关注我！biubiu~~","link":"/about/index.html"}],"posts":[{"title":"github搜索技巧","text":"github 项目名字(name)里有 python 的in:name python 名字(name)里有 python 的并且 stars 大于 3000 的in:name python starts:&gt;3000 名字(name)里有 python 的并且 stars 大于 3000 、forks 大于 200 的in:name python starts:&gt;3000 forks:&gt;200 详情(readme)里面有 python 的并且 stars 大于 3000 的in:readme python starts:&gt;3000 描述(description)里面有 python 的并且 stars 大于 3000 的in:description python starts:&gt;3000 描述(description)里面有 python 的并且是 python 语言的in:description python language:python 描述(description)里面有 python 的并且 2019-12-20 号之后有更新过的in:description python pushed:&gt;2019-12-20","link":"/2020/03/07/github%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/"},{"title":"Diary","text":"Diary 2020年4月20日红了樱桃，绿了芭蕉。终于，终于忙完了家里的事。也算是给自己放空的机会，去小寨摘樱桃。 ![](http://demo-1259638372.cos.ap-chengdu.myqcloud.com/Diary/20200420021434260.png) 见到了许久不见的老友，一起吹风，一路欢歌来到了小寨。没想到樱桃还不怎么熟透，扎心了，进园子里随便摘了几颗便出来了，打算过一久又去。回来聚聚餐，玩玩游戏，各自回家。 哎~原本可以回来做做事情，无心继续。我陷入了对人生的大思考。我越来越发现我也是一个完美主义者，就像罗永浩一样，想得很美，做起来难；什么东西都想尝试，都想做好，做出的结果却，，，无论是做事还是感情！这是我的性格使然。再好的亲情，再好的友情都需要时间去培养和灌溉。我尽力再做，错过的人，错过的事, I am sorry but I love you. 我相信时间会给出答案，即使生命到达不了那一天。 疫情让我们懂得，什么应该放弃，什么应该去坚持，什么应该去铭记。以前的我，总是喜欢把自己的想法强加于人，殊不知这是一种不成熟，无知的体现。每个人都有自己的信仰和价值观，并以此来看待这个世界，采取不一样的态度和行为去对待身边所发生的事。尊重可能是最好的办法。 结束了一周的黑暗时刻，应该让自己的生活步入正轨。可能马上就要开学，马上要交的报告，简直了，裂开。立个flag, 20天在项目上做出个样子来，不能再拖了，奥力给。","link":"/2020/04/20/Diary/"},{"title":"java高级教程学习笔记三","text":"java高级教程 java数据结构java工具包提供了强大的数据结构。在java中的数据结构主要包括以下的几种接口和类： 枚举（Enumeration）:枚举（Enumeration）接口虽然它本身不属于数据结构,但它在其他数据结构的范畴里应用很广。 枚举（The Enumeration）接口定义了一种从数据结构中取回连续元素的方式。 例如，枚举定义了一个叫nextElement 的方法，该方法用来得到一个包含多元素的数据结构的下一个元素。 位集合（BitSet）:位集合类实现了一组可以单独设置和清除的位或标志。 该类在处理一组布尔值的时候非常有用，你只需要给每个值赋值一”位”，然后对位进行适当的设置或清除，就可以对布尔值进行操作了。 向量（Vector）: 向量（Vector）类和传统数组非常相似，但是Vector的大小能根据需要动态的变化。 和数组一样，Vector对象的元素也能通过索引访问。 使用Vector类最主要的好处就是在创建对象的时候不必给对象指定大小，它的大小会根据需要动态的变化。 栈（Stack):栈（Stack）实现了一个后进先出（LIFO）的数据结构。 你可以把栈理解为对象的垂直分布的栈，当你添加一个新元素时，就将新元素放在其他元素的顶部。 当你从栈中取元素的时候，就从栈顶取一个元素。换句话说，最后进栈的元素最先被取出。 字典(Dictionary): 字典（Dictionary） 类是一个抽象类，它定义了键映射到值的数据结构。 当你想要通过特定的键而不是整数索引来访问数据的时候，这时候应该使用Dictionary。 由于Dictionary类是抽象类，所以它只提供了键映射到值的数据结构，而没有提供特定的实现。 哈希表(Hashtable): Hashtable类提供了一种在用户定义键结构的基础上来组织数据的手段。 例如，在地址列表的哈希表中，你可以根据邮政编码作为键来存储和排序数据，而不是通过人名。 哈希表键的具体含义完全取决于哈希表的使用情景和它包含的数据。 属性(Properties): Properties 继承于 Hashtable.Properties 类表示了一个持久的属性集.属性列表中每个键及其对应值都是一个字符串。 Properties 类被许多Java类使用。例如，在获取环境变量时它就作为System.getProperties()方法的返回值。 java2中还引入了一种新的框架–集合框架（Collection） java集合框架集合框架被设计成要满足以下几个目标。 该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。 该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。 对一个集合的扩展和适应必须是简单的。 整个集合框架就围绕一组标准接口而设计。你可以直接使用这些接口的标准实现，诸如： LinkedList, HashSet, 和 TreeSet 等,除此之外你也可以通过这些接口实现自己的集合。 从上面的集合框架图可以看到，Java 集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键/值对映射。Collection 接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap 等等。 集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容： 接口：是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象 实现（类）：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。 算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。 除了集合，该框架也定义了几个 Map 接口和类。Map 里存储的是键/值对。尽管 Map 不是集合，但是它们完全整合在集合中。 集合框架体系如图所示 Java 集合框架提供了一套性能优良，使用方便的接口和类，java集合框架位于java.util包中， 所以当使用集合框架的时候需要进行导包。 集合接口 集合框架定义了一些接口。本节提供了每个接口的概述： 序号 接口描述 1 Collection 接口 Collection 是最基本的集合接口，一个 Collection 代表一组 Object，即 Collection 的元素, Java不提供直接继承自Collection的类，只提供继承于的子接口(如List和set)。Collection 接口存储一组不唯一，无序的对象。 2 List 接口 List接口是一个有序的 Collection，使用此接口能够精确的控制每个元素插入的位置，能够通过索引(元素在List中位置，类似于数组的下标)来访问List中的元素，第一个元素的索引为 0，而且允许有相同的元素。List 接口存储一组不唯一，有序（插入顺序）的对象。 3 Set Set 具有与 Collection 完全一样的接口，只是行为上不同，Set 不保存重复的元素。Set 接口存储一组唯一，无序的对象。 4 SortedSet 继承于Set保存有序的集合。 5 Map Map 接口存储一组键值对象，提供key（键）到value（值）的映射。 6 Map.Entry 描述在一个Map中的一个元素（键/值对）。是一个Map的内部类。 7 SortedMap 继承于 Map，使 Key 保持在升序排列。 8 Enumeration 这是一个传统的接口和定义的方法，通过它可以枚举（一次获得一个）对象集合中的元素。这个传统接口已被迭代器取代。 Set和List的区别 \\1. Set 接口实例存储的是无序的，不重复的数据。List 接口实例存储的是有序的，可以重复的元素。 \\2. Set检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 &lt;实现类有HashSet,TreeSet&gt;。 \\3. List和数组类似，可以动态增长，根据实际存储的数据的长度自动增长List的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 &lt;实现类有ArrayList,LinkedList,Vector&gt; 。 集合实现类（集合类） Java提供了一套实现了Collection接口的标准集合类。其中一些是具体类，这些类可以直接拿来使用，而另外一些是抽象类，提供了接口的部分实现。 标准集合类汇总于下表： 序号 类描述 1 AbstractCollection 实现了大部分的集合接口。 2 AbstractList 继承于AbstractCollection 并且实现了大部分List接口。 3 AbstractSequentialList 继承于 AbstractList ，提供了对数据元素的链式访问而不是随机访问。 4 LinkedList 该类实现了List接口，允许有null（空）元素。主要用于创建链表数据结构，该类没有同步方法，如果多个线程同时访问一个List，则必须自己实现访问同步，解决方法就是在创建List时候构造一个同步的List。例如：List list=Collections.synchronizedList(newLinkedList(...));LinkedList 查找效率低。 5 ArrayList 该类也是实现了List的接口，实现了可变大小的数组，随机访问和遍历元素时，提供更好的性能。该类也是非同步的,在多线程的情况下不要使用。ArrayList 增长当前长度的50%，插入删除效率低。 6 AbstractSet 继承于AbstractCollection 并且实现了大部分Set接口。 7 HashSet 该类实现了Set接口，不允许出现重复元素，不保证集合中元素的顺序，允许包含值为null的元素，但最多只能一个。 8 LinkedHashSet 具有可预知迭代顺序的 Set 接口的哈希表和链接列表实现。 9 TreeSet 该类实现了Set接口，可以实现排序等功能。 10 AbstractMap 实现了大部分的Map接口。 11 HashMap HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。 该类实现了Map接口，根据键的HashCode值存储数据，具有很快的访问速度，最多允许一条记录的键为null，不支持线程同步。 12 TreeMap 继承了AbstractMap，并且使用一颗树。 13 WeakHashMap 继承AbstractMap类，使用弱密钥的哈希表。 14 LinkedHashMap 继承于HashMap，使用元素的自然顺序对元素进行排序. 15 IdentityHashMap 继承AbstractMap类，比较文档时使用引用相等。 在前面的教程中已经讨论通过java.util包中定义的类，如下所示： 序号 类描述 1 Vector 该类和ArrayList非常相似，但是该类是同步的，可以用在多线程的情况，该类允许设置默认的增长长度，默认扩容方式为原来的2倍。 2 Stack 栈是Vector的一个子类，它实现了一个标准的后进先出的栈。 3 Dictionary Dictionary 类是一个抽象类，用来存储键/值对，作用和Map类相似。 4 Hashtable Hashtable 是 Dictionary(字典) 类的子类，位于 java.util 包中。 5 Properties Properties 继承于 Hashtable，表示一个持久的属性集，属性列表中每个键及其对应值都是一个字符串。 6 BitSet 一个Bitset类创建一种特殊类型的数组来保存位值。BitSet中数组大小会随需要增加。 集合算法 集合框架定义了几种算法，可用于集合和映射。这些算法被定义为集合类的静态方法。 在尝试比较不兼容的类型时，一些方法能够抛出 ClassCastException异常。当试图修改一个不可修改的集合时，抛出UnsupportedOperationException异常。 集合定义三个静态的变量：EMPTY_SET，EMPTY_LIST，EMPTY_MAP的。这些变量都不可改变。 如何使用迭代器 通常情况下，你会希望遍历一个集合中的元素。例如，显示集合中的每个元素。 一般遍历数组都是采用for循环或者增强for，这两个方法也可以用在集合框架，但是还有一种方法是采用迭代器遍历集合框架，它是一个对象，实现了Iterator 接口或ListIterator接口。 迭代器，使你能够通过循环来得到或删除集合的元素。ListIterator 继承了Iterator，以允许双向遍历列表和修改元素。 遍历 ArrayList 123456789101112131415161718192021222324252627282930313233343536import java.util.*; public class Test{ public static void main(String[] args) { Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(\"1\", \"value1\"); map.put(\"2\", \"value2\"); map.put(\"3\", \"value3\"); //第一种：普遍使用，二次取值 System.out.println(\"通过Map.keySet遍历key和value：\"); for (String key : map.keySet()) { System.out.println(\"key= \"+ key + \" and value= \" + map.get(key)); } //第二种 System.out.println(\"通过Map.entrySet使用iterator遍历key和value：\"); Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator(); while (it.hasNext()) { Map.Entry&lt;String, String&gt; entry = it.next(); System.out.println(\"key= \" + entry.getKey() + \" and value= \" + entry.getValue()); } //第三种：推荐，尤其是容量大时 System.out.println(\"通过Map.entrySet遍历key和value\"); for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) { System.out.println(\"key= \" + entry.getKey() + \" and value= \" + entry.getValue()); } //第四种 System.out.println(\"通过Map.values()遍历所有的value，但不能遍历key\"); for (String v : map.values()) { System.out.println(\"value= \" + v); } }} 如何使用比较器TreeSet和TreeMap的按照排序顺序来存储元素. 然而，这是通过比较器来精确定义按照什么样的排序顺序。 这个接口可以让我们以不同的方式来排序一个集合。 序号 比较器方法描述 1 使用 Java Comparator 这里通过实例列出Comparator接口提供的所有方法 总结Java集合框架为程序员提供了预先包装的数据结构和算法来操纵他们。 集合是一个对象，可容纳其他对象的引用。集合接口声明对每一种类型的集合可以执行的操作。 集合框架的类和接口均在java.util包中。 任何对象加入集合类后，自动转变为Object类型，所以在取出的时候，需要进行强制类型转换。 java泛型—参数化类型ava 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。 泛型方法你可以写一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用。 下面是定义泛型方法的规则： 所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的）。 每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。 类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。 泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（像int,double,char的等）。 下面的例子演示了如何使用泛型方法打印不同字符串的元素： 1234567891011121314151617181920212223242526272829public class GenericMethodTest{ // 泛型方法 printArray public static &lt; E &gt; void printArray( E[] inputArray ) { // 输出数组元素 for ( E element : inputArray ){ System.out.printf( \"%s \", element ); } System.out.println(); } public static void main( String args[] ) { // 创建不同类型数组： Integer, Double 和 Character Integer[] intArray = { 1, 2, 3, 4, 5 }; Double[] doubleArray = { 1.1, 2.2, 3.3, 4.4 }; Character[] charArray = { 'H', 'E', 'L', 'L', 'O' }; System.out.println( \"整型数组元素为:\" ); printArray( intArray ); // 传递一个整型数组 System.out.println( \"\\n双精度型数组元素为:\" ); printArray( doubleArray ); // 传递一个双精度型数组 System.out.println( \"\\n字符型数组元素为:\" ); printArray( charArray ); // 传递一个字符型数组 } } 有界的类型参数: 可能有时候，你会想限制那些被允许传递到一个类型参数的类型种类范围。例如，一个操作数字的方法可能只希望接受Number或者Number子类的实例。这就是有界类型参数的目的。 要声明一个有界的类型参数，首先列出类型参数的名称，后跟extends关键字，最后紧跟它的上界。 实例 下面的例子演示了”extends”如何使用在一般意义上的意思”extends”（类）或者”implements”（接口）。该例子中的泛型方法返回三个可比较对象的最大值。 1234567891011121314151617181920212223242526public class MaximumTest{ // 比较三个值并返回最大值 public static &lt;T extends Comparable&lt;T&gt;&gt; T maximum(T x, T y, T z) { T max = x; // 假设x是初始最大值 if ( y.compareTo( max ) &gt; 0 ){ max = y; //y 更大 } if ( z.compareTo( max ) &gt; 0 ){ max = z; // 现在 z 更大 } return max; // 返回最大对象 } public static void main( String args[] ) { System.out.printf( \"%d, %d 和 %d 中最大的数为 %d\\n\\n\", 3, 4, 5, maximum( 3, 4, 5 ) ); System.out.printf( \"%.1f, %.1f 和 %.1f 中最大的数为 %.1f\\n\\n\", 6.6, 8.8, 7.7, maximum( 6.6, 8.8, 7.7 ) ); System.out.printf( \"%s, %s 和 %s 中最大的数为 %s\\n\",\"pear\", \"apple\", \"orange\", maximum( \"pear\", \"apple\", \"orange\" ) ); }} 泛型类 泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。 和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。 实例 如下实例演示了我们如何定义一个泛型类: 1234567891011121314151617181920212223public class Box&lt;T&gt; { private T t; public void add(T t) { this.t = t; } public T get() { return t; } public static void main(String[] args) { Box&lt;Integer&gt; integerBox = new Box&lt;Integer&gt;(); Box&lt;String&gt; stringBox = new Box&lt;String&gt;(); integerBox.add(new Integer(10)); stringBox.add(new String(\"菜鸟教程\")); System.out.printf(\"整型值为 :%d\\n\\n\", integerBox.get()); System.out.printf(\"字符串为 :%s\\n\", stringBox.get()); }} 类型通配符 1、类型通配符一般是使用?代替具体的类型参数。例如 List 在逻辑上是List,List 等所有List&lt;具体类型实参&gt;的父类。 1234567891011121314151617181920212223import java.util.*; public class GenericTest { public static void main(String[] args) { List&lt;String&gt; name = new ArrayList&lt;String&gt;(); List&lt;Integer&gt; age = new ArrayList&lt;Integer&gt;(); List&lt;Number&gt; number = new ArrayList&lt;Number&gt;(); name.add(\"icon\"); age.add(18); number.add(314); getData(name); getData(age); getData(number); } public static void getData(List&lt;?&gt; data) { System.out.println(\"data :\" + data.get(0)); }} 解析： 因为getData()方法的参数是List类型的，所以name，age，number都可以作为这个方法的实参，这就是通配符的作用 2、类型通配符上限通过形如List来定义，如此定义就是通配符泛型值接受Number及其下层子类类型。 123456789101112131415161718192021222324252627import java.util.*; public class GenericTest { public static void main(String[] args) { List&lt;String&gt; name = new ArrayList&lt;String&gt;(); List&lt;Integer&gt; age = new ArrayList&lt;Integer&gt;(); List&lt;Number&gt; number = new ArrayList&lt;Number&gt;(); name.add(\"icon\"); age.add(18); number.add(314); //getUperNumber(name);//1 getUperNumber(age);//2 getUperNumber(number);//3 } public static void getData(List&lt;?&gt; data) { System.out.println(\"data :\" + data.get(0)); } public static void getUperNumber(List&lt;? extends Number&gt; data) { System.out.println(\"data :\" + data.get(0)); }} java序列化Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。 将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。 整个过程都是 Java 虚拟机（JVM）独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。 类 ObjectInputStream 和 ObjectOutputStream 是高层次的数据流，它们包含反序列化和序列化对象的方法。 java网络编程网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。 java.net 包中 J2SE 的 API 包含有类和接口，它们提供低层次的通信细节。你可以直接使用这些类和接口，来专注于解决问题，而不用关注通信细节。 java.net 包中提供了两种常见的网络协议的支持： TCP：TCP 是传输控制协议的缩写，它保障了两个应用程序之间的可靠通信。通常用于互联网协议，被称 TCP / IP。 UDP：UDP 是用户数据报协议的缩写，一个无连接的协议。提供了应用程序之间要发送的数据的数据包。 本教程主要讲解以下两个主题。 Socket 编程：这是使用最广泛的网络概念，它已被解释地非常详细。 套接字使用TCP提供了两台计算机之间的通信机制。 客户端程序创建一个套接字，并尝试连接服务器的套接字。 当连接建立时，服务器会创建一个 Socket 对象。客户端和服务器现在可以通过对 Socket 对象的写入和读取来进行通信。 java.net.Socket 类代表一个套接字，并且 java.net.ServerSocket 类为服务器程序提供了一种来监听客户端，并与他们建立连接的机制。 以下步骤在两台计算机之间使用套接字建立TCP连接时会出现： 服务器实例化一个 ServerSocket 对象，表示通过服务器上的端口通信。 服务器调用 ServerSocket 类的 accept() 方法，该方法将一直等待，直到客户端连接到服务器上给定的端口。 服务器正在等待时，一个客户端实例化一个 Socket 对象，指定服务器名称和端口号来请求连接。 Socket 类的构造函数试图将客户端连接到指定的服务器和端口号。如果通信被建立，则在客户端创建一个 Socket 对象能够与服务器进行通信。 在服务器端，accept() 方法返回服务器上一个新的 socket 引用，该 socket 连接到客户端的 socket。 连接建立后，通过使用 I/O 流在进行通信，每一个socket都有一个输出流和一个输入流，客户端的输出流连接到服务器端的输入流，而客户端的输入流连接到服务器端的输出流。 TCP 是一个双向的通信协议，因此数据可以通过两个数据流在同一时间发送.以下是一些类提供的一套完整的有用的方法来实现 socket。 URL 处理：这部分会在另外的篇幅里讲，点击这里更详细地了解在 Java 语言中的 URL 处理。 java发送邮件使用Java应用程序发送 E-mail 十分简单，但是首先你应该在你的机器上安装 JavaMail API 和Java Activation Framework (JAF) 。 您可以从 Java 网站下载最新版本的 JavaMail，打开网页右侧有个 Downloads 链接，点击它下载。 您可以从 Java 网站下载最新版本的 JAF（版本 1.1.1）。 你也可以使用本站提供的下载链接： JavaMail mail.jar 1.4.5 JAF（版本 1.1.1） activation.jar 下载并解压缩这些文件，在新创建的顶层目录中，您会发现这两个应用程序的一些 jar 文件。您需要把 mail.jar 和 activation.jar 文件添加到您的 CLASSPATH 中。 如果你使用第三方邮件服务器如QQ的SMTP服务器，可查看文章底部用户认证完整的实例。 java多线程编程Java 给多线程编程提供了内置的支持。 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。 这里定义和线程相关的另一个术语 - 进程：一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。 多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。 一个线程的生命周期线程是一个动态执行的过程，它也有一个从产生到死亡的过程。 下图显示了一个线程完整的生命周期。 新建状态: 使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。 就绪状态: 当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。 运行状态: 如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。 阻塞状态: 如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种： 等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。 同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。 其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。 死亡状态: 一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。 线程的优先级每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。 Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。 默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。 具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。 创建一个线程Java 提供了三种创建线程的方法： 通过实现 Runnable 接口； 创建一个线程，最简单的方法是创建一个实现 Runnable 接口的类。 为了实现 Runnable，一个类只需要执行一个方法调用 run()，声明如下： 1public void run() 你可以重写该方法，重要的是理解的 run() 可以调用其他方法，使用其他类，并声明变量，就像主线程一样。 在创建一个实现 Runnable 接口的类之后，你可以在类中实例化一个线程对象。 Thread 定义了几个构造方法，下面的这个是我们经常使用的： 1Thread(Runnable threadOb,String threadName); 这里，threadOb 是一个实现 Runnable 接口的类的实例，并且 threadName 指定新线程的名字。 新线程创建之后，你调用它的 start() 方法它才会运行。 1void start(); 下面是一个创建线程并开始让它执行的实例： 123456789101112131415161718192021222324252627282930313233343536373839404142class RunnableDemo implements Runnable { private Thread t; private String threadName; RunnableDemo( String name) { threadName = name; System.out.println(\"Creating \" + threadName ); } public void run() { System.out.println(\"Running \" + threadName ); try { for(int i = 4; i &gt; 0; i--) { System.out.println(\"Thread: \" + threadName + \", \" + i); // 让线程睡眠一会 Thread.sleep(50); } }catch (InterruptedException e) { System.out.println(\"Thread \" + threadName + \" interrupted.\"); } System.out.println(\"Thread \" + threadName + \" exiting.\"); } public void start () { System.out.println(\"Starting \" + threadName ); if (t == null) { t = new Thread (this, threadName); t.start (); } }} public class TestThread { public static void main(String args[]) { RunnableDemo R1 = new RunnableDemo( \"Thread-1\"); R1.start(); RunnableDemo R2 = new RunnableDemo( \"Thread-2\"); R2.start(); } } 12345678910111213141516Creating Thread-1Starting Thread-1Creating Thread-2Starting Thread-2Running Thread-1Thread: Thread-1, 4Running Thread-2Thread: Thread-2, 4Thread: Thread-1, 3Thread: Thread-2, 3Thread: Thread-1, 2Thread: Thread-2, 2Thread: Thread-1, 1Thread: Thread-2, 1Thread Thread-1 exiting.Thread Thread-2 exiting. 通过继承 Thread 类本身； 创建一个线程的第二种方法是创建一个新的类，该类继承 Thread 类，然后创建一个该类的实例。 继承类必须重写 run() 方法，该方法是新线程的入口点。它也必须调用 start() 方法才能执行。 该方法尽管被列为一种多线程实现方式，但是本质上也是实现了 Runnable 接口的一个实例。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class ThreadDemo extends Thread { private Thread t; private String threadName; ThreadDemo( String name) { threadName = name; System.out.println(\"Creating \" + threadName ); } public void run() { System.out.println(\"Running \" + threadName ); try { for(int i = 4; i &gt; 0; i--) { System.out.println(\"Thread: \" + threadName + \", \" + i); // 让线程睡眠一会 Thread.sleep(50); } }catch (InterruptedException e) { System.out.println(\"Thread \" + threadName + \" interrupted.\"); } System.out.println(\"Thread \" + threadName + \" exiting.\"); } public void start () { System.out.println(\"Starting \" + threadName ); if (t == null) { t = new Thread (this, threadName); t.start (); } }} public class TestThread { public static void main(String args[]) { ThreadDemo T1 = new ThreadDemo( \"Thread-1\"); T1.start(); ThreadDemo T2 = new ThreadDemo( \"Thread-2\"); T2.start(); } }编译以上程序运行结果如下：Creating Thread-1Starting Thread-1Creating Thread-2Starting Thread-2Running Thread-1Thread: Thread-1, 4Running Thread-2Thread: Thread-2, 4Thread: Thread-1, 3Thread: Thread-2, 3Thread: Thread-1, 2Thread: Thread-2, 2Thread: Thread-1, 1Thread: Thread-2, 1Thread Thread-1 exiting.Thread Thread-2 exiting. Thread 方法下表列出了Thread类的一些重要方法： 序号 方法描述 1 public void start() 使该线程开始执行；Java 虚拟机调用该线程的 run 方法。 2 public void run() 如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。 3 public final void setName(String name) 改变线程名称，使之与参数 name 相同。 4 public final void setPriority(int priority) 更改线程的优先级。 5 public final void setDaemon(boolean on) 将该线程标记为守护线程或用户线程。 6 public final void join(long millisec) 等待该线程终止的时间最长为 millis 毫秒。 7 public void interrupt() 中断线程。 8 public final boolean isAlive() 测试线程是否处于活动状态。 测试线程是否处于活动状态。 上述方法是被Thread对象调用的。下面的方法是Thread类的静态方法。 序号 方法描述 1 public static void yield() 暂停当前正在执行的线程对象，并执行其他线程。 2 public static void sleep(long millisec) 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。 3 public static boolean holdsLock(Object x) 当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。 4 public static Thread currentThread() 返回对当前正在执行的线程对象的引用。 5 public static void dumpStack() 将当前线程的堆栈跟踪打印至标准错误流。 通过 Callable 和 Future 创建线程。 创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。 ​ 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。 ​ 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。 ​ 调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。 123456789101112131415161718192021222324252627282930313233343536public class CallableThreadTest implements Callable&lt;Integer&gt; { public static void main(String[] args) { CallableThreadTest ctt = new CallableThreadTest(); FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(ctt); for(int i = 0;i &lt; 100;i++) { System.out.println(Thread.currentThread().getName()+\" 的循环变量i的值\"+i); if(i==20) { new Thread(ft,\"有返回值的线程\").start(); } } try { System.out.println(\"子线程的返回值：\"+ft.get()); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } } @Override public Integer call() throws Exception { int i = 0; for(;i&lt;100;i++) { System.out.println(Thread.currentThread().getName()+\" \"+i); } return i; } } 创建线程的三种方式的对比 \\1. 采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。 \\2. 使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。 线程的几个主要概念 在多线程编程时，你需要了解以下几个概念： 线程同步 线程间通信 线程死锁 线程控制：挂起、停止和恢复 多线程的使用 有效利用多线程的关键是理解程序是并发执行而不是串行执行的。例如：程序中有两个子系统需要并发执行，这时候就需要利用多线程编程。 通过对多线程的使用，可以编写出非常高效的程序。不过请注意，如果你创建太多的线程，程序执行的效率实际上是降低了，而不是提升了。 请记住，上下文的切换开销也很重要，如果你创建了太多的线程，CPU 花费在上下文的切换的时间将多于执行程序的时间！ java实例​ https://www.runoob.com/java/java-examples.html java8新特性它支持函数式编程，新的 JavaScript 引擎，新的日期 API，新的Stream API 等。 Lambda表达式Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。 Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。 使用 Lambda 表达式可以使代码变的更加简洁紧凑。 语法 lambda 表达式的语法格式如下： (parameters) -&gt; expression 或 (parameters) -&gt;{ statements; } 以下是lambda表达式的重要特征: 可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。 可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。 可选的大括号：如果主体包含了一个语句，就不需要使用大括号。 可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。 Lambda 表达式实例 Lambda 表达式的简单例子: 1234567891011121314// 1. 不需要参数,返回值为 5 () -&gt; 5 // 2. 接收一个参数(数字类型),返回其2倍的值 x -&gt; 2 * x // 3. 接受2个参数(数字),并返回他们的差值 (x, y) -&gt; x – y // 4. 接收2个int型整数,返回他们的和 (int x, int y) -&gt; x + y // 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void) (String s) -&gt; System.out.print(s) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Java8Tester { public static void main(String args[]){ Java8Tester tester = new Java8Tester(); // 类型声明 MathOperation addition = (int a, int b) -&gt; a + b; // 不用类型声明 MathOperation subtraction = (a, b) -&gt; a - b; // 大括号中的返回语句 MathOperation multiplication = (int a, int b) -&gt; { return a * b; }; // 没有大括号及返回语句 MathOperation division = (int a, int b) -&gt; a / b; System.out.println(\"10 + 5 = \" + tester.operate(10, 5, addition)); System.out.println(\"10 - 5 = \" + tester.operate(10, 5, subtraction)); System.out.println(\"10 x 5 = \" + tester.operate(10, 5, multiplication)); System.out.println(\"10 / 5 = \" + tester.operate(10, 5, division)); // 不用括号 GreetingService greetService1 = message -&gt; System.out.println(\"Hello \" + message); // 用括号 GreetingService greetService2 = (message) -&gt; System.out.println(\"Hello \" + message); greetService1.sayMessage(\"Runoob\"); greetService2.sayMessage(\"Google\"); } interface MathOperation { int operation(int a, int b); } interface GreetingService { void sayMessage(String message); } private int operate(int a, int b, MathOperation mathOperation){ return mathOperation.operation(a, b); }}执行以上脚本，输出结果为：$ javac Java8Tester.java $ java Java8Tester10 + 5 = 1510 - 5 = 510 x 5 = 5010 / 5 = 2Hello RunoobHello Google 使用 Lambda 表达式需要注意以下两点： Lambda 表达式主要用来定义行内执行的方法类型接口，例如，一个简单方法接口。在上面例子中，我们使用各种类型的Lambda表达式来定义MathOperation接口的方法。然后我们定义了sayMessage的执行。 Lambda 表达式免去了使用匿名方法的麻烦，并且给予Java简单但是强大的函数化的编程能力。 java8方法引用方法引用通过方法的名字来指向一个方法。 方法引用可以使语言的构造更紧凑简洁，减少冗余代码。 方法引用使用一对冒号 :: 。 下面，我们在 Car 类中定义了 4 个方法作为例子来区分 Java 中 4 种不同方法的引用。 12345678910111213141516171819202122232425package com.runoob.main; @FunctionalInterfacepublic interface Supplier&lt;T&gt; { T get();} class Car { //Supplier是jdk1.8的接口，这里和lamda一起使用了 public static Car create(final Supplier&lt;Car&gt; supplier) { return supplier.get(); } public static void collide(final Car car) { System.out.println(\"Collided \" + car.toString()); } public void follow(final Car another) { System.out.println(\"Following the \" + another.toString()); } public void repair() { System.out.println(\"Repaired \" + this.toString()); }} 构造器引用：它的语法是Class::new，或者更一般的Class&lt; T &gt;::new实例如下： final Car car = Car.create( Car::new ); final List&lt; Car &gt; cars = Arrays.asList( car ); 静态方法引用：它的语法是Class::static_method，实例如下： cars.forEach( Car::collide ); 特定类的任意对象的方法引用：它的语法是Class::method实例如下： cars.forEach( Car::repair ); 特定对象的方法引用：它的语法是instance::method实例如下： final Car police = Car.create( Car::new ); cars.forEach( police::follow ); 12345678910111213141516import java.util.List;import java.util.ArrayList; public class Java8Tester { public static void main(String args[]){ List names = new ArrayList(); names.add(\"Google\"); names.add(\"Runoob\"); names.add(\"Taobao\"); names.add(\"Baidu\"); names.add(\"Sina\"); names.forEach(System.out::println); }} java8函数式接口函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。 函数式接口可以被隐式转换为 lambda 表达式。 Lambda 表达式和方法引用（实际上也可认为是Lambda表达式）上。 如定义了一个函数式接口如下： 12345@FunctionalInterfaceinterface GreetingService { void sayMessage(String message);} 那么就可以使用Lambda表达式来表示该接口的一个实现(注：JAVA 8 之前一般是用匿名类实现的)： 1GreetingService greetService1 = message -&gt; System.out.println(&quot;Hello &quot; + message); 接下来我们将详细为大家简介 Java 8 的新特性： 序号 特性 1 Lambda 表达式 2 方法引用 3 函数式接口 4 默认方法 5 Stream 6 Optional 类 7 Nashorn, JavaScript 引擎 8 新的日期时间 API 9 Base64","link":"/2020/03/07/java%E9%AB%98%E7%BA%A7%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/"},{"title":"jiva面向对象学习笔记二","text":"java继承 类的继承格式 在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来的，一般形式如下： 类的继承格式 1class 父类 { } class 子类 extends 父类 { } 继承的意义： 子类就不会存在重复的代码，维护性也提高，代码也更加简洁，提高代码的复用性（复用性主要是可以多次使用，不用再多次写同样的代码） 继承类型 需要注意的是 Java 不支持多继承，但支持多重继承。 继承的特性 子类拥有父类非 private 的属性、方法。 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。 Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C 类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。 继承关键字 继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 java.lang 包中，所以不需要 import）祖先类。 extends关键字: 在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。 implements关键字: 使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。 1234567891011public interface A { public void eat(); public void sleep();} public interface B { public void show();} public class C implements A,B {} super 与 this 关键字: super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。 this关键字：指向自己的引用。 final关键字: final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写： 构造器 子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表。 如果父类构造器没有参数，则在子类的构造器中不需要使用 super 关键字调用父类构造器，系统会自动调用父类的无参构造器。 java重写（Override）与重载（Overload）重写(Override) 重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！ 重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。 重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。 在面向对象原则里，重写意味着可以重写任何现有方法。实例如下： 方法的重写规则 参数列表必须完全与被重写方法的相同。 返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。 父类的成员方法只能被它的子类重写。 声明为 final 的方法不能被重写。 声明为 static 的方法不能被重写，但是能够被再次声明。 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。 构造方法不能被重写。 如果不能继承一个方法，则不能重写这个方法。 Super 关键字的使用 当需要在子类中调用父类的被重写方法时，要使用 super 关键字。 重载(Overload) 重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。 每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。 最常用的地方就是构造器的重载。 重载规则: 被重载的方法必须改变参数列表(参数个数或类型不一样)； 被重载的方法可以改变返回类型； 被重载的方法可以改变访问修饰符； 被重载的方法可以声明新的或更广的检查异常； 方法能够在同一个类中或者在一个子类中被重载。 无法以返回值类型作为重载函数的区分标准。 ​ 重写与重载之间的区别 区别点 重载方法 重写方法 参数列表 必须修改 一定不能修改 返回类型 可以修改 一定不能修改 异常 可以修改 可以减少或删除，一定不能抛出新的或者更广的异常 访问 可以修改 一定不能做更严格的限制（可以降低限制） 总结 方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。 (1)方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。 (2)方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。 (3)方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。 java多态多态是同一个行为具有多个不同表现形式或形态的能力。 多态就是同一个接口，使用不同的实例而执行不同操作，如图所示： 多态性是对象多种表现形式的体现。 多态的优点 \\1. 消除类型之间的耦合关系 \\2. 可替换性 \\3. 可扩充性 \\4. 接口性 \\5. 灵活性 \\6. 简化性 多态存在的三个必要条件 继承 重写 父类引用指向子类对象 比如： 1Parent p = new Child(); 当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。 多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。 :basketball_man:多态的实现方式 方式一：重写： Java 重写(Override)与重载(Overload)。 方式二：接口 \\1. 生活中的接口最具代表性的就是插座，例如一个三接头的插头都能接在三孔插座中，因为这个是每个国家都有各自规定的接口规则，有可能到国外就不行，那是因为国外自己定义的接口类型。 \\2. java中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现。具体可以看 java接口 这一章节的内容。 方式三：抽象类和抽象方法 java抽象类如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。 由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。 在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。 抽象类 在Java语言中使用abstract class来定义抽象类。 继承抽象类 我们能通过一般的方法继承Employee类： 抽象方法 如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。 Abstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。 抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。 12345678910public abstract class Employee{ private String name; private String address; private int number; public abstract double computePay(); //其余代码} 声明抽象方法会造成以下两个结果： 如果一个类包含抽象方法，那么该类必须是抽象类。 任何子类必须重写父类的抽象方法，或者声明自身为抽象类。 继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。 如果Salary类继承了Employee类，那么它必须实现computePay()方法： 抽象类总结规定 \\1. 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。 \\2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 \\3. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。 \\4. 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。 \\5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。 java封装在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。 封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。 要访问该类的代码和数据，必须通过严格的接口控制。 封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。 适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。 封装的优点 \\1. 良好的封装能够减少耦合。 \\2. 类内部的结构可以自由修改。 \\3. 可以对成员变量进行更精确的控制。 \\4. 隐藏信息，实现细节。 实现Java封装的步骤 修改属性的可见性来限制对属性的访问（一般限制为private），例如： 1234public class Person { private String name; private int age;} 这段代码中，将 name 和 age 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。 2、对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问，例如： 123456789101112131415161718public class Person{ private String name; private int age; public int getAge(){ return age; } public String getName(){ return name; } public void setAge(int age){ this.age = age; } public void setName(String name){ this.name = name; }} 采用 this 关键字是为了解决实例变量（private String name）和局部变量（setName(String name)中的name变量）之间发生的同名的冲突。 通常情况下，这些方法被称为getter和setter方法。 因此，任何要访问类中私有成员变量的类都要通过这些getter和setter方法。 java接口接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。 接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。 除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。 接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。 接口与类相似点： 一个接口可以有多个方法。 接口文件保存在 .java 结尾的文件中，文件名使用接口名。 接口的字节码文件保存在 .class 结尾的文件中。 接口相应的字节码文件必须在与包名称相匹配的目录结构中。 接口与类的区别： 接口不能用于实例化对象。 接口没有构造方法。 接口中所有的方法必须是抽象方法。 接口不能包含成员变量，除了 static 和 final 变量。 接口不是被类继承了，而是要被类实现。 接口支持多继承。 接口特性 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。 接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。 抽象类和接口的区别 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。 一个类只能继承一个抽象类，而一个类却可以实现多个接口。 注：JDK 1.8 以后，接口里可以有静态方法和方法体了。 接口的声明 接口的声明语法格式如下： 1234[可见度] interface 接口名称 [extends 其他的接口名] { // 声明变量 // 抽象方法} Interface关键字用来声明一个接口。 接口有以下特性： 接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。 接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字。 接口中的方法都是公有的。 接口的实现 当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。 类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。 重写接口中声明的方法时，需要注意以下规则： 类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。 类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。 如果实现接口的类是抽象类，那么就没必要实现该接口的方法。 在实现接口的时候，也要注意一些规则： 一个类可以同时实现多个接口。 一个类只能继承一个类，但是能实现多个接口。 一个接口能继承另一个接口，这和类之间的继承比较相似。 接口的继承 一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。 下面的Sports接口被Hockey和Football接口继承： 1234567891011121314151617181920212223// 文件名: Sports.javapublic interface Sports{ public void setHomeTeam(String name); public void setVisitingTeam(String name);} // 文件名: Football.javapublic interface Football extends Sports{ public void homeTeamScored(int points); public void visitingTeamScored(int points); public void endOfQuarter(int quarter);} // 文件名: Hockey.javapublic interface Hockey extends Sports{ public void homeGoalScored(); public void visitingGoalScored(); public void endOfPeriod(int period); public void overtimePeriod(int ot);} Hockey接口自己声明了四个方法，从Sports接口继承了两个方法，这样，实现Hockey接口的类需要实现六个方法。 相似的，实现Football接口的类需要实现五个方法，其中两个来自于Sports接口。 接口的多继承 在Java中，类的多继承是不合法，但接口允许多继承。 在接口的多继承中extends关键字只需要使用一次，在其后跟着继承接口。 如下所示： 1public interface Hockey extends Sports, Event 以上的程序片段是合法定义的子接口，与类不同的是，接口允许多继承，而 Sports及 Event 可能定义或是继承相同的方法 标记接口 最常用的继承接口是没有包含任何方法的接口。 标记接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。 标记接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。 例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下： 123package java.util;public interface EventListener{} 没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的： 建立一个公共的父接口： 正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。 向一个类添加数据类型： 这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。 java包（package）包的作用 1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。 2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。 3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。 Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。 包语句的语法格式为： 1234567package pkg1[．pkg2[．pkg3…]];例如：package net.java.util;public class Something{ ...} 创建包 创建包的时候，你需要为这个包取一个合适的名字。之后，如果其他的一个源文件包含了这个包提供的类、接口、枚举或者注释类型的时候，都必须将这个包的声明放在这个源文件的开头。 包声明应该在源文件的第一行，每个源文件只能有一个包声明，这个文件中的每个类型都应用于它。 如果一个源文件中没有使用包声明，那么其中的类，函数，枚举，注释等将被放在一个无名的包（unnamed package）中。 例子 让我们来看一个例子，这个例子创建了一个叫做animals的包。通常使用小写的字母来命名避免与类、接口名字的冲突。 在 animals 包中加入一个接口（interface）： 1234567/* 文件名: Animal.java */package animals; interface Animal { public void eat(); public void travel();} 接下来，在同一个包中加入该接口的实现： 1234567891011121314151617181920212223package animals; /* 文件名 : MammalInt.java */public class MammalInt implements Animal{ public void eat(){ System.out.println(\"Mammal eats\"); } public void travel(){ System.out.println(\"Mammal travels\"); } public int noOfLegs(){ return 0; } public static void main(String args[]){ MammalInt m = new MammalInt(); m.eat(); m.travel(); }} import 关键字 为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。使用 “import” 语句可完成此功能。 在 java 源文件中 import 语句应位于 package 语句之后，所有类的定义之前，可以没有，也可以有多条，其语法格式为： 1import package1[.package2…].(classname|*); 如果在一个包中，一个类想要使用本包中的另一个类，那么该包名可以省略。","link":"/2020/03/07/jiva%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/"},{"title":"markdown学习笔记","text":"markdown笔记 - 常用快捷键加粗 Ctrl + B斜体 Ctrl + I引用 Ctrl + Q插入链接 Ctrl + L插入代码 Ctrl + K插入图片 Ctrl + G提升标题 Ctrl + H有序列表 Ctrl + O无序列表 Ctrl + U横线 Ctrl + R撤销 Ctrl + Z重做 Ctrl + Y Markdown标题： 这是一级标题这是二级标题一级标题二级标题三级标题四级标题五级标题六级标题字体斜体文本斜体文本粗体文本粗体文本粗斜体文本粗斜体文本 分隔线 删除线 下划线 [^脚注]：markdown中的说明 markdown列表 无序列表 第一项 第二项 第三项 第一项 第二项 第三项 第一项 第二项 第三项 有序列表1.第一项： -嵌套 -嵌套2.第二项：3.第三项： markdown区块 区块引用 我的笔记 加油 markdown代码一个函数或者片段的代码 代码区块使用 4 个空格或者一个制表符（Tab 键）12345public class HelloWorld{ pulic static void main(String[] args){ System.out.println(\"Hello World!\"); }} markdown连接链接名称 或者 https://music.163.com/#/my/m/music/playlist?id=2061638738 链接也可以用变量来代替，文档末尾附带变量地址：这个链接用 1 作为网址变量 Google 然后在文档的结尾为变量赋值（网址） markdown图片 markdown表格 表头 表头 单元格 单元格 单元格 单元格 markdown高级技巧不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。 目前支持的 HTML 元素有： 等使用 Ctrl+Alt+Del 重启电脑 转义文本加粗** 正常显示星号 ** 123456789st=&gt;start: 开始框op=&gt;operation: 处理框cond=&gt;condition: 判断框(是或否?)sub1=&gt;subroutine: 子流程io=&gt;inputoutput: 输入输出框e=&gt;end: 结束框st(right)-&gt;op(right)-&gt;condcond(yes)-&gt;io(bottom)-&gt;econd(no)-&gt;sub1(right)-&gt;op","link":"/2020/03/07/markdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"linux学习笔记","text":"linux学习笔记 1 shell家族shell：命令解释器，根据输入的命令执行相应命令。 察看当前系统下有哪些shell： 1cat /etc/shells 察看当前系统正在使用的shell。 1echo $SHELL 常见shell： 123456/bin/sh (已经被 /bin/bash 所取代)/bin/bash (就是 Linux 默认的 shell)/bin/ksh (Kornshell 由 AT&amp;T Bell lab. 发展出来的，兼容于 bash)/bin/tcsh (整合 C Shell ，提供更多的功能)/bin/csh (已经被 /bin/tcsh 所取代)/bin/zsh (基于 ksh 发展出来的，功能更强大的 shell) 1.2 bashbash 是一个为GNU计划编写的Unix shell。它的名字是一系列缩写：Bourne-Again SHell — 这是关于Bourne shell（sh）的一个双关语（Bourne again / born again）bash 是 许 多 Linux 平 台 的 内 定 Shell， 事 实 上， 还 有 许 多 传 统 UNIX 上 用 的 Shell， 像 tcsh、csh、ash、bsh、ksh等等，Shell Script大致都类同，当您学会一种Shell以后，其 它的Shell会很快就上手，大多数的时候，一个Shell Script通常可以在很多种Shell上使用。 bash是大多数Linux系统以及Mac OS X v10.4默认的shell，它能运行于大多数Unix风格 的操作系统之上，甚至被移植到了Microsoft Windows上的Cygwin系统中，以实现windows的POSIX虚拟接口。此外，它也被DJGPP项目移植到了MS-DOS上。 1.3 命令和路径补齐在bash下敲命令时，Tab键可以补全已经敲了一部分的文件名和目录名。如果是Ubuntu 系统，系统默认启用了bash completion，还可以补全命令的某些参数、Makefile目标等 等。如果是Debian系统，可以用以下命令启用bash completion： 1$ source /etc/bash_completion 建议将这一行加入∼/.bashrc启动脚本中。比如使用sudo后面接命令，如果没有bash completion则只有sudo可以补全，后面的命令不能补全。如果启用了bash completion，则 后面的命令，包括命令的某些参数（比如aptitude命令的install）都可以补全了。 比如在主目录下要列出桌面目录的内容，输入（不回车） 1$ ls De 然后敲Tab键，如果以De开头的文件或文件夹只有Desktop一个，就自动补全为 1$ ls Desktop 否则，再敲一次Tab键，将会把所有以De开头的文件或文件夹列在下面供你选择(在这里 我们手动创建另外一个以De开头的文件) 123$ touch Death$ ls DeDeath Desktop/ 你可以再补敲一个s再Tab，这次Desktop就会补全到命令后面了。有 的 人 是 从 DOS 时 代 过 来 的， 留 下 一 个 很 不 好 的 习 惯 就 是 在 找 一 个 文 件 时 反 复 地cd、ls、cd、ls等找到了要找的文件时再想回到先前的目录，已经不记得先前是 从哪个目录转到这里来的了。 我们从上面可以看出，Tab补全本身就具备了ls的功能，上面的Tab补全相当于ls -Fd De*命令。所以我们完全不必反复地cd到别的目录然后ls去找文件，多按几次Tab就可以一条 命令完成了，这样的好处是我们的当前目录不用变，不需要找完了文件再cd回来，同时省去 了大量的按键次数。更重要的是，自动补全同时兼具了检查拼写错误的功能，如果前面几个 字母拼写错了，就补全不出东西来，用户就知道拼写错了，如果前面几个字母没有拼写错， 那么由系统补全出来的文件名肯定也不会有拼写错误，避免了用户在敲很长的文件名时易犯 的拼写错误。 1.4 历史记录1history 历史记录是另外一个非常方便的功能。按上下移动光标键（或者Ctrl-p、Ctrl-n）可以 一条一条浏览以前输过的命令。如果有需要重复输入的命令就不用输第二次了。如果你能记 住以前输过的某条命令中的某个关键字，可以按Ctrl-r，然后输入关键字，随着你每输入一 个字母，bash会做增量式（increasingly）查找，也可以反复按Ctrl-r或Ctrl-s向前向后查 找。如果找到了，按左右移动光标键或Home键(Ctrl-a)或End键(Ctrl-e)将该命令带回提示 符下进一步修改，或者直接按Enter键原封不动地执行该命令。 1.5 主键盘快捷键bash的快捷键和emacs保持一致，用惯其中之一再用另一个程序会很顺手的。请记住一条原则：尽量使用主键盘快捷键而不使用移动光标键和编辑键。因为手不必离开主键盘是效 率最高的，这样在你一生之中所节省的来回移动手的时间绝对可以用星期来计算，是绝对值 得你花十分钟的时间记住这些快捷键的。 功能 快捷键 助记 上 Ctrl-p previous 下 Ctrl-n next 左 Ctrl-b backward 右 Ctrl-f forward Del Ctrl-d delete光标后面的 Home Ctrl-a the first letter End Ctrl-e end Backspace Backspace delete光标前面的 目录和文件2.1 类Unix系统目录结构ubuntu没有盘符这个概念，只有一个根目录/，所有文件都在它下面 123456789101112131415161718/ 根目录bin //系统可执行程序，如命令boot //内核和启动程序，所有和启动相关的文件都保存在这里 grub //引导器相关文件dev //设备文件etc //系统软件的启动和配置文件，系统在启动过程中需要读取的文件都在这个目录。如LILO参数、用 户账户和密码。home //用户的主目录。下面是自己定义的用户名的文件夹lib //系统程序库文件,这个目录里存放着系统最基本的动态链接共享库，类似于Windows下的system32 目录，几乎所有的应用程序都需要用到这些共享库。media //挂载媒体设备，如光驱、U盘等mnt //目录是让用户临时挂载别的文件系统，如挂载Windows下的某个分区，ubuntu默认还是挂载在/media 目录。opt //可选的应用软件包（很少使用）proc //这个目录是系统内存的映射，我们可以直接访问这个目录来获取系统信息。也就是说，这个目录 的内容不在硬盘上而是在内存里。sbin //管理员系统程序 selinuxsrvsys //udev用到的设备目录树，/sys反映你机器当前所接的设备 tmp //临时文件夹usr //这是个最庞大的目录，我们要用到的很多应用程序和文件几乎都存放在这个目录下。] bin // 应用程序game //游戏程序 includelib //应用程序的库文件 lib64local //包含用户程序等 sbin //管理员应用程序 2.2 用户目录位于/home/user，称之为用户工作目录或家目录,表示方式： 12/home/user~ 2.2.1 相对路径和绝对路径绝对路径 从/目录开始描述的路径为绝对路径，如： 1cd /home ls /usr 相对路径 从当前位置开始描述的路径为相对路径，如： 1cd ../../ ls abc/def .和.. 每个目录下都有.和... 表示当前目录.. 表示上一级目录，即父目录 根目录下的.和..都表示当前目录 2.3 ls1ls [OPTION]… [FILE]… ls是英文单词list的简写，其功能为列出目录的内容。这是用户最常用的一个命令，因 为用户需要不时地查看某个目录的内容。该命令类似于DOS下的dir命令。 对于每个目录， 该命令将列出其中的所有子目录与文件。对于每个文件，ls将输出其文件名以及所要求的其 他信息。默认情况下，输出条目按字母顺序排序。当未给出目录名或是文件名时，就显示当 前目录的信息。 主要的OPTION有： 123-a 列出隐藏文件，文件中以“.”开头的均为隐藏文件，如：~/.bashrc-l 列出文件的详细信息-R 连同子目录中的内容一起列出 用ls -l命令显示的信息中，开头是由10个字符构成的字符串，其中第一个字符表示文 件类型，它可以是下述类型之一： 12345- 普通文件 d 目录l 符号链接b 块设备文件c 字符设备文件s socket文件，网络套接字 p 管道 后面的9个字符表示文件的访问权限，分为3组，每组3位。第一组表示文件属主的权 限，第二组表示同组用户的权限，第三组表示其他用户的权限。每一组的三个字符分别表示 对文件的读、写和执行权限。各权限如下所示： 123456r 读w 写x 可执行。对于目录，表示进入权限。s 当文件被执行时，把该文件的UID或GID赋予执行进程的UID（用户ID）或GID（组 ID）。t 设置标志位（sticky bit）。如果是有sticky bit的目录，在该目录下任何用户只要有适当的权限即可创建文 件，但文件只能被超级用户、目录拥有者或文件属主删除。如果是有sticky bit的可执行文件，在该文件执行后， 指向其正文段的指针仍留在内存。这样再次执行它时，系统就能更快地装入该文件。- 没有相应位置的权限。 访问权限后面的数字表示与该文件共享inode的文件总数，即硬链接数(参见下面ln命 令)。 2.4 cdchange dir 改变当前所在路径 12cd ~cd dir1/dir2 cd .. 2.5 which查看指定命令所在路径 1which ls 2.6 pwd查看当前所在路径 1pwd 2.7 mkdir1mkdir [OPTION] DIRECTORY… 创建目录DIRECTORY，可以一次创建多个。OPTION如果是-p，表示可以连同父目录一起 创建。 2.8 rmdir1rmdir [OPTION]… DIRECTORY… 删除空目录，可以一次删除多个。OPTION如果是-p，表示可以连同空的父目录一起删 除。mkdir和rmdir的用法举例： 12345678910$ mkdir a$ mkdir a/b$ ls a b$ rmdir a/b$ ls a$ rmdir a$ mkdir a/bmkdir: cannot create directory `a/b': No such file or directory$ mkdir -p a/b$ rmdir -p a/b 2.9 touch1touch [OPTION]… FILE… 将每个文件的访问及修改时间都更新为目前的时间。 如果文件不存在，则创建一个字节数为0的文件。 2.10 rm删除文件： 1rm file 删除目录： 1rm dir -rf 2.11 mv重命名： 1mv file1 file2 移动文件: 1mv file1 ~/ 2.12 cp拷贝文件： 1cp file1 file2 cp file1 dir/ cp file1 ../ 拷贝目录: 1cp dir1 dir2 -r cp dir1 ~/ -r 2.13 cat查看文件里内容，输出到终端，如果cat时没跟文件名，则读标准输入，遇到\\n后，输 出到标准输出，终端下输入Ctrl-d表示结束 2.14 more1more [OPTION] FILE… 查看文本文件的内容，屏幕显示完一屏就等待用户按下任意键再滚动到下一屏，如果中 途不想继续看下去了，可以按Ctrl+C或q终止显示。 2.15 less1less [OPTION] FILE… 查看文本文件的内容，屏幕显示完一屏就等待用户按键，用户可以向上或向下查看，如 果中途不想继续看下去了，可以按Ctrl+C或q终止显示。 2.16 headhead [OPTION]… FILE… 显示指定文件的前面几行。如果没有指定文件，将从标准输入（键盘）上读取。如果没有指定要显示的行数，则默认显示前10行。如果要显示文件的前5行： 1$ head -5 file1 2.17 tailtail [OPTION]… FILE… 显示文件的最后几行。若没有指定显示的行或字符数，则默认显示末尾10行。如果要显示文件末5行： 1$ tail -5 file1 2.18 ln链接有两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。建立硬链接时，链接文件和被链接文件必须位于同一个文件系统中，并且不能建立 指向目录的硬链接。而对符号链接，则不存在这个问题。默认情况下，ln产生硬链接。如果 给ln命令加上-s选项，则建立符号链接。举例如下，注意ls -l列出文件的硬链接数和字节 数： 硬链接： 12touch helloln hello word_h 软链接： 1ln -s hello word_s 2.19 tree这个命令需要下载安装，ubuntu下 1sudo apt-get install tree 按结构树的形状显示目录和文件 2.20 wc利用 wc 指令我们可以计算文件的 Byte 数、字数、或是列数,若不指定文件名称、或 是所给予的文件名为“-”,则 wc 指令会从标准输入设备读取数据。 1wc -l ./* -c 或–bytes 或–chars 只显示 Bytes 数。-l 或–lines 只显示列数。-w 或–words 只显示字数。 2.21 od1od -tcx file1 -t 指定数据的显示格式，主要的参数有：c ASCII字符或反斜杠序列d[SIZE] 有符号十进制数,每个整数SIZE字节。 f[SIZE] 浮点数,每个整数SIZE字节。o[SIZE] 八进制（系统默认值为02）,每个整数SIZE字节。 u[SIZE] 无符号十进制数,每个整数SIZE字节。x[SIZE] 十六进制数,每个整数SIZE字节。 2.22 du查看某个目录的大小： 以M为单位 1du -hm /home/sihai/test 以B为单位 1du -hb ./* 以K为单位,4k的整数倍 1du -hk ./* 2.23 dfdf查看磁盘使用情况 1df --block-size=GB df --block-size=MB 文件属性和用户用户组3.1 whoami查看当前登陆用户 3.2 chmod 文字设定法 chmod [who] [+|-|=] [mode] 文件名 操作对象who可是下述字母中的任一个或者它们的组合： u 表示“用户（user）”，即文件或目录的所有者。g 表示“同组（group）用户”，即与文件属主有相同组ID的所有用户。 o 表示“其他（others）用户”。a 表示“所有（all）用户”。它是系统默认值。 操作符号可以是： +添加某个权限。 -取消某个权限。 = 赋予给定权限并取消其他所有权限（如果有的话）。 设置mode所表示的权限可用下述字母的任意组合： r 可读。 w 可写。x 可执行。 数字设定法 chmod [mode] 文件名 我们必须首先了解用数字表示的属性的含义： 0表示没有权限，1表示可执行权限，2表示可写权限，4表示可读权限， 然后将其相加。所以数字属性的格式应为3个从0到7的八进制数，其顺序是（u）（g）（o）。 例如，如果想让某个文件的属主有“读/写”二种权限，需要把4（可读）+2（可写）＝ 6（读/写）。 比如设置一个文件允许所有用户可写 1$ chmod a+w file1 设置一个文件允许所有用户可读、可写、不可执行 1$ chmod 666 file1 3.3 chown chown [OPTION]… [OWNER:GROUP] FILE… chown [OPTION]… –reference=RFILE FILE… 更改某个文件或目录的属主和属组。这个命令也很常用。例如root用户把自己的一个文件拷贝给用户A, 为了让用户A能够存取这个文件，root用户应该把这个文件的属主设为A， 否则，用户A无法存取这个文件。 OPTION的主要参数： -R 递归式地改变指定目录及其下的所有子目录和文件的拥有者。 -v 显示chown命令所做的工作。 比如把一个文件改为sihai用户和nogroup用户组所有 1$ sudo chown sihai:nogroup file1 注意： chown需要特权用户才能执行 一个文件的owner和owning group是没有关联的。一个文件属于用户A，也属于用户组 B，并不表示用户A属于用户组B。 3.4 chgrp chgrp [OPTION]… GROUP FILE… chgrp [OPTION]… –reference=RFILE FILE… 该命令改变（指定）指定文件所属的用户组。其中group可以是用户组ID，也可以是/etc/group文件中用户组的组名。 文件名是以空格分开的要改变属组的文件列表，支持通配 符。如果用户不是该文件的属主或超级用户，则不能改变该文件的组。 OPTION的主要参数： -R 递归式地改变指定目录及其下的所有子目录和文件的属组。 查找与检索4.1 find根据文件名查找 find [OPTION] path… [expression] 在目录中搜索文件，path指定目录路径，系统从这里开始沿着目录树向下查找文件。它是一个路径列表，相互用空格分离，如果不写path，那么默认为当前目录。Expression 是 find命令接受的表达式，find命令的所有操作都是针对表达式的。 一条最常用的find命令－－在当前目录及子目录下查找所有以file开头的文件名。 1234567$ find . -name 'file*'$ find / -name 'vimrc'$ find ~ -name '*.c' 4.2 grep根据内容检索 1grep [options] PATTERN [FILE...] 在指定文件中搜索特定的内容，并将含有这些内容的行输出到标准输出。若不指定文件 名，则从标准输入读取。[options]部分包含的主要参数： -c：只输出匹配行的计数。 -I：不区分大小写（只适用于单字符）。 -h：查询多文件时不显示文件名。 -l：查询多文件时只输出包含匹配字符的文件名。 -n：显示匹配行及行号。 -s：不显示不存在或无匹配文本的错误信息。 -v：显示不包含匹配文本的所有行。 -R: 连同子目录中所有文件一起查找。 比如到系统头文件目录下查找所有包含printf的文件 1$ grep 'printf' /usr/include -R 安装卸载软件5.1 apt-get更新源服务器列表 1sudo vi /etc/apt/sources.list 更新完服务器列表后需要更新下源 sudo apt-get update 更新源sudo apt-get install package 安装包sudo apt-get remove package 删除包sudo apt-cache search package 搜索软件包sudo apt-cache show package 获取包的相关信息，如说明、大小、版本等 sudo apt-get install package –reinstall 重新安装包sudo apt-get -f install 修复安装sudo apt-get remove package –purge 删除包，包括配置文件等 sudo apt-get build-dep package 安装相关的编译环境sudo apt-get upgrade 更新已安装的包 sudo apt-get dist-upgrade 升级系统sudo apt-cache depends package 了解使用该包依赖那些包 sudo apt-cache rdepends package 查看该包被哪些包依赖 sudo apt-get source package 下载该包的源代码sudo apt-get clean &amp;&amp; sudo apt-get autoclean 清理无用的包 sudo apt-get check 检查是否有损坏的依赖 5.2 deb包安装 安装deb软件包命令： sudo dpkg -i xxx.deb删除软件包命令： sudo dpkg -r xxx.deb连同配置文件一起删除命令： sudo dpkg -r –purge xxx.deb查看软件包信息命令： sudo dpkg -info xxx.deb查看文件拷贝详情命令： sudo dpkg -L xxx.deb查看系统中已安装软件包信息命令： sudo dpkg -l重新配置软件包命令： sudo dpkg-reconfigure xxx 5.3 原码安装 解压缩源代码包 cd dir ./configure 检测文件是否缺失，创建Makefile,检测编译环境 make 编译源码，生成库和可执行程序 sudo make install 把库和可执行程序，安装到系统路径下 磁盘管理6.1 mount命令格式： mount [-t vfstype] -o options device dir 其中： -t vfstype 指定文件系统的类型，通常不必指定。mount 会自动选择正确的类型。常 用类型有： 光盘或光盘镜像：iso9660 DOS fat16文件系统：msdos Windows 9x fat32文件系统：vfat Windows NT ntfs文件系统：ntfs Mount Windows文件网络共享：smbfs UNIX(LINUX) 文件网络共享：nfs -o options 主要用来描述设备或档案的挂接方式。常用的参数有： loop：用来把一个文件当成硬盘分区挂接上系统ro：采用只读方式挂接设备rw：采用读写方式挂接设备 iocharset：指定访问文件系统所用字符集 device 要挂接(mount)的设备。 dir设备在系统上的挂接点(mount point)。 6.1.1 挂接光盘镜像文件由 于 近 年 来 磁 盘 技 术 的 巨 大 进 步， 新 的 电 脑 系 统 都 配 备 了 大 容 量 的 磁 盘 系 统， 在 Windows下许多人都习惯把软件和资料做成光盘镜像文件通过虚拟 光驱来使用。这样做有 许多好处：一、减轻了光驱的磨损;二、现在硬盘容量巨大存放几十个光盘镜像文件不成问 题，随用随调十分方便;三、硬盘的读取速度要远 远高于光盘的读取速度，CPU占用率大大 降低。其实linux系统下制作和使用光盘镜像比Windows系统更方便，不必借用任何第三方软 件包。 1.从光盘制作光盘镜像文件。将光盘放入光驱，执行下面的命令。 1cp /dev/cdrom /home/sunky/mydisk.iso 或 1dd if=/dev/cdrom of=/home/sunky/mydisk.iso 注：执行上面的任何一条命令都可将当前光驱里的光盘制作成光盘镜像文件/home/ sunky/mydisk.iso 2.文件和目录制作成光盘镜像文件，执行下面的命令。 1mkisofs -r -J -V mydisk -o /home/sunky/mydisk.iso /home/sunky/ mydir 注：这条命令将/home/sunky/mydir目录下所有的目录和文件制作成光盘镜像文件/ home/sunky/mydisk.iso，光盘卷标为：mydisk 3.光盘镜像文件的挂接(mount) 1mkdir /mnt/vcdrom 注：建立一个目录用来作挂接点(mount point) 1mount -o loop -t iso9660 /home/sunky/mydisk.iso /mnt/vcdrom 注：使用/mnt/vcdrom就可以访问盘镜像文件mydisk.iso里的所有文件了。 6.1.2 挂载U盘1.检测存储设备名称 1sudo fdisk -l 2.挂载存储设备sdb1到挂载点/mnt目录 1sudo mount /dev/sdb1 /mnt 3.访问/mnt 4.卸载/mnt 1sudo umount /mnt 6.2 umount卸载命令 1sudo umount 挂在点 6.3 dddd:拷贝 例1：拷贝光碟(注意，你的光碟是标准的 iso9660格式才可以这么做) 1dd if=/dev/cdrom of=cdrom.iso 例2：将文件sfile拷贝到文件 dfile中。 1$ dd if=sfile of=dfile 例3：创建一个100M的空文件 1dd if=/dev/zero of=hello.txt bs=100M count=1 /dev/null，外号叫无底洞，你可以向它输出任何数据，它通吃，并且不会撑着！ /dev/zero,是一个输入设备，你可你用它来初始化文件,从里面读出来的数据都是0。 压缩包管理7.1 tartar [主选项+辅选项] 文件或者目录 tar可以为文件和目录创建档案。 利用tar命令用户可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。使用该命令时，主选项是 必须要有的，辅选项是辅助使用的，可以选用。 主选项包括： c 创建新的档案文件。如果用户想备份一个目录或是一些文件，就要选择这个选项。 r 把要存档的文件追加到档案文件的未尾。 t 列出档案文件的内容，查看已经备份了哪些文件。 u 更新文件。用新增的文件取代原备份文件，如果在备份文件中找不到要更新的文件，则把它追加到备份文件的最 后。 x 从档案文件中释放文件。（常用） 辅选项包括： f 使用档案文件或设备，这个选项通常是必选的。（常用） k 保存已经存在的文件。 m 在还原文件时，把所有文件的修改时间设定为现在。 M 创建多卷的档案文件，以便在几个磁盘中存放。 v 详细报告tar处理的文件信息。如无此选项，tar不报告文件信息。（常用） w 每一步都要求确认。 z 用gzip来压缩/解压缩文件，加上该选项后可以将档案文件进行压缩，但还原时也一定要使用该选项进行解压 缩。（常用） j 用bzip2来压缩/解压缩文件，加上该选项后可以将档案文件进行压缩，但还原时也一定要使用该选项进行解压 缩。（常用） 要将文件备份到一个特定的设备，只需把设备名作为备份文件名。 打包： 1tar cvf dir.tar dir tar xvf dir.tar dir 打gz压缩包： 1tar zcvf dir.tar.gz dir tar zxvf dir.tar.gz 打bz2压缩包: 1tar jcvf dir.tar.bz2 dir tar jxvf dir.tar.bz2 指定目录解压缩： 1tar zxvf dir.tar.gz -C ~/test 7.2 rar打包：把dir压缩成newdir.rar 1rar a -r newdir dir 解包：把newdir.rar解压缩到当前目录 1unrar x newdir.rar ####7.3zip打包： 1zip -r dir.zip dir 解包： 1unzip dir.zip 进程管理8.1 who查看当前在线上的用户情况。所有的选项都是可选的，不使用任何选项时，who命令将 显示以下三项内容： login name：登录用户名； terminal line：使用终端设备； login time：登录到系统的时间。 12345sihai@ubuntu:~/demo$ who -uH名称 线路 时间 空闲 进程号 备注 sihai tty2 2014-08-14 13:31 . 6798sihai tty7 2014-08-14 01:31 旧 2423sihai pts/1 2014-08-14 01:31 12:00 2843 (:0)sihai pts/3 2014-08-14 10:39 . 2843 (:0) ####8.2 ps ps [选项] ps命令用于监控后台进程的工作情况，因为后台进程是不和屏幕键盘这些标准输入/输 出设备进行通信的，所以如果需要检测其情况，便可以使用ps命令了。选项部分如下： -e 显示所有进程。 -f 全格式。 -h 不显示标题。 -l 长格式。 -w 宽输出。 a 显示终端上的所有进程，包括其他用户的进程。 r 只显示正在运行的进程。 x 显示没有控制终端的进程。 这个命令参数有很多，但一般的用户只需掌握一些最常用的命令参数就可以了。 最常用的三个参数是u、a、x， 我们首先以root身份登录系统，查看当前进程状况 1234567891011121314sihai@ubuntu:~$ ps auxUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 1 0.0 0.0 3672 2008 ? Ss 08:46 0:01 /sbin/initsihai@ubuntu:~$ ps ajxPPID PID PGID SID TTY TPGID STAT UID TIME COMMAND 4592 6948 6948 4592 pts/3 6948 R+ 1000 0:00 ps ajxsihai@ubuntu:~$ ps -Lf 2423UID PID PPID LWP C NLWP STIME TTY STAT TIME CMD1000 2423 2282 2423 0 4 08:46 ? Ssl 0:00 gnome-session --session=ubuntu1000 2423 2282 2465 0 4 08:46 ? Ssl 0:00 gnome-session --session=ubuntu1000 2423 2282 2466 0 4 08:46 ? Ssl 0:00 gnome-session --session=ubuntu1000 2423 2282 2468 0 4 08:46 ? Ssl 0:00 gnome-session --session=ubuntu Head标头： USER 用户名UID 用户ID（User ID）PID 进程ID（Process ID）PPID 父进程的进程ID（Parent Process id） SID 会话ID（Session id）%CPU 进程的cpu占用率%MEM 进程的内存占用率VSZ 进程所使用的虚存的大小（Virtual Size）RSS 进程使用的驻留集大小或者是实际内存的大小，Kbytes字节。 TTY 与进程关联的终端（tty）STAT 进程的状态：进程状态使用字符表示的（STAT的状态码）R 运行 Runnable (on run queue) 正在运行或在运行队列中等待。S 睡眠 Sleeping 休眠中, 受阻, 在等待某个条件的形成或接受到信号。 I 空闲 IdleZ 僵死 Zombie（a defunct process) 进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调 用后释放。D 不可中断 Uninterruptible sleep (ususally IO) 收到信号不唤醒和不可运行, 进程必须等待直到有中 断发生。T 停止 Terminate 进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行。 P 等待交换页W 无驻留页 has no resident pages 没有足够的记忆体分页可分配。 X 死掉的进程&lt; 高优先级进程 高优先序的进程N 低优先 级进程 低优先序的进程L 内存锁页 Lock 有记忆体分页分配并缩在记忆体内 s 进程的领导者（在它之下有子进程）；l 多进程的（使用 CLONE_THREAD, 类似 NPTL pthreads） 位于后台的进程组START 进程启动时间和日期 TIME 进程使用的总cpu时间COMMAND 正在执行的命令行命令 NI 优先级(Nice)PRI 进程优先级编号(Priority)WCHAN 进程正在睡眠的内核函数名称；该函数的名称是从/root/system.map文件中获得的。 FLAGS 与进程相关的数字标识 8.4 fg fg [job…] 把指定的后台作业或挂起作业移到前台运行。 参数job是一个或多个进程的PID，或者 是命令名称，或者是作业号（作业号前面要带一个%号）。 通常在shell中输入命令启动进程后，如果该进程需要与用户交互，那么此后用户的键 盘输入都被该进程读取，直到该进程退出后才出现shell提示符$，这种进程为前台进程。 如果在命令行的末尾加上&amp;字符，则shell为这个命令创建一个后台进程，它虽然也可以 输出到屏幕，但是不能读取键盘输入，不管执行命令的进程有没有退出都立刻回到shell提 示符接受下一条命令的输入。如果该进程也需要读取键盘输入，则被挂起等待直到用户用fg 命令把它变成前台进程。如果一个命令需要较长的处理时间并且不需要与用户交互，就适合 把它放在后台执行。 8.5 bg bg [job…] 把被挂起的进程提到后台执行。 其中，job是一个或多个进程的PID、命令名称或者作 业号，在参数前要带%号。 8.6 kill向指定进程发送信号 kill [ -signal | -s signal ] pid … 查看信号编号 1kill -l [ signal ] 给一个进程发信号，或终止一个进程的运行。 kill命令如果不带参数而直接跟pid，就是发给该进程SIGTERM信号，大部分进程收到该 信号就会终止。但是被挂起的进程不能处理信号，所以必须发SIGKILL信号，由系统强制终 止进程。 8.7env查看当前进程环境变量 1$env vim ∼/.bashrc 配置当前用户环境变量 vim /etc/profile 配置系统环境变量,配置时需要有root权限 用户管理9.1 创建用户1sudo useradd -s /bin/bash -g sihai -d /home/sihai -m sihai sudo useradd -s /bin/sh -g group -G adm,root xwp 此命令新建了一个用户xwp，该用户的登录Shell是/bin/sh，他属于group用户组，同时 又属于adm和root用户组，其中group用户组是其主组。 -s 指定新用户登陆时shell类型 -g 指定所属组，该组必须已经存在 -G 指定附属组，该组必须已经存在 -d 用户家目录 -m 用户家目录不存在时，自动创建该目录 9.2 设置用户组1sudo groupadd sihai 9.3 设置密码1sudo passwd sihai 9.4 切换用户 su 用户名 1su sihai 9.5 root用户变成root用户 1sudo su 设置root密码 1passwd 9.6 删除用户 userdel 选项 用户名 常用的选项是-r，他的作用是把用户的主目录一起删除。 例如： 1sudo userdel -r sihai 此命令删除用户sihai在系统文件（主要是/etc/passwd，/etc/shadow，/etc/ group等）中的记录，同时删除用户的主目录。 网络管理10.1 ifconfig1.查看网卡信息 1ifconfig 2.关闭网卡 1sudo ifconfig eth0 down 3.开启网卡eth0 1sudo ifconfig eth0 up 4.给eth0配置临时IP 1sudo ifconfig eth0 IP 10.2ping ping [选项] 主机名/IP地址 查看网络上的主机是否在工作。它向该主机发送ICMP ECHO_REQUEST包。有时我们想从网络上的某台主机上下载文件，可是又不知道那台主机是否开着，就需要使用ping命令查看。 命令中各选项的含义如下： -c 数目 在发送指定数目的包后停止。-d 设定SO_DEBUG的选项。-f 大量且快速地送网络封包给一台机器，看它的回应。-I 秒数 设定间隔几秒送一个网络封包给一台机器，预设值是一秒送一次。-l 次数 在指定次数内，以最快的方式送封包数据到指定机器（只有超级用户可以使用此选项）。-q 不显示任何传送封包的信息，只显示最后的结果。-r 不经由网关而直接送封包到一台机器，通常是查看本机的网络接口是否有问题。-s 字节数 指定发送的数据字节数，预设值是56，加上8字节的ICMP头，一共是64ICMP数据字节。 10.3netstat netstat [选项] 显示网络连接、路由表和网络接口信息，可以让用户得知目前都有哪些网络连接正在运 作。命令中各选项的含义如下： -a 显示所有socket，包括正在监听的。-c 每隔1秒就重新显示一遍，直到用户中断它。-i 显示所有网络接口的信息，格式同“ifconfig -e”。-n 以网络IP地址代替名称，显示出网络连接情形。-r 显示核心路由表，格式同“route -e”。-t 显示TCP协议的连接情况。-u 显示UDP协议的连接情况。-v 显示正在进行的工作。 ####10.4nslookup nslookup name 查询一台机器的IP地址和其对应的域名。它通常需要一台域名服务器来提供域名服务。 如果用户已经设置好域名服务器，就可以用这个命令查看不同主机的IP地址对应的域名。 不带参数使用nslookup命令时，出现提示符“&gt;”，在后面输入要查询的IP地址或域名 并回车即可。如果要退出该命令，输入exit并回车即可。 1234sihai@ubuntu:~$ nslookup&gt; www.sihai.cnServer: 127.0.0.1Address: 127.0.0.1#53 10.5 fingerfinger [-lmsp] user [user@host …] 查询用户的信息，通常会显示系统中某个用 户的用户名、主目录、停滞时间、登录时间、登录shell等信息。如果要查询远程机上的用 户信息，需要在用户名后面接“@主机名”，采用[用户名@主机名]的格式，不过要查询的网 络主机需要运行finger守护进程。 命令中各选项的含义如下： -s 显示用户的注册名、实际姓名、终端名称、写状态、停滞时间、登录时间等信息。-l 除了用-s选项显示的信息外，还显示用户主目录、登录shell、邮件状态等信息，以 及用户主目录下的.plan、.project和.forward文件的内容。-p 除了不显示.plan文件和.project文件以外，与-l选项相同。 1234567sihai@ubuntu:~$ finger sihaiLogin: sihai Name: sihaiDirectory: /home/sihai Shell: /bin/bashOn since Mon Sep 8 08:55 (CST) on tty7 14 hours 48 minutes idle On since Mon Sep 8 21:57 (CST) on pts/1 from :011 minutes 18 seconds idleOn since Mon Sep 8 23:12 (CST) on pts/2 from :0 6 seconds idleNo mail. No Plan. 常用服务器构建11.1 ftp11.1.1ftp服务器1.安装vsftpd服务器 1sudo apt-get install vsftpd 2.配置vsftpd.conf文件 1sudo vi /etc/vsftpd.conf 添加下面设置 1234567anonymous_enable=YES anon_root=/home/sihai/ftp no_anon_password=YES write_enable=YES anon_upload_enable=YES anon_mkdir_write_enable=YES anon_umask=0022 3.重启服务器，重新加载/etc/vsftpd.conf配置文件 123456ubuntu12.04下sudo /etc/init.d/vsftpd restartubuntu14.04下sudo /lib/init/upstart-job vsftpd restart 4.进入你的/home/sihai/ftp目录下创建一个空目录，供用户上传 123cd ~/ftpmkdir anonymous chmod 777 anonymous 5.测试上传功能，登陆ftp服务器，进入到anonymous目录 12ftp IPcd anonymous 6.上传命令，可以把你当前目录下的文件上传到ftp服务器的anonymous目录 12put somefile get somefile 11.1.2 ftp客户端Ubuntu 默认已经安装ftp客户端 11.1.3 lftp客户端lftp 也 是 一 种 ftp 客 户 程 序。 它 是 以 文 本 方 式 操 作 的， 但 是 比 起 图 形 界 面 更 为 方 便。lftp几乎具有bash的所有方便功能，Tab 补全，bookmark, queue, 后台下载等可以 得到支持。用法与ftp类似，主要的指令如下： put 上传文件mput 上传多个文件 get 下载文件mget 下载多个文件mirror 下载整个目录及其子目录 mirror –R 上传整个目录及其子目录!command 调用本地shell执行命令command 注意，有的发行版可能缺省没有安装lftp工具，需要用户自己安装。如果是Debian或 Ubuntu系统，则安装lftp软件包。 1sudo apt-get install lftp 11.2 nfs1.安装nfs服务器 1sudo apt-get install nfs-kernel-server 2.设置/etc/exports配置文件 1sudo vi /etc/exports 添加这行配置 1/home/用户名/nfs *(rw,sync,no_root_squash) 3.在用户目录下创建nfs目录 1mkdir /home/用户名/nfs 4.重启服务器，重新加载配置文件 1sudo /etc/init.d/nfs-kernel-server restart 5.在/home/用户名/nfs目录下创建测试文件hello 1cd /home/用户名/nfs touch hello 6.测试服务器，把服务器共享目录nfs挂在到/mnt节点 1sudo mount -t nfs -o nolock -o tcp IP:/home/用户名/nfs /mnt 7.进入/mnt目录可以看到hello文件，表示构建成功 8.卸载网络共享目录 1sudo umount /mnt 11.3ssh1.安装ssh服务器 1sudo apt-get install openssh-server 2.远程登陆 1ssh 用户名@IP 其它命令12.1 终端翻页12Shift-pageup Shift-pagedown 12.2 man看手册(叫做manual或man page)。每一个命令和系统函数都有自己的man page。 12man manman read 查看read命令的man page 1man 2 read 查看read系统函数的man page(在第二个section中，表示为read(2)) man -k read 以read为关键字查找相关的man page 12.3 clear清屏。使光标和提示符回到屏幕第一行。 快捷键：Ctrl-l ####12.4 aliasalias [-p] name=value … 将 value 字 符 串 起 个 别 名 叫 name， 以 后 在 命 令 行 输 入 name，shell 自 动 将 其 解 释 为value，如果不带参数执行本命令，或以参数-p执行，则显示当前定义的别名列表。 12$ aliasalias ls='ls --color=auto' alias rm='rm -i' 12.5 echo echo [-n] 字符串 在显示器上显示一段文字，一般起到一个提示的作用。其中选项n表示输出文字后不换 行；字符串可以加引号，也可以不加引号。用echo命令输出加引号的字符串时，将字符串原 样输出；用echo命令输出不加引号的字符串时，将字符串中的各个单词作为字符串输出，各 字符串之间用一个空格分割。 查看上一个程序退出数值，正常情况程序退出值是0 1echo $? 12.6 date查看当前时间 12.7 umask umask [-p] -S [mode] umask指定用户创建文件时的掩码，其中的mode和chmod的命令中的格式一样。如果不用 mode参数，则显示当前的umask设置。如果用-S参数，则以符号形式显示设置。 12$ umask 0022$ umask -S u=rwx,g=rx,o=rx 比如该用户touch或gedit创建一个文件，则其默认权限为-rw-r-r–，如果该用户创 建一个可执行文件(比如编译生成的程序)，则其默认权限为-rwxr-xr-x。也就是说，由于 umask的设定，创建的文件默认是不具有g的w权限和o的w权限的，除非用chmod更改权限。 12.8 创建终端创建终端标签 1Ctrl + Shift + t 切换标签 1Alt+n（n=1） 新开终端 1Ctrl + Shift + n 关机重启关机重启这些操作都需要有root权限 13.1 poweroff13.2 shutdown shutdown -t 秒数 [-rkhncfF] 时间 [警告讯息] 选项： -t 秒数 : 设定在切换至不同的runlevel之前, 警告和删除二讯号之间的延迟时间(秒).-k : 仅送出警告讯息文字, 但不是真的要 shutdown.-r : shutdown 之後重新开机-h : shutdown 之後关机.-n : 不经过 init , 由 shutdown 指令本身来做关机动作.(不建议你用)-f : 重新开机时, 跳过 fsck 指令, 不检查档案系统.-F : 重新开机时, 强迫做 fsck 检查.-c : 将已经正在 shutdown 的动作取消. 例子: 1234shutdown -r now 立刻重新开机 shutdown -h now 立刻关机shutdown -k now 'Hey! Go away! now....' 发出警告讯息, 但没有真的关机 shutdown -t3 -r now 立刻重新开机, 但在警告和删除processes 之间, 延迟3秒钟. shutdown -h 10:42 'Hey! Go away!' 10:42 分关机shutdown -r 10 'Hey! Go away!' 10 分钟後关机shutdown -c 将刚才下的 shutdown 指令取消,必须切换至其它tty, 登入之後, 才能下此一指令. shutdown now 切换至单人操作模式(不加任何选项时) 注意事项:时间参数务必要加: 不是用 now, 便是用 hh:mm 或 mm now 其实就是 0 的意思. 13.3 reboot13.4 查看内核版本信息1uname -a 13.5 查看发行版信息1lsb_release -a 13.6 查看空闲内存1free -m vim16.1 vi简介vi是“Visual interface”的简称，它在Linux上的地位就仿佛Edit程序在DOS上一样。 它可以执行输出、删除、查找、替换、块操作等众多文本操作，而且用户可以根据自己的需 要对其进行定制。Vi不是一个排版程序，它不象Word或WPS那样可以对字体、格式、段落等 其他属性进行编排，它只是一个文本编辑程序。 vi没有菜单，只有命令，且命令繁多。 Vi有三种基本工作模式： 命令模式 文本输入模式 末行模式。 16.1.1 命令行模式任何时候，不管用户处于何种模式，只要按一下ESC键，即可使Vi进入命令模式；我们 在shell环境(提示符为$)下输入启动Vi命令，进入编辑器时，也是处于该模式下。在该模式 下，用户可以输入各种合法的Vi命令，用于管理自己的文档。此时从键盘上输入的任何字符 都被当做编辑命令来解释，若输入的字符是合法的Vi命令，则Vi在接受用户命令之后完成相 应的动作。但需注意的是，所输入的命令并不在屏幕上显示出来。若输入的字符不是Vi的合 法命令，Vi会响铃报警。 16.1.2 文本输入模式在命令模式下输入插入命令i、附加命令a 、打开命令o、修改命令c、取代命令r或替换 命令s都可以进入文本输入模式。在该模式下，用户输入的任何字符都被Vi当做文件内容保 存起来，并将其显示在屏幕上。在文本输入过程中，若想回到命令模式下，按键ESC即可。 16.1.3 末行模式末行模式也称ex转义模式。在命令模式下，用户按“:”键即可进入末行模式下，此时 Vi会在显示窗口的最后一行(通常也是屏幕的最后一行)显示一个“:”作为末行模式的提示 符，等待用户输入命令。多数文件管理命令都是在此模式下执行的(如把编辑缓冲区的内容 写到文件中等)。末行命令执行完后，Vi自动回到命令模式。例如： 1:sp newfile 则分出一个窗口编辑newfile文件。如果要从命令模式转换到编辑模式，可以键入命令a 或者i；如果需要从文本模式返回，则按Esc键即可。在命令模式下输入“:”即可切换到末 行模式，然后输入命令。 16.2 vim基础操作进入插入模式: i: 插入光标前一个字符 I: 插入行首a: 插入光标后一个字符 A: 插入行未o: 向下新开一行,插入行首 O: 向上新开一行,插入行首 进入命令模式: ESC:从插入模式或末行模式进入命令模式 移动光标: h: 左移 j: 下移 k: 上移 l: 右移M: 光标移动到中间行L: 光标移动到屏幕最后一行行首 G: 移动到指定行,行号 -Gw: 向后一次移动一个字 b: 向前一次移动一个字{: 按段移动,上移}: 按段移动,下移 Ctr-d: 向下翻半屏 Ctr-u: 向上翻半屏 Ctr-f: 向下翻一屏 Ctr-b: 向上翻一屏gg: 光标移动文件开头 G: 光标移动到文件末尾 删除命令: x: 删除光标后一个字符,相当于 DelX: 删除光标前一个字符,相当于 Backspacedd: 删除光标所在行,n dd 删除指定的行数 D: 删除光标后本行所有内容,包含光标所在字符 d0: 删除光标前本行所有内容,不包含光标所在字符dw: 删除光标开始位置的字,包含光标所在字符 撤销命令: u: 一步一步撤销U: 一次性撤销当前行所作的所有操作 Ctr-r: 反撤销 重复命令: .: 重复上一次操作的命令 文本行移动: : 文本行右移 &lt;&lt;: 文本行左移 复制粘贴: yy: 复制当前行,n yy 复制 n 行p: 在光标所在位置向下新开辟一行,粘贴 可视模式: v: 按字符移动,选中文本V: 按行移动,选中文本可视模式可以配合 d, y, &gt;&gt;, &lt;&lt; 实现对文本块的删除,复制,左右移动 替换操作: r: 替换当前字符R: 替换当前行光标后的字符 查找命令: /: str查找n: 下一个N：上一个 替换命令： 把abc全部替换成123 1:%s/abc/123/g 代码排版: gg=G: 代码自动缩进排版 16.3 vim分屏操作分屏操作: sp: 上下分屏,后可跟文件名vsp: 左右分屏,后可跟文件名Ctr+w+w: 在多个窗口切换 启动分屏 1.使用大写O参数进行垂直分屏 1$ vim -On file1 file2 ... 2.使用小写o参数进行水平分屏 1$ vim -on file1 file2 ... 注: n是数字，表示分屏的数量,n要大于等于文件个数 关闭分屏 1.关闭当前窗口 1ctrl+w c 2.关闭当前窗口，如果只剩最后一个，则退出vim 1ctrl+w q 编辑中分屏 1.上下分割当前打开的文件 1ctrl+w s 2.上下分割，并打开一个新的文件 1:sp filename 3.左右分割当前打开的文件 1ctrl+w v 4.左右分割，并打开一个新的文件 1:vsp filename 分屏编辑中光标的移动 vi中的光标键是h,j,k,l,要在各个屏之间切换，只需要先按一下ctrl+w 1.把光标移动到上边的屏 1ctrl+w k 2.把光标移动到下边的屏 1ctrl+w j 3.把光标移动到右边的屏 1ctrl+w l 4.把光标移动到左边的屏 1ctrl+w h 5.把光标移动到下一个的屏 1ctrl+w w 移动分屏 1.向上移动 1ctrl+w K 2.向下移动 1ctrl+w J 3.向右移动 1ctrl+w L 4.向左移动 1ctrl+w H 屏幕尺寸 1.增加高度 1ctrl+w + 2.减少高度 1ctrl+w - 3.让所有屏的高度一致 1ctrl+w = 4.左加宽度 1ctrl+w &gt; 5.右加宽度 1ctrl+w &lt; 6.右增加n宽 (如：n=30) 1ctrl+w n &lt;","link":"/2020/03/07/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"windows系统重装","text":"今天帮好朋友重装系统。总结一下收获吧。简单记录一下 重装系统U盘制作工具有很多方法，例如： 一、借助工具制作 大白菜一键U盘装系统，小白一键装系统等等， 其中大白菜在多数人中的呼声更高。 今天尝试了一下，好像也还行， 不足就是也有捆绑软件在里面携带安装 包括360全家桶，腾讯视频等（对作者表示理解，这些软件安装后可以自行删除即可）注：不建议用小白重装系统弄，亲测不好用 制作U盘启动盘 很详细的教程，照着做绝对没问题 二、window纯净安装原版系统 * 找到官网 点击下载 剩下的就很简单了，一步一步往下走就好。 如果不懂的可以看看视频教程 win10小技巧： 屏幕键盘：win+r 输入osk 截图： win+shift+s","link":"/2020/03/29/windows%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85/"},{"title":"小程序之JavaScript","text":"Console.log打印日志: console.log(321*3) console.log打印数组Array: console.log([“肖申克的救赎”,”霸王别姬”,”这个杀手不太冷”,”阿甘正传”,”美丽人生”][3]) console.log打印对象Object: console.log({name: “霸王别姬”,img:”https://img3.doubanio.com/view/photo/s_ratio_poster/public/p1910813120.webp&quot;,desc: “风华绝代。”}.desc) 变量与赋值: let movie={name: “霸王别姬”,img: “https://img3.doubanio.com/view/photo/s_ratio_poster/public/p1910813120.webp&quot;,desc: “风华绝代。”}console.log(movie)console.log(movie.name)通过将复杂的数据信息（数组、对象）赋值给一个变量，代码得到了大大的简化，可以深刻了解到变量是用于存储信息的”容器”。 变量的冲突与覆盖: 声明了一个变量名之后，就不能再次声明这个变量名啦。但是我们却可以给该变量重新赋值 操作数组movielist=[“肖申克的救赎”,”霸王别姬”,”这个杀手不太冷”,”阿甘正传”,”美丽人生”] 分隔符join方法： join方法将数组元素拼接为字符串,以分隔符分割，默认是逗号,分割。console.log(movielist.join(“、”)) 添加数组push方法：console.log(movielist.push(“千与千寻”,”泰坦尼克号”,”辛德勒的名单”,”盗梦空间”,”忠犬八公的故事”)) 移除最后一项pop方法：console.log(movielist.pop()) 操作对象用点表示法访问对象的属性，通过给该属性赋值就能够添加和修改对象的属性的值了 给对象添加属性：直接赋值 删除对象的某个属性： 用delete方法 delete movie.img 更新对象的某个属性： 重新赋值 常量const defaultStyle = { color: ‘#7A7E83’, selectedColor: ‘#3cc51f’, backgroundColor: ‘#ffffff’,} 字符串的操作 123456789101112let lesson=\"云开发技术训练营\";let enname=\"CloudBase Camp\"console.log(lesson.length); //返回字符串的长度console.log(lesson[4]); //返回在指定位置的字符console.log(lesson.charAt(4)); //返回在指定位置的字符console.log(lesson.substring(3,6)); //从索引3开始到6（不包括6）console.log(lesson.substring(4)); //从索引4开始到结束console.log(enname.toLowerCase()); //把一个字符串全部变为小写：console.log(enname.toUpperCase()); //把一个字符串全部变为大写：console.log(enname.indexOf('oud')); //搜索指定字符串出现的位置：console.log(enname.concat(lesson)); //连接两个字符串console.log(lesson.slice(4)); //提取字符串的某个部分，并以新的字符串返回被提取的部分 Math方法 Math是一个内置对象， 它具有数学常数和函数的属性和方法，但它不是一个函数对象。 123456789let x=3,y=4,z=5.001,a=-3,b=-4,c=-5;console.log(Math.abs(b)); //返回b的绝对值console.log(Math.round(z));//返回z四舍五入后的整数console.log(Math.pow(x,y)) //返回x的y次幂console.log(Math.max(x,y,z,a,b,c)); //返回x,y,z,a,b,c的最大值console.log(Math.min(x,y,z,a,b,c));//返回x,y,z,a,b,c的最小值console.log(Math.sign(a)); //返回a是正数还是负数console.log(Math.hypot(x,y)); //返回所有x,y的平方和的平方根 console.log(Math.PI); //返回一个圆的周长与直径的比例，约3.1415 Date对象 123456789console.log(now.getFullYear()); //从 Date 对象以四位数字返回年份。console.log(now.getMonth()); //从 Date 对象返回月份 (0 ~ 11)。console.log(now.getDate()); //从 Date 对象返回一个月中的某一天 (1 ~ 31)。console.log(now.getDay()); //从 Date 对象返回一周中的某一天 (0 ~ 6)。console.log(now.getHours()); //返回 Date 对象的小时 (0 ~ 23)。console.log(now.getMinutes()); //返回 Date 对象的分钟 (0 ~ 59)。console.log(now.getSeconds()); //返回 Date 对象的秒数 (0 ~ 59)。console.log(now.getMilliseconds()); //返回 Date 对象的毫秒(0 ~ 999)。console.log(now.getTime()); //返回 1970 年 1 月 1 日至今的毫秒数。 全局对象 wx是小程序的全局对象，用于承载小程序能力相关API。 https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/api.html#API eg:获取网络类型技术文档 12345wx.getNetworkType({ success(res) { console.log(res) }}); 获取用户信息技术文档：wx.getUserInfo() 获取设备信息技术文档：wx.getSystemInfo() 页面跳转技术文档：wx.navigateTo() 页面返回技术文档：wx.navigateBack() 显示消息提示框技术文档：wx.showToast() 设置标题技术文档：wx.setNavigationBarTitle() 打开文件选择技术文档：wx.chooseImage() 点击事件事件是视图层到逻辑层的通信方式，当我们点击tap、触摸touch、长按longpress小程序绑定了事件的组件时，就会触发事件，执行逻辑层中对应的事件处理函数。 消息提示框Toast消息提示框是移动端App、H5(WebApp)、小程序经常会使用到的一个交互界面。在tapevent.wxml输入代码： 12 &lt;button type=\"primary\" bindtap=\"toastTap\"&gt;点击弹出消息对话框&lt;/button&gt; 在js里输入以下代码： 1234567toastTap() { wx.showToast({ title: '购买成功',//显示内容，必填 icon: 'success', //sucess , loading , none duration: 2000 //提示延迟的时间，默认为1500毫秒，也就是1.5秒 }) }, 模态对话框技术文档：wx.showModal(Object object) 手机振动 长振动技术文档：wx.vibrateLong() 弹出操作菜单：弹出菜单技术文档：wx.showActionSheet(Object object)](https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.showActionSheet.html) 页面路由 页面路由API Navigator open-type值 含义 redirectTo redirect 关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面。 navigateTo navigate 保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面。 navigateBack navigateBack 关闭当前页面，返回上一页面或多级页面。 switchTab switchTab 跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面 reLaunch reLaunch 关闭所有页面，打开到应用内的某个页面 navigateTo, redirectTo 只能打开非 tabBar 页面。 switchTab 只能打开 tabBar 页面。 reLaunch 可以打开任意页面。 页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。 调用页面路由带的参数可以在目标页面的onLoad中获取。 在前面我们提到bintap是小程序所有组件的公有属性，只有bintap绑定了页面路由切换的事件处理函数，组件是不是Navigator也就不重要了，也就是链接跳转不再是Navigator组件的专利。 注意这里的url的路径，我们使用的是相对于小程序根目录的绝对路径。app.json的pages配置项前面没有/是因为app.json本来就在根目录，所以可以使用相对路径以及这里的取值，以及API很多参数的字符串String类型的赋值，单引号和双引号都是没有影响的。 返回上一页 返回上一页 12345navigateBack() { wx.navigateBack({ delta: 1 })}, wx.navigateTo 是保留当前页面、跳转到应用内的某个页面，使用 wx.navigateBack可以返回到原页面。对于页面不是特别多的小程序，且页面间存在经常切换时，推荐使用 wx.navigateTo进行跳转， 然后返回，提高加载速度。 页面渲染将变量值渲染到页面 响应的数据绑定data.wxml 123&lt;view style=\"background-color:{{bgcolor}};width:400rpx;height:300rpx;\"&gt;&lt;/view&gt;&lt;button bindtap=\"redTap\"&gt;让背景变红&lt;/button&gt;&lt;button bindtap=\"yellowTap\"&gt;让背景变黄&lt;/button&gt; data.js 123456789101112bgcolor:\"#000000\",redTap:function(){ this.setData({ bgcolor: \"#cd584a\" })},yellowTap:function(){ this.setData({ bgcolor: \"#f8ce5f\" })}, 响应的布尔操作 data.wxml: 123&lt;video id=\"daxueVideo\" src=\"http://wxsnsdy.tc.qq.com/105/20210/snsdyvideodownload?filekey=30280201010421301f0201690402534804102ca905ce620b1241b726bc41dcff44e00204012882540400&amp;bizid=1023&amp;hy=SH&amp;fileparam=302c020101042530230204136ffd93020457e3c4ff02024ef202031e8d7f02030f42400204045a320a0201000400\" autoplay loop muted=\"{{muted}}\" initial-time=\"100\" controls event-model=\"bubble\"&gt;&lt;/video&gt;&lt;button bindtap=\"changeMuted\"&gt;静音和取消静音&lt;/button&gt; data.js: 1234567 muted: true,changeMuted: function (e) { this.setData({ muted: !this.data.muted })}, 响应的数组操作 函数与调用函数 函数的作用，可以写一次代码，然后反复地重用这个代码。JavaScript的函数本身也是对象，因此可以把函数赋值给变量，或者作为参数传递给其他函数。 123function 函数名(参数 1, 参数 2, 参数 3) { 代码块内要执行的语句} 1234function greet() { console.log(\"你好，欢迎来到云开发训练营\");};greet(); //调用greet()函数 对象的方法 在小程序里我们会经常将一个匿名函数赋值给对象的一个属性，而这个属性我们可以称之为对象的方法。 匿名函数 1234let square = function(number) { return number * number};console.log(square(4))//使用console.log()输出变量square 箭头函数 123456const multiply = (x, y) =&gt; { return x * y;}const sum= (x, y) =&gt; x + y;//连{}和return语句都可以省掉console.log(multiply(20, 4));console.log(sum(20, 4)); 在控制台我们可以看到箭头函数打印的结果。箭头函数相当于匿名函数，它没有函数名，而且也简化了函数定义。箭头函数可以只包含一个表达式，甚至连{ … }和return都可以省略掉。 调用对象的方法 点表示法 JavaScript 函数的写法 12345scrollToPosition() {},或yellowTap:function(){}, currentTarget就是事件对象的一个属性，我们可以使用点表示法获取到点击的组件的Id，并将其赋值给activeIndex，所谓active就是激活的意思，也就是我们点击哪个tab，哪个tab就激活。 生命周期:basketball: 获取url参数的生命周期函数onload / 分隔目录和子目录 ? 分隔实际的URL和参数 &amp; URL中指定的参数间的分隔符 = URL中指定的参数的值 # 同一个页面的位置标识符，类似于页面的书签； 数据跨页面 跨页面数据渲染 :basketball:组件携带数据dataset 组件有公有属性和私有属性，这些属性都是数据，事件处理函数可以修改这些属性，从而让组件有丰富的表现形式。 使用JavaScript代替Navigator组件 自定义属性dataset 点击组件显示当前组件其他数据 :basketball:小程序和页面的生命周期 App()函数注册小程序，Page()函数注册小程序中的一个页面，他们都接受的是对象Object类型的参数，包含一些生命周期函数和事件处理函数。App() 必须在 app.js 中调用，必须调用且只能调用一次。开发者可以添加任意的函数或数据变量到 Object参数中，用 this 可以访问。 小程序构造器：App(Object object) 页面构造器：Page(Object object) 使用开发者工具在app.js里给onLaunch、onShow、onHide添加一些打印日志。 123456789onLaunch(opts) { console.log('onLaunch监听小程序初始化。',opts)},onShow(opts) { console.log('onShow监听小程序启动或切前台',opts)},onHide() { console.log('onHide监听小程序切后台')}, onLaunch与onShow onLaunch是监听小程序的初始化，初始化完成时触发，全局只会触发一次，所以在这里我们可以用来执行获取用户登录信息的函数等一些非常核心的数据，如果onLaunch的函数过多，会影响小程序的启动速度。 onShow是在小程序启动，或从后台进入前台显示时触发，也就是它会触发很多次，在这里就不大适合放获取用户登录信息的函数啦。这两者的区别要注意。 :basketball:globalData 这个数据是在app.js里，和我们之前接触到的数据都在页面的js文件里有不同。而且这个用户信息的数据是所有页面都通用的，放在app.js里公用是应该的，但是我们要怎么才能调用到这个数据呢？ globalData对象通常用来存放整个小程序都会使用到的数据，比如我们可以把用户信息赋值给globalData的任意自定义属性。 getApp() 数据表单设置导航栏标题 wx.setNavigationBarTitle() onLoad调用API 12345onLoad: function (options) { wx.setNavigationBarTitle({ title:\"onLoad触发修改的标题\" }) }, button调用API 123456789.wxml&lt;button type=\"primary\" bindtap=\"buttonSetTitle\"&gt;设置标题&lt;/button&gt;.js buttonSetTitle(e){ console.log(e) wx.setNavigationBarTitle({ title: \"button触发修改的标题\" }) }, 使用表单修改标题 小程序一个完整的数据表单收集通常包含一个form组件，一个输入框或选择器组件（比如input组件），一个button组件。 1234&lt;form bindsubmit=\"setNaivgationBarTitle\"&gt; &lt;input type=\"text\" placeholder=\"请输入页面标题并点击设置即可\" name=\"navtitle\"&gt;&lt;/input&gt; &lt;button type=\"primary\" formType=\"submit\"&gt;设置&lt;/button&gt;&lt;/form&gt; 1234567setNaivgationBarTitle(e) { console.log(e) const navtitle = e.detail.value.navtitle wx.setNavigationBarTitle({ title:navtitle })}, 文本输入框input 12345678&lt;form bindsubmit=\"inputSubmit\"&gt; &lt;input type=\"text\" name=\"username\" placeholder=\"请输入你的用户名\"&gt;&lt;/input&gt; &lt;input password type=\"text\" name=\"password\" maxlength=\"6\" placeholder=\"请输入6位数密码\" confirm-type=\"next\" /&gt; &lt;input type=\"idcard\" name=\"idcard\" placeholder=\"请输入你的身份证账号\" /&gt; &lt;input type=\"number\" name=\"age\" placeholder=\"请输入你的年龄\" /&gt; &lt;input type=\"digit\" name=\"height\" placeholder=\"请输入你身高多少米\"/&gt; &lt;button form-type=\"submit\"&gt;提交&lt;/button&gt;&lt;/form&gt; input输入框会因为属性的类型的不同，手机键盘外观会有比较大的差异，所以需要点击预览，用微信扫描二维码在手机上体验（也可以启用真机调试）。 input输入框支持的type值有文本输入text、数字输入number、身份证输入idcard、小数点输入digit，当type不同时，注意手机键盘外观的不同； placeholder:输入框为空时的占位符（也就是默认值）；maxlength：最大输入长度；password和disabled都是boolean值，使用方法和之前的video组件里面的boolean属性一样。 在开发者工具的控制台我们可以看到打印的事件对象里的value对象，属性名即为input的name名，值即为我们输入的数据。如果没有name。 小任务：给input输入框配置confirm-type，分别输入send、search、next、go、done，然后点击预览，用微信扫描二维码体验，注意输入内容时，手机键盘显示的不同。 表单组件组合一个完整的数据收集表单，除了可以提交input文本框里面的数据，还可以提交开关选择器按钮switch、滑动选择器按钮slider、单选按钮radio、多选按钮checkbox等组件里面的数据。 input绑定事件处理函数bindinput响应式数据渲染 剪切板设置剪切板内容wx.setClipboardData()、获取剪切板内容wx.getClipboardData() 图片、缓存与文件获取手机相册或拍照的图片 wx.chooseImage() 上传一张照片 12345678910111213141516171819202122232425file.wxml&lt;button bindtap=\"chooseImg\"&gt;选择图片&lt;/button&gt;&lt;image mode=\"widthFix\" src=\"{{imgurl}}\"&gt;&lt;/image&gt;&lt;view&gt;上传的图片&lt;/view&gt;file.js data: { imgurl:\"\", }, chooseImg:function(){ let that=this wx.chooseImage({ count: 1, sizeType: ['original', 'compressed'], sourceType: ['album', 'camera'], success(res) { const imgurl = res.tempFilePaths that.setData({ imgurl }) } }) }, count：可以选择的照片数量，默认为9张（由于imgurl声明的是字符串，多张照片需为数组Array，后面有上传多张图片的案例） sourceType：选择图片的来源，album就是图片可以来自手机相册；而camera是可以来自手机拍照，两个都写就是来自相册或拍照都可以； sizeType：所选的图片的尺寸，original为原图，compressed为压缩图，为了减轻服务器压力，建议为压缩图； tempFilePaths为临时文件的路径列表，tempFiles为临时文件列表，注意这两个值都为数组。 操作图片 wx.getImageInfo() 123456789回调函数经过之前的学习，相信大家对回调函数success、fail有了一定的认识，那什么是回调函数呢？简单一点说就是：回调Callback是指在另一个函数执行完成之后被调用的函数。success、fail就都是在小程序的API函数执行完成之后，才会被调用，而success和fail它们本身也是函数，也能返回数据。而复杂一点说，就是回调函数本身就是函数，但是它们却被其他函数给调用，而调用函数的函数被称为高阶函数。这些大家只需要粗略了解就可以了。异步与同步我们前面也提及过异步，那什么会有异步呢？因为JavaScript是单线程的编程语言，就是从上到下、一行一行去执行代码，类似于排队一样一个个处理，第一个不处理完，就不会处理后面的。但是遇到网络请求、I/O操作（比如上面的读取图片信息）以及定时函数（后面会涉及）以及类似于成功反馈的情况，等这些不可预知时间的任务都执行完再处理后面的任务，肯定不行，于是就有了异步处理。把要等待其他函数执行完之后，才能执行的函数（比如读取图片信息）放到回调函数里，先不处理，等图片上传成功之后再来处理，这就是异步。比如wx.showToast()消息提示框，可以放到回调函数里，当API调用成功之后再来显示提示消息。回调函数相当于是异步的一个解决方案。 预览所有上传的图片 wx.previewImage() 123456789101112.wxml&lt;view wx:if=\"{{hasImg === true}}\"&gt; &lt;button bindtap=\"previewImg\"&gt;预览照片&lt;/button&gt;&lt;/view&gt;.js previewImg:function(){ wx.previewImage({ current: '', urls: this.data.imgurl, }) }, 保存图片到相册 wx.saveImageToPhotosAlbum() 压缩图片 小程序是有压缩图片的API的wx.compressImage()，尤其是在上传图片时，为了减轻存储服务器的压力，不能让用户上传分辨率过高的照片。 上传文件 wx.chooseMessageFile() 上传地理位置 wx.chooseLocation() 模块化与格式化 数据缓存Storage wx.setStorageSync()、wx.getStorageSync() 保存文件技术文档：wx.saveFile() 注意：尽管上传图片和上传文件都是把图片或文件先上传到临时文件里，但是保存图片wx.saveImageToPhotosAlbum()和保存文件wx.saveFile()是完全不同的概念，保存图片是把图片保存到手机本地相册；而保存文件则是把图片由临时文件移动到本地存储里，而本地存储每个小程序用户只有10M的空间。 网络API数据API 渲染网络数据到页面 聚合API：一个比较全面的综合性API服务平台 即速API：也是提供一些综合性的API服务 V2EX API：v2ex论坛是很多程序员经常会光顾的综合性技术论坛 CNode API：Nodejs交流论坛 和风天气：含天气预报、空气质量、实况天气等数据 Github API：Github是所有程序员都（必须）会使用的网站 知乎日报API：知乎日报API分析","link":"/2020/03/15/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8BJavaScript/"},{"title":"三体经典语录","text":"弱小和无知，不是生存的障碍，傲慢才是 1、你的无畏来源于无知。 2、孩子问，他们是烈士吗？妈妈说，不是。他们是敌人吗？不是，那他们是什么？他们是历史！ 3、死亡是一座永恒的灯塔，不管你驶向何方，最终都会朝它转向。一切都将逝去，只有死神永生。 4、我们都是阴沟里的虫子,但总还是得有人仰望星空。 5、弱小和无知，不是生存的障碍，傲慢才是。 6、碑是那么小，与其说是为了纪念，更像是为了忘却。 7、人生的美妙之处在于迷上一样东西。人生苦短，少做些虚无缥缈的事。 8、记忆是一条早已干涸的河流，只在毫无生气的河床中剩下零落的砾石。 9、夜晚的灯塔一直都在，只是灯亮的时候，你才看见它。 10、城市就是森林，每一个男人都是猎手，每一个女人都是陷阱。 11、要知道，一个文学人物十分钟的行为，可能是她十年的经历的反映。 12、知道在哪儿，世界就变得像一张地图那么小了；不知道在哪儿，感觉世界才广阔。 13、西方人并不比东方人聪明，但是他们却找对了路。 14、空不是无，空是一种存在，你得用空这种存在填满自己。 15、没有救世的能力不是你的错，但给世界以希望后又打碎它就是一种不可饶恕的罪恶了。 16、越透明的东西越神秘，宇宙本身就是透明的，只要目力能及，你想看多远就看多远，但越看越神秘。 17、大多数人到死都没有向尘世之外瞥一眼。 18、限长的曲线就是宇宙的抽象，一头连着无限的过去，另一头连着无限的未来，中间只有无规律无生命的随机起伏，一个个高低错落的波峰就像一粒粒大小不等的沙子，整条曲线就像是所有沙粒排成行形成的一维沙漠，荒凉寂寥，长得更令人无法忍受。你可以沿着它向前向后走无限远，但永远找不到归宿。 19、如果说，有上帝的话。人类一思考，上帝就发笑，如果人类不思考，上帝连发笑都不屑于。 20、没有什么能永远存在，即使是宇宙也有灭亡的那一天，凭什么人类就觉得自己该永远存在下去。 21、在这寒冷无际的草原间，燃烧是无意义的，一腔热血喷出来，比一堆牛粪凉的更快，还不如后者有实用价值。但燃烧是他们的命运，他们是燃烧的一代。 22、仅靠生存本身是不能保证生存的，发展才是生存的最好保障。 23、他们的宇宙还很年轻，他们的神还只是个孩子。现在评断他们还为时过早，当‘我们’在‘末日’回去的时候，会决定谁该被拯救。 24、在黑暗中沉淀出了重元素，所以光明不是文明的母亲，黑暗才是。 25、上帝是个无耻的老赌徒，他抛弃了我们！ 26、实际上没有毁掉什么……就像一副牌，只是重洗了……可生命就像是一手同花顺，一洗就什么都没了。以后再也不会有这么好的牌了。 27、在宇宙中，你再快都有比你更快的，你再慢也有比你更慢的。 28、既没有入世的能力也没有出世的资本——说的是某一个人，不过却很具有普遍性。 29、在意义之塔上，生存高于一切，面对生存，任何低熵体都只能两害相权取其轻。 30、活着本身就很美妙，如果连这道理都不懂，怎么去探索更深的东西呢？","link":"/2020/03/21/%E4%B8%89%E4%BD%93%E7%BB%8F%E5%85%B8%E8%AF%AD%E5%BD%95/"},{"title":"寒窑赋","text":"《寒窑赋》郭德纲版 楚王虽雄难免乌江自刎， 汉王虽弱却有万里江山。 满腹经纶白发不第， 才疏学浅，少年登科。 有先贫而后富，有先富而后贫。 蛟龙未遇潜身于鱼虾之间， 君子失时拱手于小人之下。 天不得时日月无光， 地不得时草木不长。 水不得时风浪不止， 人不得时利运不通。 感人生在世， 富贵不能移贫贱不能欺， 此乃天理循环， 终而复始者也！ 《破窑赋》作品原文 破窑赋 天有不测风云，人有旦夕祸福。蜈蚣百足，行不及蛇；雄鸡两翼，飞不过鸦。马有千里之程，无骑不能自往；人有冲天之志，非运不能自通。 盖闻：人生在世，富贵不能淫，贫贱不能移。文章盖世，孔子厄于陈邦；武略超群，太公钓于渭水。颜渊命短，殊非凶恶之徒；盗跖年长，岂是善良之辈。尧帝明圣，却生不肖之儿；瞽叟愚顽，反生大孝之子。张良原是布衣，萧何称谓县吏。晏子身无五尺，封作齐国宰相；孔明卧居草庐，能作蜀汉军师。楚霸虽雄，败于乌江自刎；汉王虽弱，竟有万里江山。李广有射虎之威，到老无封；冯唐有乘龙之才，一生不遇。韩信未遇之时，无一日三餐，及至遇行，腰悬三齐玉印，一旦时衰，死于阴人之手。 有先贫而后富，有老壮而少衰。满腹文章，白发竟然不中；才疏学浅，少年及第登科。深院宫娥，运退反为妓妾；风流妓女，时来配作夫人。 青春美女，却招愚蠢之夫；俊秀郎君，反配粗丑之妇。蛟龙未遇，潜水于鱼鳖之间；君子失时，拱手于小人之下。衣服虽破，常存仪礼之容；面带忧愁，每抱怀安之量。时遭不遇，只宜安贫守份；心若不欺，必然扬眉吐气。初贫君子，天然骨骼生成；乍富小人，不脱贫寒肌体。 天不得时，日月无光；地不得时，草木不生；水不得时，风浪不平；人不得时，利运不通。注福注禄，命里已安排定，富贵谁不欲？人若不依根基八字，岂能为卿为相？ 吾昔寓居洛阳，朝求僧餐，暮宿破窑，思衣不可遮其体，思食不可济其饥，上人憎，下人厌，人道我贱，非我不弃也。今居朝堂，官至极品，位置三公，身虽鞠躬于一人之下，而列职于千万人之上，有挞百僚之杖，有斩鄙吝之剑，思衣而有罗锦千箱，思食而有珍馐百味，出则壮士执鞭，入则佳人捧觞，上人宠，下人拥。人道我贵，非我之能也，此乃时也、运也、命也。 嗟呼！人生在世，富贵不可尽用，贫贱不可自欺，听由天地循环，周而复始焉。","link":"/2020/03/29/%E6%97%B6%E8%BF%90%E8%B5%8B/"},{"title":"学历之区别","text":"本科生和研究生到底有何区别？硕士和博士又有什么不同？ 这是很多人都有的困惑，对于这个问题的说法也有很多版本，我们挑选了几个比较经典的版本，以期能和大家一同探讨。 红烧肉版 本科论文 第一章：红烧肉的定义和类型； 第二章：各种红烧肉区别和特点； 第三章：东坡红烧肉的具体特点； 第四章：烹制东坡红烧肉的主要问题和对策。 结论：东坡红烧肉可以更好吃。 硕士论文 第一章：关于猪肉做法的文献综述； 第二章：红烧肉做法的历史演变过程； 第三章：传统红烧肉制作和研究方式介绍和比较； 第四章：马克思剩余价值理论对红烧肉做法的启示； 第五章：剩余价值红烧肉的具体做法； 第六章：剩余价值红烧肉的创新之处和进一步研究建议。 结论：红烧肉很好吃，但是吃的过程中注意区分，剩余价值理论指导下的红烧肉做得会更符合社会主义实践发展。 博士论文 序言：历史中猪肉食谱的文献综述、理论意义和现实价值、不足和问题； 第一篇（第一章到第三章）：猪是怎样养成的； 第二篇（第四章到第五章）：猪的各个部分肉质的区分和作用； 第三篇（第六章到第七章）：马克思理论不同发展阶段对红烧肉发展的影响和启示； 第四篇（第八章到第十章）：红烧肉制作的实证研究（变量选取、理论模型和计量分析）。 结论：红烧肉是不是可以吃取决于很多复杂的因素，总体来看，在满足一定约束条件的情况下红烧肉是不错的营养、美容食品，但操作过程的障碍还需要通过真学、真懂、真用马克思剩余价值理论，有必要的情况下需要进行理论创新和政策支持，使红烧肉更好地实现增加营养、避免增肥和促进社会和谐的作用。 圈圈版 想象这个圆圈代表了人类的所有知识。 你小学毕业时，了解了其中一小部分。 高中毕业时，了解了更多。 拿到本科学位后，你有了自己的专业。 硕士学位让你对自己的专业有了更深的钻研。 继续阅读学术论文，你会逐渐抵达人类知识的边界。 一旦抵达了边界，你便专注于此。 你花几年的时间试图突破边界。 终于有一天，你推动了它。 这个凸出来的部分，让你获得了博士学位。 当然，对你而言，这个世界看上去不一样了。 但别忘了全局是长这样的。 这是一组非常生动的图画，最后那张图更是“意外结局”的典范。它让人感受到自身的渺小，对于走在硕博道路上的人来说是非常必要的提醒：不要因为推动了一点边界而洋洋自得，也不要一味沉浸在自己的领域中，忘记了这个世界的辽阔和丰富。 兔子版 著名数学家华罗庚先生比喻导师和研究生的关系是：导师负责给研究生指出兔子在哪里，并指导学生学会打兔子的本领。反之，研究生则是从导师那里了解到兔子的位置、大小、肥瘦，并采用从导师那里学到的打兔子本领擒获一只兔子（就是做完论文）。 有人由此衍生出本科生、硕士生、博士生、博士后之区别的“兔子理论”： 本科生：学习捡“死”兔子。本科及以前所学知识都是别人已经发现并经过了反复验证的知识，是固定、稳定的，属于“死兔子”。此阶段的学习训练只是学会找到一条比较便捷的路径把已经死在那里的“兔子”拿回来。 硕士生：学习打一只在视野中奔跑的活兔子。这只兔子在哪里？需要导师指给你，或者需要导师和学生一起来确定其位置。导师在“指兔子”的同时还应该告诉学生瞄准并射死兔子的本领。硕士生需要遵从自导师处学来的方法和技术，去把这只尚在活动中的兔子打死，然后再通过以往已经具备的方法把兔子擒在手中。 博士生：学习打一只看不到的活兔子。此时的兔子也是活的，但可能不在你的视野里跑着，而是在树林里跑——导师可以确认一定有这只兔子存在，可是，需要你先从树林里把这只兔子撵出来，判断是否值得去猎取，再用更高级的猎取技术去射击并沿用原有方法将兔子取在手中。 博士后阶段：此时，导师叫合作导师，他就要和博士后一起来确定究竟到哪里去寻找兔子，此时面对的可能是不一样的森林，需要一起商量后确定是否需要在这里伫足，并重复以上过程。 专业分析版 清华大学当代国际关系研究院院长阎学通教授较为全面的从学习、分析、研究方法等几个方面阐述了本、硕、博学习的区别，我们节选了部分内容： 1.本科学习与研究生学习的区别 本科是素质教育，是从未成年到成人的教育，是让他们完成文明教育的过程。素质教育不在乎学什么专业。例如，家长们对子女找配偶的要求是要找个大学生，而不是要求找学某种专业的。家长们未必能解释为什么，但他们知道受过高等教育的人基本上不动手打配偶。本科教育是培养做人的品格和修养的过程。 研究生教育不是素质教育，是专业教育。这就是研究生教育和本科生教育的最主要区别。这个区别决定了你们应注重学习什么的问题。你们的学习带有研究性质，这对你们毕业后的工作选择与本科生有了不同。本科生毕业后终生从事其所学专业的人数比例原则上不会超过10%。这里我说的不是上世纪50年代的本科毕业生，而是指有了博士生教育以后的本科毕业生。 硕士毕业生终生从事其硕士专业的比例会高一点，约15%。而博士毕业生以博士专业为终身职业的人数应不低于三分之二，低于这个标准则说明博士教育本身不成功。也可以说明研究生教育特别是博士生教育的性质是专业教育。 2.硕士生学习与博士生学习的区别 硕士研究生与博士生的区别是专业水平差别，不是素质差别。两类毕业生在为人的素质上没有差别，其区别是研究技能。研士生教育培养的是工作技能，而博士生教育培养的是学术技能。硕士生毕业后的工作主要是从事事务性的工作，做学术研究的很少。 因此硕士生要注重学习普遍性的研究技能。完成上级交待下来的任何一项事务性工作，都需要进行调查了解基本情况，判断问题的性质，设计解决问题的方案，找到实施的方案和路径。 这些解决问题的程序和学术研究的方法很相似，例如，文献回顾、找到有意义的问题、提出假设、进行实证、做出结论。无论是研究具体的事务性问题还是研究学术性问题，都需要广义上的研究能力，懂得基本的研究程序和常用的研究方法。 由于硕士毕业生和博士毕业生所从事的工作性质不同，前者是事务性的，后者是学术性的，因此你们对于学术的态度不能一样。博士生要有较强的批判精神，即发现错误的能力，因为发现现有知识的缺陷，才能发现值得研究的问题。 硕士生如果有了这种批判精神，那你最好选择毕业后读博。否则，你到了工作单位，总是发现领导的决策有缺陷，你会不甘心情愿地执行领导决定，你工作就做不好。因此硕士的学习主要是学研究技能，学会如何将研究技能应用于自己的工作，培养成清华人的“能干、出活”精神。我以为能达做到这一点，硕士教育就达到了目标。 博士教育重要的一点是寻求真理、发现规律、探索人类尚不知道的知识。要发现新知识不仅需要研究能力，还需要学术激情和学术奉献精神。很多学术研究所发现的知识都没有实际用处，不能转化成为物质财富。 从经济学的理性角度讲，从事科学研究的人都属于非理性的，因为从事这种研究的人得不到实质性的经济收益。然而，人类的科学进步就是建立在发现了很多人们认为没用的知识的基础上的。 然而，发现新知识是有乐趣的事，于是很多博士选择在低工资的大学就业而不选择高工资的企业。家长们常说的，“这孩子读傻了”，就是这个异化过程。社会上常说的“笨得像个博士，傻得像个教授”，就是异化的结果。当你领到博士学位证书时还没被异化，你可能是个含金量不高的博士。 本文摘自来自公众号：学术志","link":"/2020/03/21/%E6%9C%AC%E7%A1%95%E5%8D%9A%E4%B9%8B%E5%8C%BA%E5%88%AB/"},{"title":"老虎，海豚，企鹅，蜜蜂，八爪鱼","text":"认识你自己 这是一套性格测试题。 先试试回答以下的问题： 如果答案是非常同意，请给自己打5分； 如果是比较同意，则打4分； 如果是差不多，打3分； 如果只是有一点同意，请打2分； 如果答案是不同意，就打1分。 提醒你注意一点——回答问题时不是依据别人眼中的你来判断，而是你认为你本质上是不是这样的，看看问题吧： 1.你做事是一个值得信赖的人吗？ 非常同意 比较同意 差不多 一点同意 不同意 2.你个性温和吗？ 非常同意 比较同意 差不多 一点同意 不同意 3.你有活力吗？ 非常同意 比较同意 差不多 一点同意 不同意 4.你善解人意吗？ 非常同意 比较同意 差不多 一点同意 不同意 5.你独立吗？ 非常同意 比较同意 差不多 一点同意 不同意 6.你受人爱戴吗？ 非常同意 比较同意 差不多 一点同意 不同意 7.做事认真且正直吗？ 非常同意 比较同意 差不多 一点同意 不同意 8.你富有同情心吗？ 非常同意 比较同意 差不多 一点同意 不同意 9.你有说服力吗？ 非常同意 比较同意 差不多 一点同意 不同意 10.你大胆吗？ 非常同意 比较同意 差不多 一点同意 不同意 11.你精确吗？ 非常同意 比较同意 差不多 一点同意 不同意 12.你适应能力强吗？ 非常同意 比较同意 差不多 一点同意 不同意 13.你组织能力好吗？ 非常同意 比较同意 差不多 一点同意 不同意 14.你是否积极主动？ 非常同意 比较同意 差不多 一点同意 不同意 15.你害羞吗？ 非常同意 比较同意 差不多 一点同意 不同意 16.你强势吗？ 非常同意 比较同意 差不多 一点同意 不同意 17.你镇定吗？ 非常同意 比较同意 差不多 一点同意 不同意 18.你勇于学习吗？ 非常同意 比较同意 差不多 一点同意 不同意 19.你反应快吗？ 非常同意 比较同意 差不多 一点同意 不同意 20.你外向吗？ 非常同意 比较同意 差不多 一点同意 不同意 21.你注意细节吗？ 非常同意 比较同意 差不多 一点同意 不同意 22.你爱说话吗？ 非常同意 比较同意 差不多 一点同意 不同意 23.你的协调能力好吗？ 非常同意 比较同意 差不多 一点同意 不同意 24.你勤劳吗？ 非常同意 比较同意 差不多 一点同意 不同意 25.你慷慨吗？ 非常同意 比较同意 差不多 一点同意 不同意 26.你小心翼翼吗？ 非常同意 比较同意 差不多 一点同意 不同意 27.你令人愉快吗？ 非常同意 比较同意 差不多 一点同意 不同意 28.你传统吗？ 非常同意 比较同意 差不多 一点同意 不同意 29你亲切吗？ 非常同意 比较同意 差不多 一点同意 不同意 30.你工作足够有效率吗？ 非常同意 比较同意 差不多 一点同意 不同意 好啦，现在把第5、10、14、18、24、30题的分加起来就是你的“老虎”分数； 把第3、6、13、20、22、29题的分加起来就是你的“海豚”分数； 把第2、8、15、17、25、28题的分加起来就是你的“企鹅”分数； 把第1、7、11、16、21、26题的分加起来就是你的“蜜蜂”分数； 把第4、9、12、19、23、27题的分加起来就是你的“八爪鱼”分数。 假若你有某一项分远远高于其它四项，你就是典型的这种属性，假若你有某两项分大大超过其它三项，你是这两种动物的综合；假若你各项分数都比较接近，恭喜你，你是一个面面俱到近似完美性格的人；假若你有某一项分数特别偏低的话，想提高自己就需要在那一种动物属性的加强上下工夫了。我们就来逐一分析一下各种迥然不同的“动物”吧！ ■老虎型 个性特点：有自信，够权威，决断力高，竞争性强，胸怀大志，喜欢评估。 企图心强烈，喜欢冒险，个性积极，竞争力强，有对抗性。 优点：善于控制局面并能果断地作出决定的能力；用这一类型工作方式的人成就非凡。 缺点：当感到压力时，这类人就会太重视迅速的完成工作，就容易忽视细节，他们可能不顾自己和别人的情感。由于他们要求过高，加之好胜的天性，有时会成为工作狂。 老虎型工作风格的主要行为： 交谈时进行直接的目光接触； 有目的性且能迅速行动； 说话快速且具有说服力； 运用直截了当的实际性语言； 办公室挂有日历、计划要点。 老虎泰格，具备高支配型特质，竞争力强、好胜心盛、积极自信，是个有决断力的组织者。他胸怀大志、勇于冒险、分析敏锐，主动积极且具极为强烈的企图心，只要认定目标就勇往直前，不畏反抗与攻讦，誓要取得目标的家伙。 老虎型领导人都倾向以权威作风来进行决策，当其部属者除要高度服从外，也要有冒险犯难的勇气，为其杀敌闯关。 老虎型族人最适合开创性与改革性的工作，在开拓市场的时代或需要执行改革的环境中，最容易有出色的表现。 宏碁集团的施振荣和前美国GE总裁韦尔奇 (Jack Welch)等，都是老虎型领导人。 ■海豚型 个性特点：很热心，够乐观，口才流畅，好交朋友，风度翩翩，诚恳热心。热情洋溢、好交朋友、口才流畅、个性乐观、表现欲强。 优点：此类型的人生性活泼。能够使人兴奋，他们高效地工作，善于建立同盟或搞好关系来实现目标。他们很适合需要当众表现、引人注目、态度公开的工作。 缺点：因其跳跃性的思考模式，常无法顾及细节以及对事情的完成执着度 海豚型工作风格的主要行为 运用快速的手势； 面部表情特别丰富； 运用有说服力的语言； 工作空间里充满了各种能鼓舞人心的东西。 海豚百利具有高度的表达能力，他的社交能力极强，有流畅无碍的口才和热情幽默的风度，在团体或社群中容易广结善缘、建立知名度。海豚型领导人天生具备乐观与和善的性格，有真诚的同情心和感染他人的能力，在以团队合作为主的工作环境中，会有最好的表现。 海豚型领导人在任何团体内，都是人缘最好的人和最受欢迎的人，是最能吹起领导号角的人物。 当海豚型领导人的部属者，除要能乐于在团队中工作外，还要对其领导谦逊得体，不露锋、不出头，把一切成功光华都让与领导。 海豚型领导人，不宜有个老虎型领导人当二把手或部属。 反之，若老虎型领导人有个海豚型的人甘愿当其二把手，则会是最佳搭配。海豚型的人天生具有鼓吹理想的特质，在推动新思维、执行某种新使命或推广某项宣传等任务的工作中，都会有极出色的表现。 他们在开发市场或创建产业的工作环境中，最能发挥其所长。 有台湾企管大师之称的石滋宜博士，就是属于海豚型的人。 ■企鹅型 个性特点：很稳定，够敦厚，温和规律，不好冲突。行事稳健、强调平实，有过人的耐力，温和善良。 优点：他们对其他人的感情很敏感，这使他们在集体环境中左右逢源。 缺点：很难坚持自己的观点和迅速做出决定。一般说来，他们不喜欢面对与同事意见不和的局面，他们不愿处理争执。 企鹅型工作风格的主要行为 面部表情和蔼可亲； 说话慢条斯理，声音轻柔； 用赞同型、鼓励性的语言； 办公室里摆有家人的照片。 企鹅加利具有高度的耐心。他敦厚随和，行事冷静自持；生活讲求律规但也随缘从容，面对困境，都能泰然自若。 企鹅型领导人，适宜当安定内部的管理工作，在需要专业精密技巧的领域，或在气氛和谐且不具赶迫时间表等的职场环境中，他们最能发挥所长。当企业的产品稳踞市场时，企鹅型的企业领导人是极佳的总舵手。但当企业还在开拓市场的时候，老虎型或海豚型的人似乎较占优势。 或许，勇于开疆辟土的老虎型的人当一哥， 配以与人为善的企鹅型人当二把手，也是好的搭配。 企鹅型领导人强调无为而治，能与周围的人和睦相处而不树敌，是极佳的人事领导者，适宜在企业改革后，为公司和员工重建互信的工作。又由于他们具有高度的耐心性，有能力为企业赚取长远的利益，或为公司打好永续经营的基础。 ■蜜蜂型 个性特点：很传统，注重细节，条理分明，责任感强，重视纪律。保守、分析力强，精准度高，喜欢把细节条例化，个性拘谨含蓄。 优点：天生就有爱找出事情真相的习性，因为他们有耐心仔细考察所有的细节并想出合乎逻辑的解决办法。 缺点：把事实和精确度置于感情之前，这会被认为是感情冷漠。在压力下，有时为了避免做出结论，他们会分析过度。 蜜蜂型工作风格的主要行为 很少有面部表情； 动作缓慢； 使用精确的语言、注意特殊细节； 办公室里挂有图表、统计数字等。 蜜蜂斯诺具有高度精确的能力，其行事风格，重规则轻情感，事事以规则为准绳，并以之为主导思想。 他性格内敛、善于以数字或规条为表达工具而不大擅长以语言来沟通情感或向同事和部属等作指示。 他行事讲究条理分明、守纪律重承诺，是个完美主义者 架构稳定和制度健全的组织最好聘用蜜蜂型的人来当各级领导人，因为蜜蜂型领导人喜欢在安全架构的环境中工作，且其表现也会最好。其行事讲究制度化，事事求依据和规律的习性，极为适合事务机构的行事方式。然而，当企业需要进行目标重整、结构重组、流程变革时，蜜蜂型领导人就会产生迷失，不知如何处事，也不知如何自处。对改革行动，上者会先保持观望的态度，再慢慢适应新的局面；中者也会先保持观望的态度，然后呈辞求去；下者则会结集反对力量，公然表示反对或隐晦地从事反对等的行为。 又由于蜜蜂型人的行事决策风格，是以数据和规则为其主导思想，其直觉能力和应变能力都偏低，随而创造和创新能力也相对地弱，因而不宜担任需要创建或创新能力的任务。组织完善和发展安定的企业，宜用蜜蜂型企管人当家。 他们尊重传统、重视架构、事事求据喜爱工作安定的性格，是企业安定力量的来源。然而，由于他们行事讲究制度化，事事求依据和规律，故会将细节条例化，事事检查以求正确无误，甚至为了办事精确，不惜对人吹毛求疵或挑剔别人的错误，以显现自己一切照章办事的态度和求取完美的精神，不易维持团队内的团结精神和凝聚力。 ■八爪鱼型 工作风格的优点：善于在工作中调整自己的角色去适应环境，具有很好的沟通能力。 缺点：从别人眼中看八爪鱼族群，会觉得他们较无个性及原则。 主要行为： 综合老虎、海豚、企鹅、蜜蜂的特质，看似没有凸出个性，但擅长整合内外资； 没有强烈的个人意识形态，是他们处事的价值观。 八爪鱼科尔具有高度的应变能力。他性格善变，处事极具弹性，能为了适应环境的要求而调整其决定甚至信念。 八爪鱼型的领导人，是支配型、表达型、耐心型、精确型四种特质的综合体，没有突出的个性，擅长整合内外信息，兼容并蓄，不会与人为敌，以中庸之道处世。他们处事圆融，弹性极强，处事处处留有余地，行事绝对不会走偏锋极端，是一个办事让你放心的人物。然而，由于他们以善变为其专长，故做人不会有什么立场或原则，也不会对任何人有效忠的意向，是个冯道式的人物。部属会难以忍受其善变和不讲原则的行为；当他们上司者，则会日夜担心不知何时会遭其「出卖」。 八爪鱼型的领导人既没有凸出的个性，对事也没有什么强烈的个人意识型态，事事求中立并倾向站在没有立场的位置，故在冲突的环境中，是个能游走折中的高手。由于他们能密切地融合于各种环境中，他们可以为企业进行对内对外的各种交涉，只要任务确实和目标清楚，他们都能恰如其分地完成其任务。 这是一个在美国高层企业管理人员中普遍认可并用之于迅速区分不同人际风格的一套测试题，管理人员通过它可以来了解下属的工作性格以扬长避短，普通职员通过它可以知己知彼完善自身。","link":"/2020/03/26/%E8%80%81%E8%99%8E%EF%BC%8C%E6%B5%B7%E8%B1%9A%EF%BC%8C%E4%BC%81%E9%B9%85%EF%BC%8C%E8%9C%9C%E8%9C%82%EF%BC%8C%E5%85%AB%E7%88%AA%E9%B1%BC/"},{"title":"java基础学习笔记一","text":"java笔记 [TOC] java简介 Java是由Sun Microsystems公司于1995年5月推出的Java面向对象程序设计语言和Java平台的总称。由James Gosling和同事们共同研发，并在1995年正式推出。 java基础语法 对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 类：类是一个模板，它描述一类对象的行为和状态。 方法：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。 实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。 *大小写敏感：Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。 *类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 。 *方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。 *源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 .java。（如果文件名和类名不相同则会导致编译错误）。 *主方法入口：所有的 Java 程序由 public static void main(String []args) 方法开始执行。 *Java修饰符 像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符： 访问控制修饰符 : default, public , protected, private 非访问控制修饰符 : final, abstract, static, synchronized *Java 标识符 Java 所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。 *接口 在 Java 中，接口可理解为对象间相互通信的协议。接口在继承中扮演着很重要的角色。接口只定义派生要用到的方法，但是方法的具体实现完全取决于派生类。 java对象和类 多态 继承 封装 抽象 类：类是一个模板，它描述一类对象的行为和状态。 对象：对象是类的一个实例 实例 方法 重载 *变量 局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。 成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。 类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。 *创建对象 声明：声明一个对象，包括对象名称和对象类型。 实例化：使用关键字new来创建一个对象。 初始化：使用new创建对象时，会调用构造方法初始化对象。 12345678910public class Puppy{ public Puppy(String name){ //这个构造器仅有一个参数：name System.out.println(\"小狗的名字是 : \" + name ); } public static void main(String[] args){ // 下面的语句将创建一个Puppy对象 Puppy myPuppy = new Puppy( \"tommy\" ); }} *访问实例变量和方法 123456789101112131415161718192021222324252627public class Puppy{ int puppyAge; public Puppy(String name){ // 这个构造器仅有一个参数：name System.out.println(\"小狗的名字是 : \" + name ); } public void setAge( int age ){ puppyAge = age; } public int getAge( ){ System.out.println(\"小狗的年龄为 : \" + puppyAge ); return puppyAge; } public static void main(String[] args){ /* 创建对象 */ Puppy myPuppy = new Puppy( \"tommy\" ); /* 通过方法来设定age */ myPuppy.setAge( 2 ); /* 调用另一个方法获取age */ myPuppy.getAge( ); /*你也可以像下面这样访问成员变量 */ System.out.println(\"变量值 : \" + myPuppy.puppyAge ); }} *源文件声明规则 一个源文件中只能有一个public类 一个源文件可以有多个非pubic类 源文件的名称应该和public类的类名保持一致 java包主要用来对类和接口进行分类 import语句import java.io.*; java基础数据类型*java的两大数据类型 *内置数据类型 ​ 1234567891011121314151617 六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。byte 1,short 2, int 4(一般整型变量默认为 int 类型), long 8 ,float 4, double 8, boolean true&amp;flase, char 2 ,默认值`u0000 ` *引用数据类型 - 在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。 - 对象、数组都是引用数据类型。 - 所有引用类型的默认值都是null。 - 一个引用变量可以用来引用任何与之兼容的类型。 123456 ***java常量**用final关键字来修饰常量，声明方式和变量类似； final double PI = 3.1415927; 12***自动类型转换** 整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。 转换从低级到高级。低 ————————————&gt; 高 byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double 、 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例(int)23.7==23; 12***强制类型转换** 格式：(type)value 隐含强制类型转换：整数的默认类型是int，浮点数不存在这种情况，因为在定义float类型时必须在数字后面加上F或者f. 123456## java变量类型Java语言支持的变量类型有：- 类变量(静态变量)：独立于方法之外的变量，用 static 修饰。 类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。 静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。 静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。 静态变量在第一次被访问时创建，在程序结束时销毁。 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。 默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。 静态变量可以通过：ClassName.VariableName的方式访问。 类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。 1234 - 实例变量：独立于方法之外的变量，不过没有 static 修饰。 实例变量声明在一个类中，但在方法、构造方法和语句块之外； 当一个对象被实例化之后，每个实例变量的值就跟着确定； 实例变量在对象创建的时候创建，在对象被销毁的时候销毁； 实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息； 实例变量可以声明在使用前或者使用后； 访问修饰符可以修饰实例变量； 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见； 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定； 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。 1234567891011121314151617 - 局部变量：类的方法中的变量。访问修饰符不能用于局部变量；局部变量是在栈上分配的。局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。 ```java public class Variable{ static int allClicks=0; // 类变量 String str=&quot;hello world&quot;; // 实例变量 public void method(){ int i =0; // 局部变量 } } java修饰符:basketball_man:访问修饰符 public&gt;protected&gt;default&gt;private 修饰符 当前类 同一包内 子孙类(同一包) 子孙类(不同包) 其他包 public Y Y Y Y Y protected Y Y Y Y/N（说明） N default Y Y Y N N private Y N N N N default:默认,在一个包内可见；使用对象：类，接口，变量，方法。 private:在同一类内可见，使用对象：变量，方法。注意：不能修饰类（外部类) public:对所有的类可见。使用对象：类，接口，变量，方法 protected:对同一包内的类和所有子类可见。使用对象变量和方法。注意：不能修饰类（外部类）。 接口里的变量都隐式声明为 public static final,而接口里的方法默认情况下访问权限为 public。 :basketball_man:非访问修饰符 static修饰符，用来修饰类方法和类变量。静态变量也被称为类变量。静态方法不能使用类的非静态变量。 final修饰符，用来修饰类，方法和变量，final修饰的类不能够被继承。修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。 abstract修饰符，用来创建抽象类和抽象方法。抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。 synchronized和volatile修饰符，主要用于线程的编程。volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。 transient 修饰符。序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。 123实例public transient int limit = 55; // 不会持久化 public int b; // 持久化 java运算符 算术运算符 +-*/%++– 关系运算符 == ！= &lt; &gt; &gt;= &lt;= 位运算符 &amp; | ^ ~ &lt;&lt; &gt;&gt; &gt;&gt;&gt;按位右移补零操作符。eg: A&gt;&gt;&gt;2得到15即0000 1111 逻辑运算符 &amp;&amp; || ! 赋值运算符 = += -= *= /= (%)= &lt;&lt;= &gt;&gt;= &amp;= ^= |= 条件运算符 三元运算符 ？ ： instanceof运算符：该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。 java运算符优先级 类别 操作符 关联性 后缀 () [] . (点操作符) 左到右 一元 + + - ！〜 从右到左 乘性 * /％ 左到右 加性 + - 左到右 移位 &gt;&gt; &gt;&gt;&gt; &lt;&lt; 左到右 关系 &gt;&gt; = &lt;&lt; = 左到右 相等 == != 左到右 按位与 ＆ 左到右 按位异或 ^ 左到右 按位或 | 左到右 逻辑与 &amp;&amp; 左到右 逻辑或 | | 左到右 条件 ？： 从右到左 赋值 = + = - = * = / =％= &gt;&gt; = &lt;&lt; =＆= ^ = | = 从右到左 逗号 ， 左到右 java循环结构-for,while及do…while123for(初始化; 布尔表达式; 更新) { //代码语句} 12 //代码语句}while(布尔表达式); 123while( 布尔表达式 ) { //循环内容} :basketball_man:java增强for循环 java5引入了一种主要用于数组的增强型for循环。 1234567891011121314for(声明语句：表达式){ //代码句子}声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。表达式：表达式是要访问的数组名，或者是返回值为数组的方法。例子： int [] numbers = {10, 20, 30, 40, 50}; for(int x : numbers ){ System.out.print( x ); System.out.print(\",\"); } break关键字 break 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。break 跳出最里层的循环，并且继续执行该循环下面的语句。 continue 关键字 continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。在 for 循环中，continue 语句使程序立即跳转到更新语句。在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。 java条件语句-if…else1234567if…else 的用法如下：if(布尔表达式){ //如果布尔表达式的值为true}else{ //如果布尔表达式的值为false} 123456789if(布尔表达式 1){ //如果布尔表达式 1的值为true执行代码}else if(布尔表达式 2){ //如果布尔表达式 2的值为true执行代码}else if(布尔表达式 3){ //如果布尔表达式 3的值为true执行代码}else { //如果以上布尔表达式都不为true执行代码} 123456if(布尔表达式 1){ ////如果布尔表达式 1的值为true执行代码 if(布尔表达式 2){ ////如果布尔表达式 2的值为true执行代码 }} java switch case 语句switch case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。 123456789101112switch(expression){ case value : //语句 break; //可选 case value : //语句 break; //可选 //你可以有任意数量的case语句 default : //可选 //语句}switch 语句可以包含一个 default 分支，该分支一般是 switch 语句的最后一个分支（可以在任何位置，但建议在最后一个）。default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句。 java Number &amp;Math类 所有的包装类（Integer、Long、Byte、Double、Float、Short）都是抽象类 Number 的子类。这种由编译器特别支持的包装称为装箱，所以当内置数据类型被当作对象使用的时候，编译器会把内置类型装箱为包装类。 Java Math 类 Java 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。 Number &amp; Math 类方法下面的表中列出的是 Number &amp; Math 类常用的一些方法： 序号 方法与描述 1 xxxValue() 将 Number 对象转换为xxx数据类型的值并返回。 2 compareTo() 将number对象与参数比较。 3 equals() 判断number对象是否与参数相等。 4 valueOf() 返回一个 Number 对象指定的内置数据类型 5 toString() 以字符串形式返回值。 6 parseInt() 将字符串解析为int类型。 7 abs() 返回参数的绝对值。 8 ceil() 返回大于等于( &gt;= )给定参数的的最小整数，类型为双精度浮点型。 9 floor() 返回小于等于（&lt;=）给定参数的最大整数 。 10 rint() 返回与参数最接近的整数。返回类型为double。 11 round() 它表示四舍五入，算法为 Math.floor(x+0.5)，即将原来的数字加上 0.5 后再向下取整，所以，Math.round(11.5) 的结果为12，Math.round(-11.5) 的结果为-11。 12 min() 返回两个参数中的最小值。 13 max() 返回两个参数中的最大值。 14 exp() 返回自然数底数e的参数次方。 15 log() 返回参数的自然数底数的对数值。 16 pow() 返回第一个参数的第二个参数次方。 17 sqrt() 求参数的算术平方根。 18 sin() 求指定double类型参数的正弦值。 19 cos() 求指定double类型参数的余弦值。 20 tan() 求指定double类型参数的正切值。 21 asin() 求指定double类型参数的反正弦值。 22 acos() 求指定double类型参数的反余弦值。 23 atan() 求指定double类型参数的反正切值。 24 atan2() 将笛卡尔坐标转换为极坐标，并返回极坐标的角度值。 25 toDegrees() 将参数转化为角度。 26 toRadians() 将角度转换为弧度。 27 random() 返回一个随机数。 java Character类Character 类用于对单个字符进行操作。Character 类在对象中包装一个基本类型 char 的值。 在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情况。为了解决这个问题，Java语言为内置数据类型char提供了包装类Character类。 在某些情况下，Java编译器会自动创建一个Character对象。 例如，将一个char类型的参数传递给需要一个Character类型参数的方法时，那么编译器会自动地将char类型参数转换为Character对象。 这种特征称为装箱，反过来称为拆箱。 1234567实例// 原始字符 'a' 装箱到 Character 对象 ch 中Character ch = 'a'; // 原始字符 'x' 用 test 方法装箱// 返回拆箱的值到 'c'char c = test('x'); Character 方法 下面是Character类的方法： 序号 方法与描述 1 isLetter() 是否是一个字母 2 isDigit() 是否是一个数字字符 3 isWhitespace() 是否是一个空白字符 4 isUpperCase() 是否是大写字母 5 isLowerCase() 是否是小写字母 6 toUpperCase() 指定字母的大写形式 7 toLowerCase() 指定字母的小写形式 8 toString() 返回字符的字符串形式，字符串的长度仅为1 java String 类字符串广泛应用在java编程中，在java中字符串属于对象，java提供了String类来创建和操作字符串。String 类有 11 种构造方法，这些方法提供不同的参数来初始化字符串，比如提供一个字符数组参数。 注意:String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了（详看笔记部分解析）。如果需要对字符串做很多修改，那么应该选择使用 StringBuffer &amp; StringBuilder 类。 :basketball_man:字符串长度：String 类的一个访问器方法是length（）方法，它返回字符串对象包含的字符数。 :basketball_man:连接字符串： string1.concat(string2); “hello”+”world”; :basketball_man:创建格式化字符串： 12345678910111213141516我们知道输出格式化数字可以使用 printf() 和 format() 方法。String 类使用静态方法 format() 返回一个String 对象而不是 PrintStream 对象。String 类的静态方法 format() 能用来创建可复用的格式化字符串，而不仅仅是用于一次打印输出。 System.out.printf(\"浮点型变量的值为 \" + \"%f, 整型变量的值为 \" + \" %d, 字符串变量的值为 \" + \"is %s\", floatVar, intVar, stringVar);或 String fs; fs = String.format(\"浮点型变量的值为 \" + \"%f, 整型变量的值为 \" + \" %d, 字符串变量的值为 \" + \" %s\", floatVar, intVar, stringVar); :basketball_man:String 方法 下面是 String 类支持的方法，更多详细，参看 Java String API 文档: SN(序号) 方法描述 1 char charAt(int index) 返回指定索引处的 char 值。 2 int compareTo(Object o) 把这个字符串和另一个对象比较。 3 int compareTo(String anotherString) 按字典顺序比较两个字符串。 4 int compareToIgnoreCase(String str) 按字典顺序比较两个字符串，不考虑大小写。 5 String concat(String str) 将指定字符串连接到此字符串的结尾。 6 boolean contentEquals(StringBuffer sb) 当且仅当字符串与指定的StringBuffer有相同顺序的字符时候返回真。 7 static String copyValueOf(char[] data) 返回指定数组中表示该字符序列的 String。 8 static String copyValueOf(char[] data, int offset, int count) 返回指定数组中表示该字符序列的 String。 9 boolean endsWith(String suffix) 测试此字符串是否以指定的后缀结束。 10 boolean equals(Object anObject) 将此字符串与指定的对象比较。 11 boolean equalsIgnoreCase(String anotherString) 将此 String 与另一个 String 比较，不考虑大小写。 12 byte[] getBytes() 使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 13 byte[] getBytes(String charsetName) 使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 14 void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 将字符从此字符串复制到目标字符数组。 15 int hashCode() 返回此字符串的哈希码。 16 int indexOf(int ch) 返回指定字符在此字符串中第一次出现处的索引。 17 int indexOf(int ch, int fromIndex) 返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。 18 int indexOf(String str) 返回指定子字符串在此字符串中第一次出现处的索引。 19 int indexOf(String str, int fromIndex) 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。 20 String intern() 返回字符串对象的规范化表示形式。 21 int lastIndexOf(int ch) 返回指定字符在此字符串中最后一次出现处的索引。 22 int lastIndexOf(int ch, int fromIndex) 返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。 23 int lastIndexOf(String str) 返回指定子字符串在此字符串中最右边出现处的索引。 24 int lastIndexOf(String str, int fromIndex) 返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。 25 int length() 返回此字符串的长度。 26 boolean matches(String regex) 告知此字符串是否匹配给定的正则表达式。 27 boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len) 测试两个字符串区域是否相等。 28 boolean regionMatches(int toffset, String other, int ooffset, int len) 测试两个字符串区域是否相等。 29 String replace(char oldChar, char newChar) 返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 30 String replaceAll(String regex, String replacement) 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。 31 String replaceFirst(String regex, String replacement) 使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。 32 String[] split(String regex) 根据给定正则表达式的匹配拆分此字符串。 33 String[] split(String regex, int limit) 根据匹配给定的正则表达式来拆分此字符串。 34 boolean startsWith(String prefix) 测试此字符串是否以指定的前缀开始。 35 boolean startsWith(String prefix, int toffset) 测试此字符串从指定索引开始的子字符串是否以指定前缀开始。 36 CharSequence subSequence(int beginIndex, int endIndex) 返回一个新的字符序列，它是此序列的一个子序列。 37 String substring(int beginIndex) 返回一个新的字符串，它是此字符串的一个子字符串。 38 String substring(int beginIndex, int endIndex) 返回一个新字符串，它是此字符串的一个子字符串。 39 char[] toCharArray() 将此字符串转换为一个新的字符数组。 40 String toLowerCase() 使用默认语言环境的规则将此 String 中的所有字符都转换为小写。 41 String toLowerCase(Locale locale) 使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。 42 String toString() 返回此对象本身（它已经是一个字符串！）。 43 String toUpperCase() 使用默认语言环境的规则将此 String 中的所有字符都转换为大写。 44 String toUpperCase(Locale locale) 使用给定 Locale 的规则将此 String 中的所有字符都转换为大写。 45 String trim() 返回字符串的副本，忽略前导空白和尾部空白。 46 static String valueOf(primitive data type x) 返回给定data type类型x参数的字符串表示形式。 java StringBuffer和StringBuilder类当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。 和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。 StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。 由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。 StringBuffer 方法以下是 StringBuffer 类支持的主要方法： 序号 方法描述 1 public StringBuffer append(String s) 将指定的字符串追加到此字符序列。 2 public StringBuffer reverse() 将此字符序列用其反转形式取代。 3 public delete(int start, int end) 移除此序列的子字符串中的字符。 4 public insert(int offset, int i) 将 int 参数的字符串表示形式插入此序列中。 5 replace(int start, int end, String str) 使用给定 String 中的字符替换此序列的子字符串中的字符。 下面的列表里的方法和 String 类的方法类似： 序号 方法描述 1 int capacity() 返回当前容量。 2 char charAt(int index) 返回此序列中指定索引处的 char 值。 3 void ensureCapacity(int minimumCapacity) 确保容量至少等于指定的最小值。 4 void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 将字符从此序列复制到目标字符数组 dst。 5 int indexOf(String str) 返回第一次出现的指定子字符串在该字符串中的索引。 6 int indexOf(String str, int fromIndex) 从指定的索引处开始，返回第一次出现的指定子字符串在该字符串中的索引。 7 int lastIndexOf(String str) 返回最右边出现的指定子字符串在此字符串中的索引。 8 int lastIndexOf(String str, int fromIndex) 返回 String 对象中子字符串最后出现的位置。 9 int length() 返回长度（字符数）。 10 void setCharAt(int index, char ch) 将给定索引处的字符设置为 ch。 11 void setLength(int newLength) 设置字符序列的长度。 12 CharSequence subSequence(int start, int end) 返回一个新的字符序列，该字符序列是此序列的子序列。 13 String substring(int start) 返回一个新的 String，它包含此字符序列当前所包含的字符子序列。 14 String substring(int start, int end) 返回一个新的 String，它包含此序列当前所包含的字符子序列。 15 String toString() 返回此序列中数据的字符串表示形式。 java数组Java 语言中提供的数组是用来存储固定大小的同类型元素 :basketball_man:声明数组变量 首先必须声明数组变量，才能在程序中使用数组。下面是声明数组变量的语法： 123dataType[] arrayRefVar; // 首选的方法 或 dataType arrayRefVar[]; // 效果相同，但不是首选方法 :basketball_man:创建数组 Java语言使用new操作符来创建数组，语法如下： 1arrayRefVar = new dataType[arraySize]; 上面的语法语句做了两件事： 使用 dataType[arraySize] 创建了一个数组。 2.把新创建的数组的引用赋值给变量 arrayRefVar。 数组变量的声明，和创建数组可以用一条语句完成，如下所示： 1dataType[] arrayRefVar = new dataType[arraySize]; 另外，你还可以使用如下的方式创建数组。 1dataType[] arrayRefVar = {value0, value1, ..., valuek}; 数组的元素是通过索引访问的。数组索引从 0 开始，所以索引值从 0 到 arrayRefVar.length-1。 :basketball_man:处理数组 数组的元素类型和数组的大小都是确定的，所以当处理数组元素时候，我们通常使用基本循环或者 For-Each 循环。 1234567891011121314151617181920212223基本循环：public class TestArray { public static void main(String[] args) { double[] myList = {1.9, 2.9, 3.4, 3.5}; // 打印所有数组元素 for (int i = 0; i &lt; myList.length; i++) { System.out.println(myList[i] + \" \"); } // 计算所有元素的总和 double total = 0; for (int i = 0; i &lt; myList.length; i++) { total += myList[i]; } System.out.println(\"Total is \" + total); // 查找最大元素 double max = myList[0]; for (int i = 1; i &lt; myList.length; i++) { if (myList[i] &gt; max) max = myList[i]; } System.out.println(\"Max is \" + max); }} 123456789101112131415for-each循环for(type element: array){ System.out.println(element);}public class TestArray { public static void main(String[] args) { double[] myList = {1.9, 2.9, 3.4, 3.5}; // 打印所有数组元素 for (double element: myList) { System.out.println(element); } }} :biking_man:数组作为函数的参数 12345public static void printArray(int[] array) { for (int i = 0; i &lt; array.length; i++) { System.out.print(array[i] + \" \"); }} :biking_man:数组作为函数的返回值 12345678public static int[] reverse(int[] list) { int[] result = new int[list.length]; for (int i = 0, j = result.length - 1; i &lt; list.length; i++, j--) { result[j] = list[i]; } return result;} :bike:多维数组 String str/[/]/[/] = new type /[typeLength1/]/[typeLenth2/]; 12345678String s[][] = new String[2][];s[0] = new String[2];s[1] = new String[3];s[0][0] = new String(\"Good\");s[0][1] = new String(\"Luck\");s[1][0] = new String(\"to\");s[1][1] = new String(\"you\");s[1][2] = new String(\"!\"); :basketball_man:Arrays 类 java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。 具有以下功能： 给数组赋值：通过 fill 方法。 对数组排序：通过 sort 方法, 按升序。 比较数组：通过 equals 方法比较数组中元素值是否相等。 查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。 具体说明请查看下表： 序号 方法和说明 1 public static int binarySearch(Object[] a, Object key) 用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(插入点) - 1)。 2 public static boolean equals(long[] a, long[] a2) 如果两个指定的 long 型数组彼此相等，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 3 public static void fill(int[] a, int val) 将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 4 public static void sort(Object[] a) 对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 java日期时间java.util 包提供了 Date 类来封装当前的日期和时间。 Date 类提供两个构造函数来实例化 Date 对象。 第一个构造函数使用当前日期和时间来初始化对象。Date( ) 第二个构造函数接收一个参数，该参数是从1970年1月1日起的毫秒数Date(long millisec) Date对象创建以后，可以调用下面的方法。 序号 方法和描述 1 boolean after(Date date) 若当调用此方法的Date对象在指定日期之后返回true,否则返回false。 2 boolean before(Date date) 若当调用此方法的Date对象在指定日期之前返回true,否则返回false。 3 Object clone( ) 返回此对象的副本。 4 int compareTo(Date date) 比较当调用此方法的Date对象和指定日期。两者相等时候返回0。调用对象在指定日期之前则返回负数。调用对象在指定日期之后则返回正数。 5 int compareTo(Object obj) 若obj是Date类型则操作等同于compareTo(Date) 。否则它抛出ClassCastException。 6 boolean equals(Object date) 当调用此方法的Date对象和指定日期相等时候返回true,否则返回false。 7 long getTime( ) 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。 8 int hashCode( ) 返回此对象的哈希码值。 9 void setTime(long time) 用自1970年1月1日00:00:00 GMT以后time毫秒数设置时间和日期。 10 String toString( ) 把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat) :biking_man:获取当前日期时间： 1234567891011import java.util.Date; public class DateDemo { public static void main(String args[]) { // 初始化 Date 对象 Date date = new Date(); // 使用 toString() 函数显示日期时间 System.out.println(date.toString()); }} :basketball_man:日期比较 Java使用以下三种方法来比较两个日期： 使用 getTime() 方法获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值。 使用方法 before()，after() 和 equals()。例如，一个月的12号比18号早，则 new Date(99, 2, 12).before(new Date (99, 2, 18)) 返回true。 使用 compareTo() 方法，它是由 Comparable 接口定义的，Date 类实现了这个接口。 :basketball_man:使用 SimpleDateFormat 格式化日期 SimpleDateFormat 是一个以语言环境敏感的方式来格式化和分析日期的类。SimpleDateFormat 允许你选择任何用户自定义日期时间格式来运行。例如： 123456789101112import java.util.*;import java.text.*; public class DateDemo { public static void main(String args[]) { Date dNow = new Date( ); SimpleDateFormat ft = new SimpleDateFormat (\"yyyy-MM-dd hh:mm:ss\"); System.out.println(\"当前时间为: \" + ft.format(dNow)); }} :basketball_man:解析字符串为时间 SimpleDateFormat 类有一些附加的方法，特别是parse()，它试图按照给定的SimpleDateFormat 对象的格式化存储来解析字符串。例如： 12345678910111213141516171819202122import java.util.*;import java.text.*; public class DateDemo { public static void main(String args[]) { SimpleDateFormat ft = new SimpleDateFormat (\"yyyy-MM-dd\"); String input = args.length == 0 ? \"1818-11-11\" : args[0]; System.out.print(input + \" Parses as \"); Date t; try { t = ft.parse(input); System.out.println(t); } catch (ParseException e) { System.out.println(\"Unparseable using \" + ft); } }} :basketball_man:java休眠（sleep） sleep()使当前线程进入停滞状态（阻塞当前线程），让出CPU的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会。 12345678910111213import java.util.*; public class SleepDemo { public static void main(String args[]) { try { System.out.println(new Date( ) + \"\\n\"); Thread.sleep(1000*3); // 休眠3秒 System.out.println(new Date( ) + \"\\n\"); } catch (Exception e) { System.out.println(\"Got an exception!\"); } }} :basketball_man:Calendar类 我们又如何在日期的这些部分加上或者减去值呢? 答案是使用Calendar 类。 Calendar类的功能要比Date类强大很多，而且在实现方式上也比Date类要复杂一些。 Calendar类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用getInstance方法创建即可。 123//创建一个代表2020年2月12日的Calendar对象Calendar c1 = Calendar.getInstance();c1.set(2020, 2 - 1, 12); :basketball_man:Calendar类对象字段类型** Calendar类中用以下这些常量表示不同的意义，jdk内的很多类其实都是采用的这种思想 常量 描述 Calendar.YEAR 年份 Calendar.MONTH 月份 Calendar.DATE 日期 Calendar.DAY_OF_MONTH 日期，和上面的字段意义完全相同 Calendar.HOUR 12小时制的小时 Calendar.HOUR_OF_DAY 24小时制的小时 Calendar.MINUTE 分钟 Calendar.SECOND 秒 Calendar.DAY_OF_WEEK 星期几 :basketball_man:Calendar类对象信息的设置 Set设置: 123Calendar c1 = Calendar.getInstance();public final void set(int year,int month,int date) c1.set(2020, 2, 12);//把Calendar对象c1的年月日分别设这为2020.2.12 利用字段类型设置 如果只设定某个字段，例如日期的值，则可以使用如下set方法： 1public void set(int field,int value) 把 c1对象代表的日期设置为10号，其它所有的数值会被重新计算 1c1.set(Calendar.DATE,10); 把c1对象代表的年份设置为2008年，其他的所有数值会被重新计算 1c1.set(Calendar.YEAR,2008); 其他字段属性set的意义以此类推 Add设置 1Calendar c1 = Calendar.getInstance(); 把c1对象的日期加上10，也就是c1也就表示为10天后的日期，其它所有的数值会被重新计算 1c1.add(Calendar.DATE, 10); 把c1对象的日期减去10，也就是c1也就表示为10天前的日期，其它所有的数值会被重新计算 1c1.add(Calendar.DATE, -10); 其他字段属性的add的意义以此类推 1234567891011 Calendar类对象信息的获得Calendar c1 = Calendar.getInstance(); // 获得年份 int year = c1.get(Calendar.YEAR); // 获得月份int month = c1.get(Calendar.MONTH) + 1; // 获得日期int date = c1.get(Calendar.DATE); // 获得小时 int hour = c1.get(Calendar.HOUR_OF_DAY); // 获得分钟int minute = c1.get(Calendar.MINUTE); // 获得秒int second = c1.get(Calendar.SECOND); // 获得星期几（注意（这个与Date类是不同的）：1代表星期日、2代表星期1、3代表星期二，以此类推） int day = c1.get(Calendar.DAY_OF_WEEK); :basketball_man:GregorianCalendar类 Calendar类实现了公历日历，GregorianCalendar是Calendar类的一个具体实现。 Calendar 的getInstance（）方法返回一个默认用当前的语言环境和时区初始化的GregorianCalendar对象。GregorianCalendar定义了两个字段：AD和BC。这是代表公历定义的两个时代。 下面列出GregorianCalendar对象的几个构造方法： 序号 构造函数和说明 1 GregorianCalendar() 在具有默认语言环境的默认时区内使用当前时间构造一个默认的 GregorianCalendar。 2 GregorianCalendar(int year, int month, int date) 在具有默认语言环境的默认时区内构造一个带有给定日期设置的 GregorianCalendar 3 GregorianCalendar(int year, int month, int date, int hour, int minute) 为具有默认语言环境的默认时区构造一个具有给定日期和时间设置的 GregorianCalendar。 4 GregorianCalendar(int year, int month, int date, int hour, int minute, int second) 为具有默认语言环境的默认时区构造一个具有给定日期和时间设置的 GregorianCalendar。 5 GregorianCalendar(Locale aLocale) 在具有给定语言环境的默认时区内构造一个基于当前时间的 GregorianCalendar。 6 GregorianCalendar(TimeZone zone) 在具有默认语言环境的给定时区内构造一个基于当前时间的 GregorianCalendar。 7 GregorianCalendar(TimeZone zone, Locale aLocale) 在具有给定语言环境的给定时区内构造一个基于当前时间的 GregorianCalendar。 这里是GregorianCalendar 类提供的一些有用的方法列表： 序号 方法和说明 1 void add(int field, int amount) 根据日历规则，将指定的（有符号的）时间量添加到给定的日历字段中。 2 protected void computeFields() 转换UTC毫秒值为时间域值 3 protected void computeTime() 覆盖Calendar ，转换时间域值为UTC毫秒值 4 boolean equals(Object obj) 比较此 GregorianCalendar 与指定的 Object。 5 int get(int field) 获取指定字段的时间值 6 int getActualMaximum(int field) 返回当前日期，给定字段的最大值 7 int getActualMinimum(int field) 返回当前日期，给定字段的最小值 8 int getGreatestMinimum(int field) 返回此 GregorianCalendar 实例给定日历字段的最高的最小值。 9 Date getGregorianChange() 获得格里高利历的更改日期。 10 int getLeastMaximum(int field) 返回此 GregorianCalendar 实例给定日历字段的最低的最大值 11 int getMaximum(int field) 返回此 GregorianCalendar 实例的给定日历字段的最大值。 12 Date getTime() 获取日历当前时间。 13 long getTimeInMillis() 获取用长整型表示的日历的当前时间 14 TimeZone getTimeZone() 获取时区。 15 int getMinimum(int field) 返回给定字段的最小值。 16 int hashCode() 重写hashCode. 17 boolean isLeapYear(int year) 确定给定的年份是否为闰年。 18 void roll(int field, boolean up) 在给定的时间字段上添加或减去（上/下）单个时间单元，不更改更大的字段。 19 void set(int field, int value) 用给定的值设置时间字段。 20 void set(int year, int month, int date) 设置年、月、日的值。 21 void set(int year, int month, int date, int hour, int minute) 设置年、月、日、小时、分钟的值。 22 void set(int year, int month, int date, int hour, int minute, int second) 设置年、月、日、小时、分钟、秒的值。 23 void setGregorianChange(Date date) 设置 GregorianCalendar 的更改日期。 24 void setTime(Date date) 用给定的日期设置Calendar的当前时间。 25 void setTimeInMillis(long millis) 用给定的long型毫秒数设置Calendar的当前时间。 26 void setTimeZone(TimeZone value) 用给定时区值设置当前时区。 27 String toString() 返回代表日历的字符串。 java正则表达式正则表达式定义了字符串的模式。可以用来搜索，编辑或者处理文本。一个字符串其实就是一个简单的正则表达式。 java.util.regex 包主要包括以下三个类： Pattern 类： pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。 Matcher 类： Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。 PatternSyntaxException： PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。 :basketball_man:正则表达式语法 在其他语言中，\\ 表示：我想要在正则表达式中插入一个普通的（字面上的）反斜杠，请不要给它任何特殊的意义。 在 Java 中，\\ 表示：我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。 所以，在其他的语言中（如Perl），一个反斜杠 \\ 就足以具有转义的作用，而在 Java 中正则表达式中则需要有两个反斜杠才能被解析为其他语言中的转义作用。也可以简单的理解在 Java 的正则表达式中，两个 \\ 代表其他语言中的一个 \\，这也就是为什么表示一位数字的正则表达式是 \\d，而表示一个普通的反斜杠是 \\\\。 字符 说明 \\ 将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，”n”匹配字符”n”。”\\n”匹配换行符。序列”\\\\“匹配”\\“，”\\(“匹配”(“。 ^ 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与”\\n”或”\\r”之后的位置匹配。 $ 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与”\\n”或”\\r”之前的位置匹配。 * 零次或多次匹配前面的字符或子表达式。例如，zo* 匹配”z”和”zoo”。* 等效于 {0,}。 + 一次或多次匹配前面的字符或子表达式。例如，”zo+”与”zo”和”zoo”匹配，但与”z”不匹配。+ 等效于 {1,}。 ? 零次或一次匹配前面的字符或子表达式。例如，”do(es)?”匹配”do”或”does”中的”do”。? 等效于 {0,1}。 {n} n 是非负整数。正好匹配 n 次。例如，”o{2}”与”Bob”中的”o”不匹配，但与”food”中的两个”o”匹配。 {n,} n 是非负整数。至少匹配 n 次。例如，”o{2,}”不匹配”Bob”中的”o”，而匹配”foooood”中的所有 o。”o{1,}”等效于”o+”。”o{0,}”等效于”o*”。 {n,m} m 和 n 是非负整数，其中 n &lt;= m。匹配至少 n 次，至多 m 次。例如，”o{1,3}”匹配”fooooood”中的头三个 o。’o{0,1}’ 等效于 ‘o?’。注意：您不能将空格插入逗号和数字之间。 ? 当此字符紧随任何其他限定符（、+、?、{*n}、{n,}、{n,m}）之后时，匹配模式是”非贪心的”。”非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的”贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串”oooo”中，”o+?”只匹配单个”o”，而”o+”匹配所有”o”。 . 匹配除”\\r\\n”之外的任何单个字符。若要匹配包括”\\r\\n”在内的任意字符，请使用诸如”[\\s\\S]”之类的模式。 (pattern) 匹配 pattern 并捕获该匹配的子表达式。可以使用 $0…$9 属性从结果”匹配”集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用”(“或者”)“。 (?:pattern) 匹配 pattern 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用”or”字符 (|) 组合模式部件的情况很有用。例如，’industr(?:y|ies) 是比 ‘industry|industries’ 更经济的表达式。 (?=pattern) 执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 pattern 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?=95|98|NT|2000)’ 匹配”Windows 2000”中的”Windows”，但不匹配”Windows 3.1”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。 (?!pattern) 执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 pattern 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?!95|98|NT|2000)’ 匹配”Windows 3.1”中的 “Windows”，但不匹配”Windows 2000”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。 x|y 匹配 x 或 y。例如，’z|food’ 匹配”z”或”food”。’(z|f)ood’ 匹配”zood”或”food”。 [xyz] 字符集。匹配包含的任一字符。例如，”[abc]”匹配”plain”中的”a”。 [^xyz] 反向字符集。匹配未包含的任何字符。例如，”[^abc]”匹配”plain”中”p”，”l”，”i”，”n”。 [a-z] 字符范围。匹配指定范围内的任何字符。例如，”[a-z]”匹配”a”到”z”范围内的任何小写字母。 [^a-z] 反向范围字符。匹配不在指定的范围内的任何字符。例如，”[^a-z]”匹配任何不在”a”到”z”范围内的任何字符。 \\b 匹配一个字边界，即字与空格间的位置。例如，”er\\b”匹配”never”中的”er”，但不匹配”verb”中的”er”。 \\B 非字边界匹配。”er\\B”匹配”verb”中的”er”，但不匹配”never”中的”er”。 \\cx 匹配 x 指示的控制字符。例如，\\cM 匹配 Control-M 或回车符。x 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是”c”字符本身。 \\d 数字字符匹配。等效于 [0-9]。 \\D 非数字字符匹配。等效于 [^0-9]。 \\f 换页符匹配。等效于 \\x0c 和 \\cL。 \\n 换行符匹配。等效于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等效于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等。与 [ \\f\\n\\r\\t\\v] 等效。 \\S 匹配任何非空白字符。与 [^ \\f\\n\\r\\t\\v] 等效。 \\t 制表符匹配。与 \\x09 和 \\cI 等效。 \\v 垂直制表符匹配。与 \\x0b 和 \\cK 等效。 \\w 匹配任何字类字符，包括下划线。与”[A-Za-z0-9_]”等效。 \\W 与任何非单词字符匹配。与”[^A-Za-z0-9_]”等效。 \\xn 匹配 n，此处的 n 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，”\\x41”匹配”A”。”\\x041”与”\\x04”&amp;”1”等效。允许在正则表达式中使用 ASCII 代码。 *num* 匹配 num*，此处的 *num 是一个正整数。到捕获匹配的反向引用。例如，”(.)\\1”匹配两个连续的相同字符。 *n* 标识一个八进制转义码或反向引用。如果 *n* 前面至少有 n 个捕获子表达式，那么 n 是反向引用。否则，如果 n 是八进制数 (0-7)，那么 n 是八进制转义码。 *nm* 标识一个八进制转义码或反向引用。如果 *nm* 前面至少有 nm 个捕获子表达式，那么 nm 是反向引用。如果 *nm* 前面至少有 n 个捕获，则 n 是反向引用，后面跟有字符 m。如果两种前面的情况都不存在，则 *nm* 匹配八进制值 nm*，其中 *n 和 m 是八进制数字 (0-7)。 \\nml 当 n 是八进制数 (0-3)，m 和 l 是八进制数 (0-7) 时，匹配八进制转义码 nml。 \\un 匹配 n，其中 n 是以四位十六进制数表示的 Unicode 字符。例如，\\u00A9 匹配版权符号 (©)。 根据 Java Language Specification 的要求，Java 源代码的字符串中的反斜线被解释为 Unicode 转义或其他字符转义。因此必须在字符串字面值中使用两个反斜线，表示正则表达式受到保护，不被 Java 字节码编译器解释。例如，当解释为正则表达式时，字符串字面值 “\\b” 与单个退格字符匹配，而 “\\b” 与单词边界匹配。字符串字面值 “(hello)“ 是非法的，将导致编译时错误；要与字符串 (hello) 匹配，必须使用字符串字面值 “\\(hello\\)”。 java方法Java方法是语句的集合，它们在一起执行一个功能。 方法是解决一类问题的步骤的有序组合 方法包含于类或对象中 方法在程序中被创建，在其他地方被引用 方法的定义 一般情况下，定义一个方法包含以下语法： 修饰符 返回值类型 方法名(参数类型 参数名){ … 方法体 … return 返回值; } 注意： 在一些其它语言中方法指过程和函数。一个返回非void类型返回值的方法称为函数；一个返回void类型返回值的方法叫做过程。 方法调用 Java 支持两种调用方法的方式，根据方法是否返回值来选择。 当方法返回一个值的时候，方法调用通常被当做一个值。例如： 1int larger = max(30, 40); 如果方法返回值是void，方法调用一定是一条语句。例如，方法println返回void。下面的调用是个语句： 1System.out.println(\"欢迎访问菜鸟教程！\"); 一个void方法的调用一定是一个语句。 所以，它被在main方法第三行以语句形式调用。就像任何以分号结束的语句一样。 示例下面的例子演示按值传递的效果。 该程序创建一个方法，该方法用于交换两个变量。 TestPassByValue.java 文件代码： 123456789101112131415161718192021222324252627public class TestPassByValue { public static void main(String[] args) { int num1 = 1; int num2 = 2; System.out.println(\"交换前 num1 的值为：\" + num1 + \" ，num2 的值为：\" + num2); // 调用swap方法 swap(num1, num2); System.out.println(\"交换后 num1 的值为：\" + num1 + \" ，num2 的值为：\" + num2); } /** 交换两个变量的方法 */ public static void swap(int n1, int n2) { System.out.println(\"\\t进入 swap 方法\"); System.out.println(\"\\t\\t交换前 n1 的值为：\" + n1 + \"，n2 的值：\" + n2); // 交换 n1 与 n2的值 int temp = n1; n1 = n2; n2 = temp; System.out.println(\"\\t\\t交换后 n1 的值为 \" + n1 + \"，n2 的值：\" + n2); }} 以上实例编译运行结果如下： 12345交换前 num1 的值为：1 ，num2 的值为：2 进入 swap 方法 交换前 n1 的值为：1，n2 的值：2 交换后 n1 的值为 2，n2 的值：1交换后 num1 的值为：1 ，num2 的值为：2 传递两个参数调用swap方法。有趣的是，方法被调用后，实参的值并没有改变。 构造方法 当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值。 通常会使用构造方法给一个类的实例变量赋初值，或者执行其它必要的步骤来创建一个完整的对象。 不管你是否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个默认构造方法，默认构造方法的访问修改符和类的访问修改符相同(类为 public，构造函数也为 public；类改为 protected，构造函数也改为 protected)。 一旦你定义了自己的构造方法，默认构造方法就会失效。 :basketball_man:可变参数 JDK 1.5 开始，Java支持传递同类型的可变参数给一个方法。 方法的可变参数的声明如下所示： typeName… parameterName 在方法声明中，在指定参数类型后加一个省略号(…) 。 一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。 实例 1234567891011121314151617181920212223public class VarargsDemo { public static void main(String args[]) { // 调用可变参数的方法 printMax(34, 3, 3, 2, 56.5); printMax(new double[]{1, 2, 3}); } public static void printMax( double... numbers) { if (numbers.length == 0) { System.out.println(\"No argument passed\"); return; } double result = numbers[0]; for (int i = 1; i &lt; numbers.length; i++){ if (numbers[i] &gt; result) { result = numbers[i]; } } System.out.println(\"The max value is \" + result); }} 以上实例编译运行结果如下： 12The max value is 56.5The max value is 3.0 java流（Stream）、文件（File)和IO读取控制台输入 Java 的控制台输入由 System.in 完成。 为了获得一个绑定到控制台的字符流，你可以把 System.in 包装在一个 BufferedReader 对象中来创建一个字符流。 下面是创建 BufferedReader 的基本语法： 1BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedReader 对象创建后，我们便可以使用 read() 方法从控制台读取一个字符，或者用 readLine() 方法读取一个字符串。 从控制台读取多字符输入 从 BufferedReader 对象读取一个字符要使用 read() 方法，它的语法如下： int read( ) throws IOException 每次调用 read() 方法，它从输入流读取一个字符并把该字符作为整数值返回。 当流结束的时候返回 -1。该方法抛出 IOException。 下面的程序示范了用 read() 方法从控制台不断读取字符直到用户输入 “q”。 1234567891011121314151617//使用 BufferedReader 在控制台读取字符 import java.io.*; public class BRRead { public static void main(String args[]) throws IOException { char c; // 使用 System.in 创建 BufferedReader BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"输入字符, 按下 'q' 键退出。\"); // 读取字符 do { c = (char) br.read(); System.out.println(c); } while (c != 'q'); }} 从控制台读取字符串 从标准输入读取一个字符串需要使用 BufferedReader 的 readLine() 方法。 它的一般格式是： 1String readLine( ) throws IOException 读写文件 :basketball_man:FileInputStream 该流用于从文件读取数据，它的对象可以用关键字 new 来创建。 有多种构造方法可用来创建对象。 可以使用字符串类型的文件名来创建一个输入流对象来读取文件： InputStream f = new FileInputStream(“C:/java/hello”); 也可以使用一个文件对象来创建一个输入流对象来读取文件。我们首先得使用 File() 方法来创建一个文件对象： File f = new File(“C:/java/hello”); InputStream out = new FileInputStream(f); 创建了InputStream对象，就可以使用下面的方法来读取流或者进行其他的流操作。 序号 方法及描述 1 public void close() throws IOException{} 关闭此文件输入流并释放与此流有关的所有系统资源。抛出IOException异常。 2 protected void finalize()throws IOException {} 这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其 close 方法。抛出IOException异常。 3 public int read(int r)throws IOException{} 这个方法从 InputStream 对象读取指定字节的数据。返回为整数值。返回下一字节数据，如果已经到结尾则返回-1。 4 public int read(byte[] r) throws IOException{} 这个方法从输入流读取r.length长度的字节。返回读取的字节数。如果是文件结尾则返回-1。 5 public int available() throws IOException{} 返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取的字节数。返回一个整数值。 :basketball_man:FileOutputStream 该类用来创建一个文件并向文件中写数据。 如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件。 有两个构造方法可以用来创建 FileOutputStream 对象。 使用字符串类型的文件名来创建一个输出流对象： OutputStream f = new FileOutputStream(“C:/java/hello”) 也可以使用一个文件对象来创建一个输出流来写文件。我们首先得使用File()方法来创建一个文件对象： File f = new File(“C:/java/hello”); OutputStream f = new FileOutputStream(f); 创建OutputStream 对象完成后，就可以使用下面的方法来写入流或者进行其他的流操作。 序号 方法及描述 1 public void close() throws IOException{} 关闭此文件输入流并释放与此流有关的所有系统资源。抛出IOException异常。 2 protected void finalize()throws IOException {} 这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其 close 方法。抛出IOException异常。 3 public void write(int w)throws IOException{} 这个方法把指定的字节写到输出流中。 4 public void write(byte[] w) 把指定数组中w.length长度的字节写到OutputStream中。 :man:Java中的目录 创建目录： File类中有两个方法可以用来创建文件夹： mkdir( )方法创建一个文件夹，成功则返回true，失败则返回false。失败表明File对象指定的路径已经存在，或者由于整个路径还不存在，该文件夹不能被创建。 mkdirs()方法创建一个文件夹和它的所有父文件夹。 下面的例子创建 “/tmp/user/java/bin”文件夹： CreateDir.java 文件代码： import java.io.File; public class CreateDir { public static void main(String args[]) { String dirname = “/tmp/user/java/bin”; File d = new File(dirname); // 现在创建目录 d.mkdirs(); } } 编译并执行上面代码来创建目录 “/tmp/user/java/bin”。 注意： Java 在 UNIX 和 Windows 自动按约定分辨文件路径分隔符。如果你在 Windows 版本的 Java 中使用分隔符 (/) ，路径依然能够被正确解析。 读取目录 一个目录其实就是一个 File 对象，它包含其他文件和文件夹。 如果创建一个 File 对象并且它是一个目录，那么调用 isDirectory() 方法会返回 true。 可以通过调用该对象上的 list() 方法，来提取它包含的文件和文件夹的列表。 12345678910111213141516171819202122232425下面展示的例子说明如何使用 list() 方法来检查一个文件夹中包含的内容：DirList.java 文件代码：import java.io.File; public class DirList { public static void main(String args[]) { String dirname = \"/tmp\"; File f1 = new File(dirname); if (f1.isDirectory()) { System.out.println(\"目录 \" + dirname); String s[] = f1.list(); for (int i = 0; i &lt; s.length; i++) { File f = new File(dirname + \"/\" + s[i]); if (f.isDirectory()) { System.out.println(s[i] + \" 是一个目录\"); } else { System.out.println(s[i] + \" 是一个文件\"); } } } else { System.out.println(dirname + \" 不是一个目录\"); } }} 1234567891011121314151617181920212223242526272829303132333435删除目录或文件删除文件可以使用 java.io.File.delete() 方法。以下代码会删除目录 /tmp/java/，需要注意的是当删除某一目录时，必须保证该目录下没有其他文件才能正确删除，否则将删除失败。测试目录结构：/tmp/java/|-- 1.log|-- testDeleteFileDemo.java 文件代码：import java.io.File; public class DeleteFileDemo { public static void main(String args[]) { // 这里修改为自己的测试目录 File folder = new File(\"/tmp/java/\"); deleteFolder(folder); } // 删除文件及目录 public static void deleteFolder(File folder) { File[] files = folder.listFiles(); if (files != null) { for (File f : files) { if (f.isDirectory()) { deleteFolder(f); } else { f.delete(); } } } folder.delete(); }} java Scanner类java.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。 下面是创建 Scanner 对象的基本语法： Scanner s = new Scanner(System.in); 接下来我们演示一个最简单的数据输入，并通过 Scanner 类的 next() 与 nextLine() 方法获取输入的字符串，在读取前我们一般需要 使用 hasNext 与 hasNextLine 判断是否还有输入的数据： 使用 next 方法：ScannerDemo.java 文件代码：ava.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。 下面是创建 Scanner 对象的基本语法： Scanner s = new Scanner(System.in); 接下来我们演示一个最简单的数据输入，并通过 Scanner 类的 next() 与 nextLine() 方法获取输入的字符串，在读取前我们一般需要 使用 hasNext 与 hasNextLine 判断是否还有输入的数据： 使用 next 方法： 1234567891011121314151617import java.util.Scanner; public class ScannerDemo { public static void main(String[] args) { Scanner scan = new Scanner(System.in); // 从键盘接收数据 // next方式接收字符串 System.out.println(\"next方式接收：\"); // 判断是否还有输入 if (scan.hasNext()) { String str1 = scan.next(); System.out.println(\"输入的数据为：\" + str1); } scan.close(); }} 执行以上程序输出结果为： 12345$ javac ScannerDemo.java$ java ScannerDemonext方式接收：runoob com输入的数据为：runoob 12345678910111213141516171819使用 nextLine 方法：ScannerDemo.java 文件代码：import java.util.Scanner; public class ScannerDemo { public static void main(String[] args) { Scanner scan = new Scanner(System.in); // 从键盘接收数据 // nextLine方式接收字符串 System.out.println(\"nextLine方式接收：\"); // 判断是否还有输入 if (scan.hasNextLine()) { String str2 = scan.nextLine(); System.out.println(\"输入的数据为：\" + str2); } scan.close(); }} next(): 1、一定要读取到有效字符后才可以结束输入。 2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。 3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。 next() 不能得到带有空格的字符串。 nextLine()： 1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。 2、可以获得空白。 如果要输入 int 或 float 类型的数据，在 Scanner 类中也有支持，但是在输入之前最好先使用 hasNextXxx() 方法进行验证，再使用 nextXxx() 来读取： 12345678910111213141516171819202122232425262728293031import java.util.Scanner; public class ScannerDemo { public static void main(String[] args) { Scanner scan = new Scanner(System.in); // 从键盘接收数据 int i = 0; float f = 0.0f; System.out.print(\"输入整数：\"); if (scan.hasNextInt()) { // 判断输入的是否是整数 i = scan.nextInt(); // 接收整数 System.out.println(\"整数数据：\" + i); } else { // 输入错误的信息 System.out.println(\"输入的不是整数！\"); } System.out.print(\"输入小数：\"); if (scan.hasNextFloat()) { // 判断输入的是否是小数 f = scan.nextFloat(); // 接收小数 System.out.println(\"小数数据：\" + f); } else { // 输入错误的信息 System.out.println(\"输入的不是小数！\"); } scan.close(); }} java异常处理要理解Java异常处理是如何工作的， 需要掌握以下三种类型的异常： 检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。 运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。 错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。 Error 用来指示运行时环境发生的错误。 例如，JVM 内存溢出。一般地，程序不会从错误中恢复。 异常类有两个主要的子类：IOException 类和 RuntimeException 类。 异常方法 下面的列表是 Throwable 类的主要方法: 序号 方法及说明 1 public String getMessage() 返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。 2 public Throwable getCause() 返回一个Throwable 对象代表异常原因。 3 public String toString() 使用getMessage()的结果返回类的串级名字。 4 public void printStackTrace() 打印toString()结果和栈层次到System.err，即错误输出流。 5 public StackTraceElement [] getStackTrace() 返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。 6 public Throwable fillInStackTrace() 用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。 捕获异常 使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。 try/catch代码块中的代码称为保护代码，使用 try/catch 的语法如下： 1234567try{ // 程序代码}catch(ExceptionName e1){ //Catch 块} Catch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。 如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块，这和传递一个参数到方法是一样。 多重捕获块 一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获。 多重捕获块的语法如下所示： try{ // 程序代码 }catch(异常类型1 异常的变量名1){ // 程序代码 }catch(异常类型2 异常的变量名2){ // 程序代码 }catch(异常类型2 异常的变量名2){ // 程序代码 } throws/throw 关键字： 如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。 也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。 12345678910import java.io.*;public class className{ public void deposit(double amount) throws RemoteException { // Method implementation throw new RemoteException(); } //Remainder of class definition} 一个方法可以声明抛出多个异常，多个异常之间用逗号隔开。 finally关键字 finally 关键字用来创建在 try 代码块后面执行的代码块。 无论是否发生异常，finally 代码块中的代码总会被执行。 在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。 finally 代码块出现在 catch 代码块最后，语法如下： 12345try{ // 程序代码 }catch(异常类型1 异常的变量名1){ // 程序代码 }catch(异常类型2 异常的变量名2){ // 程序代码 }finally{ // 程序代码 } 注意下面事项： catch 不能独立于 try 存在。 在 try/catch 后面添加 finally 块并非强制性要求的。 try 代码后不能既没 catch 块也没 finally 块。 try, catch, finally 块之间不能添加任何代码。 声明自定义异常 在 Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。 所有异常都必须是 Throwable 的子类。 如果希望写一个检查性异常类，则需要继承 Exception 类。 如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。 1class MyException extends Exception{ } 通用异常 在Java中定义了两种类型的异常和错误。 JVM(Java**虚拟机) 异常：由 JVM 抛出的异常或错误。例如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类。 程序级异常：由程序或者API程序抛出的异常。例如 IllegalArgumentException 类，IllegalStateException 类。","link":"/2020/03/07/java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"}],"tags":[{"name":"github","slug":"github","link":"/tags/github/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"win10重装","slug":"win10重装","link":"/tags/win10%E9%87%8D%E8%A3%85/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"三体","slug":"三体","link":"/tags/%E4%B8%89%E4%BD%93/"},{"name":"寒窑赋","slug":"寒窑赋","link":"/tags/%E5%AF%92%E7%AA%91%E8%B5%8B/"},{"name":"学历","slug":"学历","link":"/tags/%E5%AD%A6%E5%8E%86/"},{"name":"性格认知","slug":"性格认知","link":"/tags/%E6%80%A7%E6%A0%BC%E8%AE%A4%E7%9F%A5/"},{"name":"日记","slug":"日记","link":"/tags/%E6%97%A5%E8%AE%B0/"}],"categories":[{"name":"github","slug":"github","link":"/categories/github/"},{"name":"编程语言","slug":"编程语言","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"写作工具","slug":"写作工具","link":"/categories/%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7/"},{"name":"操作系统","slug":"操作系统","link":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"句子迷","slug":"句子迷","link":"/categories/%E5%8F%A5%E5%AD%90%E8%BF%B7/"},{"name":"转载","slug":"转载","link":"/categories/%E8%BD%AC%E8%BD%BD/"},{"name":"心情随笔","slug":"心情随笔","link":"/categories/%E5%BF%83%E6%83%85%E9%9A%8F%E7%AC%94/"}]}