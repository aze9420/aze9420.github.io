{"pages":[],"posts":[{"title":"软件工程学习笔记","text":"","link":"/2020/03/04/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/03/05/hello-world/"},{"title":"github搜索技巧","text":"github 项目名字(name)里有 python 的in:name python 名字(name)里有 python 的并且 stars 大于 3000 的in:name python starts:&gt;3000 名字(name)里有 python 的并且 stars 大于 3000 、forks 大于 200 的in:name python starts:&gt;3000 forks:&gt;200 详情(readme)里面有 python 的并且 stars 大于 3000 的in:readme python starts:&gt;3000 描述(description)里面有 python 的并且 stars 大于 3000 的in:description python starts:&gt;3000 描述(description)里面有 python 的并且是 python 语言的in:description python language:python 描述(description)里面有 python 的并且 2019-12-20 号之后有更新过的in:description python pushed:&gt;2019-12-20","link":"/2020/02/15/github%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/"},{"title":"leetcode练习","text":"1. 两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 方法一：暴力法暴力法很简单，遍历每个元素 xx，并查找是否存在一个值与 target - xtarget−x 相等的目标元素。 Java 123456789101112class Solution { public int[] twoSum(int[] nums, int target) { for (int i = 0; i &lt; nums.length; i++) { for (int j = i + 1; j &lt; nums.length; j++) { if (nums[j] == target - nums[i]) { return new int[] { i, j }; } } } throw new IllegalArgumentException(\"No two sum solution\"); }} 复杂度分析： 复杂度分析： 时间复杂度：O(n^2)O(n^2)对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n)O(n) 的时间。因此时间复杂度为 O(n^2)O(n^2)。 空间复杂度：O(1)O(1)。 方法二：两遍哈希表为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。 通过以空间换取速度的方式，我们可以将查找时间从 O(n)O(n) 降低到 O(1)O(1)。哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)O(1)。 一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]target−nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i]nums[i] 本身！ Java 123456789101112131415class Solution { public int[] twoSum(int[] nums, int target) { Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) { map.put(nums[i], i); } for (int i = 0; i &lt; nums.length; i++) { int complement = target - nums[i]; if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) { return new int[] { i, map.get(complement) }; } } throw new IllegalArgumentException(\"No two sum solution\"); }} 复杂度分析： 时间复杂度：O(n)O(n)，我们把包含有 nn 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1)O(1) ，所以时间复杂度为 O(n)O(n)。 空间复杂度：O(n)O(n)，所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 nn 个元素。 方法三：一遍哈希表事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。 Java 12345678910111213class Solution { public int[] twoSum(int[] nums, int target) { Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) { int complement = target - nums[i]; if (map.containsKey(complement)) { return new int[] { map.get(complement), i }; } map.put(nums[i], i); } throw new IllegalArgumentException(\"No two sum solution\"); }} 复杂度分析： 时间复杂度：O(n)O(n)，我们只遍历了包含有 nn 个元素的列表一次。在表中进行的每次查找只花费 O(1)O(1) 的时间。 空间复杂度：O(n)O(n)，所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 nn 个元素。 2. 两数相加给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807","link":"/2020/02/29/leetcode%E7%BB%83%E4%B9%A0/"},{"title":"java面向对象笔记","text":"java继承 类的继承格式 在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来的，一般形式如下： 类的继承格式 1class 父类 { } class 子类 extends 父类 { } 继承的意义： 子类就不会存在重复的代码，维护性也提高，代码也更加简洁，提高代码的复用性（复用性主要是可以多次使用，不用再多次写同样的代码） 继承类型 需要注意的是 Java 不支持多继承，但支持多重继承。 继承的特性 子类拥有父类非 private 的属性、方法。 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。 Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C 类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。 继承关键字 继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 java.lang 包中，所以不需要 import）祖先类。 extends关键字: 在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。 implements关键字: 使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。 1234567891011public interface A { public void eat(); public void sleep();} public interface B { public void show();} public class C implements A,B {} super 与 this 关键字: super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。 this关键字：指向自己的引用。 final关键字: final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写： 构造器 子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表。 如果父类构造器没有参数，则在子类的构造器中不需要使用 super 关键字调用父类构造器，系统会自动调用父类的无参构造器。 java重写（Override）与重载（Overload）重写(Override) 重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！ 重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。 重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。 在面向对象原则里，重写意味着可以重写任何现有方法。实例如下： 方法的重写规则 参数列表必须完全与被重写方法的相同。 返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。 父类的成员方法只能被它的子类重写。 声明为 final 的方法不能被重写。 声明为 static 的方法不能被重写，但是能够被再次声明。 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。 构造方法不能被重写。 如果不能继承一个方法，则不能重写这个方法。 Super 关键字的使用 当需要在子类中调用父类的被重写方法时，要使用 super 关键字。 重载(Overload) 重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。 每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。 最常用的地方就是构造器的重载。 重载规则: 被重载的方法必须改变参数列表(参数个数或类型不一样)； 被重载的方法可以改变返回类型； 被重载的方法可以改变访问修饰符； 被重载的方法可以声明新的或更广的检查异常； 方法能够在同一个类中或者在一个子类中被重载。 无法以返回值类型作为重载函数的区分标准。 ​ 重写与重载之间的区别 区别点 重载方法 重写方法 参数列表 必须修改 一定不能修改 返回类型 可以修改 一定不能修改 异常 可以修改 可以减少或删除，一定不能抛出新的或者更广的异常 访问 可以修改 一定不能做更严格的限制（可以降低限制） 总结 方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。 (1)方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。 (2)方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。 (3)方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。 java多态多态是同一个行为具有多个不同表现形式或形态的能力。 多态就是同一个接口，使用不同的实例而执行不同操作，如图所示： 多态性是对象多种表现形式的体现。 多态的优点 \\1. 消除类型之间的耦合关系 \\2. 可替换性 \\3. 可扩充性 \\4. 接口性 \\5. 灵活性 \\6. 简化性 多态存在的三个必要条件 继承 重写 父类引用指向子类对象 比如： 1Parent p = new Child(); 当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。 多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。 :basketball_man:多态的实现方式 方式一：重写： Java 重写(Override)与重载(Overload)。 方式二：接口 \\1. 生活中的接口最具代表性的就是插座，例如一个三接头的插头都能接在三孔插座中，因为这个是每个国家都有各自规定的接口规则，有可能到国外就不行，那是因为国外自己定义的接口类型。 \\2. java中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现。具体可以看 java接口 这一章节的内容。 方式三：抽象类和抽象方法 java抽象类如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。 由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。 在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。 抽象类 在Java语言中使用abstract class来定义抽象类。 继承抽象类 我们能通过一般的方法继承Employee类： 抽象方法 如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。 Abstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。 抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。 12345678910public abstract class Employee{ private String name; private String address; private int number; public abstract double computePay(); //其余代码} 声明抽象方法会造成以下两个结果： 如果一个类包含抽象方法，那么该类必须是抽象类。 任何子类必须重写父类的抽象方法，或者声明自身为抽象类。 继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。 如果Salary类继承了Employee类，那么它必须实现computePay()方法： 抽象类总结规定 \\1. 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。 \\2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 \\3. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。 \\4. 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。 \\5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。 java封装在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。 封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。 要访问该类的代码和数据，必须通过严格的接口控制。 封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。 适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。 封装的优点 \\1. 良好的封装能够减少耦合。 \\2. 类内部的结构可以自由修改。 \\3. 可以对成员变量进行更精确的控制。 \\4. 隐藏信息，实现细节。 实现Java封装的步骤 修改属性的可见性来限制对属性的访问（一般限制为private），例如： 1234public class Person { private String name; private int age;} 这段代码中，将 name 和 age 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。 2、对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问，例如： 123456789101112131415161718public class Person{ private String name; private int age; public int getAge(){ return age; } public String getName(){ return name; } public void setAge(int age){ this.age = age; } public void setName(String name){ this.name = name; }} 采用 this 关键字是为了解决实例变量（private String name）和局部变量（setName(String name)中的name变量）之间发生的同名的冲突。 通常情况下，这些方法被称为getter和setter方法。 因此，任何要访问类中私有成员变量的类都要通过这些getter和setter方法。 java接口接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。 接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。 除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。 接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。 接口与类相似点： 一个接口可以有多个方法。 接口文件保存在 .java 结尾的文件中，文件名使用接口名。 接口的字节码文件保存在 .class 结尾的文件中。 接口相应的字节码文件必须在与包名称相匹配的目录结构中。 接口与类的区别： 接口不能用于实例化对象。 接口没有构造方法。 接口中所有的方法必须是抽象方法。 接口不能包含成员变量，除了 static 和 final 变量。 接口不是被类继承了，而是要被类实现。 接口支持多继承。 接口特性 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。 接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。 抽象类和接口的区别 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。 一个类只能继承一个抽象类，而一个类却可以实现多个接口。 注：JDK 1.8 以后，接口里可以有静态方法和方法体了。 接口的声明 接口的声明语法格式如下： 1234[可见度] interface 接口名称 [extends 其他的接口名] { // 声明变量 // 抽象方法} Interface关键字用来声明一个接口。 接口有以下特性： 接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。 接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字。 接口中的方法都是公有的。 接口的实现 当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。 类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。 重写接口中声明的方法时，需要注意以下规则： 类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。 类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。 如果实现接口的类是抽象类，那么就没必要实现该接口的方法。 在实现接口的时候，也要注意一些规则： 一个类可以同时实现多个接口。 一个类只能继承一个类，但是能实现多个接口。 一个接口能继承另一个接口，这和类之间的继承比较相似。 接口的继承 一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。 下面的Sports接口被Hockey和Football接口继承： 1234567891011121314151617181920212223// 文件名: Sports.javapublic interface Sports{ public void setHomeTeam(String name); public void setVisitingTeam(String name);} // 文件名: Football.javapublic interface Football extends Sports{ public void homeTeamScored(int points); public void visitingTeamScored(int points); public void endOfQuarter(int quarter);} // 文件名: Hockey.javapublic interface Hockey extends Sports{ public void homeGoalScored(); public void visitingGoalScored(); public void endOfPeriod(int period); public void overtimePeriod(int ot);} Hockey接口自己声明了四个方法，从Sports接口继承了两个方法，这样，实现Hockey接口的类需要实现六个方法。 相似的，实现Football接口的类需要实现五个方法，其中两个来自于Sports接口。 接口的多继承 在Java中，类的多继承是不合法，但接口允许多继承。 在接口的多继承中extends关键字只需要使用一次，在其后跟着继承接口。 如下所示： 1public interface Hockey extends Sports, Event 以上的程序片段是合法定义的子接口，与类不同的是，接口允许多继承，而 Sports及 Event 可能定义或是继承相同的方法 标记接口 最常用的继承接口是没有包含任何方法的接口。 标记接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。 标记接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。 例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下： 123package java.util;public interface EventListener{} 没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的： 建立一个公共的父接口： 正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。 向一个类添加数据类型： 这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。 java包（package）包的作用 1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。 2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。 3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。 Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。 包语句的语法格式为： 1234567package pkg1[．pkg2[．pkg3…]];例如：package net.java.util;public class Something{ ...} 创建包 创建包的时候，你需要为这个包取一个合适的名字。之后，如果其他的一个源文件包含了这个包提供的类、接口、枚举或者注释类型的时候，都必须将这个包的声明放在这个源文件的开头。 包声明应该在源文件的第一行，每个源文件只能有一个包声明，这个文件中的每个类型都应用于它。 如果一个源文件中没有使用包声明，那么其中的类，函数，枚举，注释等将被放在一个无名的包（unnamed package）中。 例子 让我们来看一个例子，这个例子创建了一个叫做animals的包。通常使用小写的字母来命名避免与类、接口名字的冲突。 在 animals 包中加入一个接口（interface）： 1234567/* 文件名: Animal.java */package animals; interface Animal { public void eat(); public void travel();} 接下来，在同一个包中加入该接口的实现： 1234567891011121314151617181920212223package animals; /* 文件名 : MammalInt.java */public class MammalInt implements Animal{ public void eat(){ System.out.println(\"Mammal eats\"); } public void travel(){ System.out.println(\"Mammal travels\"); } public int noOfLegs(){ return 0; } public static void main(String args[]){ MammalInt m = new MammalInt(); m.eat(); m.travel(); }} import 关键字 为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。使用 “import” 语句可完成此功能。 在 java 源文件中 import 语句应位于 package 语句之后，所有类的定义之前，可以没有，也可以有多条，其语法格式为： 1import package1[.package2…].(classname|*); 如果在一个包中，一个类想要使用本包中的另一个类，那么该包名可以省略。","link":"/2020/02/18/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0/"},{"title":"java反射机制","text":"java反射机制","link":"/2020/03/02/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"},{"title":"linux学习笔记","text":"linux学习笔记 1 shell家族shell：命令解释器，根据输入的命令执行相应命令。 察看当前系统下有哪些shell： 1cat /etc/shells 察看当前系统正在使用的shell。 1echo $SHELL 常见shell： 123456/bin/sh (已经被 /bin/bash 所取代)/bin/bash (就是 Linux 默认的 shell)/bin/ksh (Kornshell 由 AT&amp;T Bell lab. 发展出来的，兼容于 bash)/bin/tcsh (整合 C Shell ，提供更多的功能)/bin/csh (已经被 /bin/tcsh 所取代)/bin/zsh (基于 ksh 发展出来的，功能更强大的 shell) 1.2 bashbash 是一个为GNU计划编写的Unix shell。它的名字是一系列缩写：Bourne-Again SHell — 这是关于Bourne shell（sh）的一个双关语（Bourne again / born again）bash 是 许 多 Linux 平 台 的 内 定 Shell， 事 实 上， 还 有 许 多 传 统 UNIX 上 用 的 Shell， 像 tcsh、csh、ash、bsh、ksh等等，Shell Script大致都类同，当您学会一种Shell以后，其 它的Shell会很快就上手，大多数的时候，一个Shell Script通常可以在很多种Shell上使用。 bash是大多数Linux系统以及Mac OS X v10.4默认的shell，它能运行于大多数Unix风格 的操作系统之上，甚至被移植到了Microsoft Windows上的Cygwin系统中，以实现windows的POSIX虚拟接口。此外，它也被DJGPP项目移植到了MS-DOS上。 1.3 命令和路径补齐在bash下敲命令时，Tab键可以补全已经敲了一部分的文件名和目录名。如果是Ubuntu 系统，系统默认启用了bash completion，还可以补全命令的某些参数、Makefile目标等 等。如果是Debian系统，可以用以下命令启用bash completion： 1$ source /etc/bash_completion 建议将这一行加入∼/.bashrc启动脚本中。比如使用sudo后面接命令，如果没有bash completion则只有sudo可以补全，后面的命令不能补全。如果启用了bash completion，则 后面的命令，包括命令的某些参数（比如aptitude命令的install）都可以补全了。 比如在主目录下要列出桌面目录的内容，输入（不回车） 1$ ls De 然后敲Tab键，如果以De开头的文件或文件夹只有Desktop一个，就自动补全为 1$ ls Desktop 否则，再敲一次Tab键，将会把所有以De开头的文件或文件夹列在下面供你选择(在这里 我们手动创建另外一个以De开头的文件) 123$ touch Death$ ls DeDeath Desktop/ 你可以再补敲一个s再Tab，这次Desktop就会补全到命令后面了。有 的 人 是 从 DOS 时 代 过 来 的， 留 下 一 个 很 不 好 的 习 惯 就 是 在 找 一 个 文 件 时 反 复 地cd、ls、cd、ls等找到了要找的文件时再想回到先前的目录，已经不记得先前是 从哪个目录转到这里来的了。 我们从上面可以看出，Tab补全本身就具备了ls的功能，上面的Tab补全相当于ls -Fd De*命令。所以我们完全不必反复地cd到别的目录然后ls去找文件，多按几次Tab就可以一条 命令完成了，这样的好处是我们的当前目录不用变，不需要找完了文件再cd回来，同时省去 了大量的按键次数。更重要的是，自动补全同时兼具了检查拼写错误的功能，如果前面几个 字母拼写错了，就补全不出东西来，用户就知道拼写错了，如果前面几个字母没有拼写错， 那么由系统补全出来的文件名肯定也不会有拼写错误，避免了用户在敲很长的文件名时易犯 的拼写错误。 1.4 历史记录1history 历史记录是另外一个非常方便的功能。按上下移动光标键（或者Ctrl-p、Ctrl-n）可以 一条一条浏览以前输过的命令。如果有需要重复输入的命令就不用输第二次了。如果你能记 住以前输过的某条命令中的某个关键字，可以按Ctrl-r，然后输入关键字，随着你每输入一 个字母，bash会做增量式（increasingly）查找，也可以反复按Ctrl-r或Ctrl-s向前向后查 找。如果找到了，按左右移动光标键或Home键(Ctrl-a)或End键(Ctrl-e)将该命令带回提示 符下进一步修改，或者直接按Enter键原封不动地执行该命令。 1.5 主键盘快捷键bash的快捷键和emacs保持一致，用惯其中之一再用另一个程序会很顺手的。请记住一条原则：尽量使用主键盘快捷键而不使用移动光标键和编辑键。因为手不必离开主键盘是效 率最高的，这样在你一生之中所节省的来回移动手的时间绝对可以用星期来计算，是绝对值 得你花十分钟的时间记住这些快捷键的。 功能 快捷键 助记 上 Ctrl-p previous 下 Ctrl-n next 左 Ctrl-b backward 右 Ctrl-f forward Del Ctrl-d delete光标后面的 Home Ctrl-a the first letter End Ctrl-e end Backspace Backspace delete光标前面的 目录和文件2.1 类Unix系统目录结构ubuntu没有盘符这个概念，只有一个根目录/，所有文件都在它下面 123456789101112131415161718/ 根目录bin //系统可执行程序，如命令boot //内核和启动程序，所有和启动相关的文件都保存在这里 grub //引导器相关文件dev //设备文件etc //系统软件的启动和配置文件，系统在启动过程中需要读取的文件都在这个目录。如LILO参数、用 户账户和密码。home //用户的主目录。下面是自己定义的用户名的文件夹lib //系统程序库文件,这个目录里存放着系统最基本的动态链接共享库，类似于Windows下的system32 目录，几乎所有的应用程序都需要用到这些共享库。media //挂载媒体设备，如光驱、U盘等mnt //目录是让用户临时挂载别的文件系统，如挂载Windows下的某个分区，ubuntu默认还是挂载在/media 目录。opt //可选的应用软件包（很少使用）proc //这个目录是系统内存的映射，我们可以直接访问这个目录来获取系统信息。也就是说，这个目录 的内容不在硬盘上而是在内存里。sbin //管理员系统程序 selinuxsrvsys //udev用到的设备目录树，/sys反映你机器当前所接的设备 tmp //临时文件夹usr //这是个最庞大的目录，我们要用到的很多应用程序和文件几乎都存放在这个目录下。] bin // 应用程序game //游戏程序 includelib //应用程序的库文件 lib64local //包含用户程序等 sbin //管理员应用程序 2.2 用户目录位于/home/user，称之为用户工作目录或家目录,表示方式： 12/home/user~ 2.2.1 相对路径和绝对路径绝对路径 从/目录开始描述的路径为绝对路径，如： 1cd /home ls /usr 相对路径 从当前位置开始描述的路径为相对路径，如： 1cd ../../ ls abc/def .和.. 每个目录下都有.和... 表示当前目录.. 表示上一级目录，即父目录 根目录下的.和..都表示当前目录 2.3 ls1ls [OPTION]… [FILE]… ls是英文单词list的简写，其功能为列出目录的内容。这是用户最常用的一个命令，因 为用户需要不时地查看某个目录的内容。该命令类似于DOS下的dir命令。 对于每个目录， 该命令将列出其中的所有子目录与文件。对于每个文件，ls将输出其文件名以及所要求的其 他信息。默认情况下，输出条目按字母顺序排序。当未给出目录名或是文件名时，就显示当 前目录的信息。 主要的OPTION有： 123-a 列出隐藏文件，文件中以“.”开头的均为隐藏文件，如：~/.bashrc-l 列出文件的详细信息-R 连同子目录中的内容一起列出 用ls -l命令显示的信息中，开头是由10个字符构成的字符串，其中第一个字符表示文 件类型，它可以是下述类型之一： 12345- 普通文件 d 目录l 符号链接b 块设备文件c 字符设备文件s socket文件，网络套接字 p 管道 后面的9个字符表示文件的访问权限，分为3组，每组3位。第一组表示文件属主的权 限，第二组表示同组用户的权限，第三组表示其他用户的权限。每一组的三个字符分别表示 对文件的读、写和执行权限。各权限如下所示： 123456r 读w 写x 可执行。对于目录，表示进入权限。s 当文件被执行时，把该文件的UID或GID赋予执行进程的UID（用户ID）或GID（组 ID）。t 设置标志位（sticky bit）。如果是有sticky bit的目录，在该目录下任何用户只要有适当的权限即可创建文 件，但文件只能被超级用户、目录拥有者或文件属主删除。如果是有sticky bit的可执行文件，在该文件执行后， 指向其正文段的指针仍留在内存。这样再次执行它时，系统就能更快地装入该文件。- 没有相应位置的权限。 访问权限后面的数字表示与该文件共享inode的文件总数，即硬链接数(参见下面ln命 令)。 2.4 cdchange dir 改变当前所在路径 12cd ~cd dir1/dir2 cd .. 2.5 which查看指定命令所在路径 1which ls 2.6 pwd查看当前所在路径 1pwd 2.7 mkdir1mkdir [OPTION] DIRECTORY… 创建目录DIRECTORY，可以一次创建多个。OPTION如果是-p，表示可以连同父目录一起 创建。 2.8 rmdir1rmdir [OPTION]… DIRECTORY… 删除空目录，可以一次删除多个。OPTION如果是-p，表示可以连同空的父目录一起删 除。mkdir和rmdir的用法举例： 12345678910$ mkdir a$ mkdir a/b$ ls a b$ rmdir a/b$ ls a$ rmdir a$ mkdir a/bmkdir: cannot create directory `a/b': No such file or directory$ mkdir -p a/b$ rmdir -p a/b 2.9 touch1touch [OPTION]… FILE… 将每个文件的访问及修改时间都更新为目前的时间。 如果文件不存在，则创建一个字节数为0的文件。 2.10 rm删除文件： 1rm file 删除目录： 1rm dir -rf 2.11 mv重命名： 1mv file1 file2 移动文件: 1mv file1 ~/ 2.12 cp拷贝文件： 1cp file1 file2 cp file1 dir/ cp file1 ../ 拷贝目录: 1cp dir1 dir2 -r cp dir1 ~/ -r 2.13 cat查看文件里内容，输出到终端，如果cat时没跟文件名，则读标准输入，遇到\\n后，输 出到标准输出，终端下输入Ctrl-d表示结束 2.14 more1more [OPTION] FILE… 查看文本文件的内容，屏幕显示完一屏就等待用户按下任意键再滚动到下一屏，如果中 途不想继续看下去了，可以按Ctrl+C或q终止显示。 2.15 less1less [OPTION] FILE… 查看文本文件的内容，屏幕显示完一屏就等待用户按键，用户可以向上或向下查看，如 果中途不想继续看下去了，可以按Ctrl+C或q终止显示。 2.16 headhead [OPTION]… FILE… 显示指定文件的前面几行。如果没有指定文件，将从标准输入（键盘）上读取。如果没有指定要显示的行数，则默认显示前10行。如果要显示文件的前5行： 1$ head -5 file1 2.17 tailtail [OPTION]… FILE… 显示文件的最后几行。若没有指定显示的行或字符数，则默认显示末尾10行。如果要显示文件末5行： 1$ tail -5 file1 2.18 ln链接有两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。建立硬链接时，链接文件和被链接文件必须位于同一个文件系统中，并且不能建立 指向目录的硬链接。而对符号链接，则不存在这个问题。默认情况下，ln产生硬链接。如果 给ln命令加上-s选项，则建立符号链接。举例如下，注意ls -l列出文件的硬链接数和字节 数： 硬链接： 12touch helloln hello word_h 软链接： 1ln -s hello word_s 2.19 tree这个命令需要下载安装，ubuntu下 1sudo apt-get install tree 按结构树的形状显示目录和文件 2.20 wc利用 wc 指令我们可以计算文件的 Byte 数、字数、或是列数,若不指定文件名称、或 是所给予的文件名为“-”,则 wc 指令会从标准输入设备读取数据。 1wc -l ./* -c 或–bytes 或–chars 只显示 Bytes 数。-l 或–lines 只显示列数。-w 或–words 只显示字数。 2.21 od1od -tcx file1 -t 指定数据的显示格式，主要的参数有：c ASCII字符或反斜杠序列d[SIZE] 有符号十进制数,每个整数SIZE字节。 f[SIZE] 浮点数,每个整数SIZE字节。o[SIZE] 八进制（系统默认值为02）,每个整数SIZE字节。 u[SIZE] 无符号十进制数,每个整数SIZE字节。x[SIZE] 十六进制数,每个整数SIZE字节。 2.22 du查看某个目录的大小： 以M为单位 1du -hm /home/sihai/test 以B为单位 1du -hb ./* 以K为单位,4k的整数倍 1du -hk ./* 2.23 dfdf查看磁盘使用情况 1df --block-size=GB df --block-size=MB 文件属性和用户用户组3.1 whoami查看当前登陆用户 3.2 chmod 文字设定法 chmod [who] [+|-|=] [mode] 文件名 操作对象who可是下述字母中的任一个或者它们的组合： u 表示“用户（user）”，即文件或目录的所有者。g 表示“同组（group）用户”，即与文件属主有相同组ID的所有用户。 o 表示“其他（others）用户”。a 表示“所有（all）用户”。它是系统默认值。 操作符号可以是： +添加某个权限。 -取消某个权限。 = 赋予给定权限并取消其他所有权限（如果有的话）。 设置mode所表示的权限可用下述字母的任意组合： r 可读。 w 可写。x 可执行。 数字设定法 chmod [mode] 文件名 我们必须首先了解用数字表示的属性的含义： 0表示没有权限，1表示可执行权限，2表示可写权限，4表示可读权限， 然后将其相加。所以数字属性的格式应为3个从0到7的八进制数，其顺序是（u）（g）（o）。 例如，如果想让某个文件的属主有“读/写”二种权限，需要把4（可读）+2（可写）＝ 6（读/写）。 比如设置一个文件允许所有用户可写 1$ chmod a+w file1 设置一个文件允许所有用户可读、可写、不可执行 1$ chmod 666 file1 3.3 chown chown [OPTION]… [OWNER:GROUP] FILE… chown [OPTION]… –reference=RFILE FILE… 更改某个文件或目录的属主和属组。这个命令也很常用。例如root用户把自己的一个文件拷贝给用户A, 为了让用户A能够存取这个文件，root用户应该把这个文件的属主设为A， 否则，用户A无法存取这个文件。 OPTION的主要参数： -R 递归式地改变指定目录及其下的所有子目录和文件的拥有者。 -v 显示chown命令所做的工作。 比如把一个文件改为sihai用户和nogroup用户组所有 1$ sudo chown sihai:nogroup file1 注意： chown需要特权用户才能执行 一个文件的owner和owning group是没有关联的。一个文件属于用户A，也属于用户组 B，并不表示用户A属于用户组B。 3.4 chgrp chgrp [OPTION]… GROUP FILE… chgrp [OPTION]… –reference=RFILE FILE… 该命令改变（指定）指定文件所属的用户组。其中group可以是用户组ID，也可以是/etc/group文件中用户组的组名。 文件名是以空格分开的要改变属组的文件列表，支持通配 符。如果用户不是该文件的属主或超级用户，则不能改变该文件的组。 OPTION的主要参数： -R 递归式地改变指定目录及其下的所有子目录和文件的属组。 查找与检索4.1 find根据文件名查找 find [OPTION] path… [expression] 在目录中搜索文件，path指定目录路径，系统从这里开始沿着目录树向下查找文件。它是一个路径列表，相互用空格分离，如果不写path，那么默认为当前目录。Expression 是 find命令接受的表达式，find命令的所有操作都是针对表达式的。 一条最常用的find命令－－在当前目录及子目录下查找所有以file开头的文件名。 1234567$ find . -name 'file*'$ find / -name 'vimrc'$ find ~ -name '*.c' 4.2 grep根据内容检索 1grep [options] PATTERN [FILE...] 在指定文件中搜索特定的内容，并将含有这些内容的行输出到标准输出。若不指定文件 名，则从标准输入读取。[options]部分包含的主要参数： -c：只输出匹配行的计数。 -I：不区分大小写（只适用于单字符）。 -h：查询多文件时不显示文件名。 -l：查询多文件时只输出包含匹配字符的文件名。 -n：显示匹配行及行号。 -s：不显示不存在或无匹配文本的错误信息。 -v：显示不包含匹配文本的所有行。 -R: 连同子目录中所有文件一起查找。 比如到系统头文件目录下查找所有包含printf的文件 1$ grep 'printf' /usr/include -R 安装卸载软件5.1 apt-get更新源服务器列表 1sudo vi /etc/apt/sources.list 更新完服务器列表后需要更新下源 sudo apt-get update 更新源sudo apt-get install package 安装包sudo apt-get remove package 删除包sudo apt-cache search package 搜索软件包sudo apt-cache show package 获取包的相关信息，如说明、大小、版本等 sudo apt-get install package –reinstall 重新安装包sudo apt-get -f install 修复安装sudo apt-get remove package –purge 删除包，包括配置文件等 sudo apt-get build-dep package 安装相关的编译环境sudo apt-get upgrade 更新已安装的包 sudo apt-get dist-upgrade 升级系统sudo apt-cache depends package 了解使用该包依赖那些包 sudo apt-cache rdepends package 查看该包被哪些包依赖 sudo apt-get source package 下载该包的源代码sudo apt-get clean &amp;&amp; sudo apt-get autoclean 清理无用的包 sudo apt-get check 检查是否有损坏的依赖 5.2 deb包安装 安装deb软件包命令： sudo dpkg -i xxx.deb删除软件包命令： sudo dpkg -r xxx.deb连同配置文件一起删除命令： sudo dpkg -r –purge xxx.deb查看软件包信息命令： sudo dpkg -info xxx.deb查看文件拷贝详情命令： sudo dpkg -L xxx.deb查看系统中已安装软件包信息命令： sudo dpkg -l重新配置软件包命令： sudo dpkg-reconfigure xxx 5.3 原码安装 解压缩源代码包 cd dir ./configure 检测文件是否缺失，创建Makefile,检测编译环境 make 编译源码，生成库和可执行程序 sudo make install 把库和可执行程序，安装到系统路径下 磁盘管理6.1 mount命令格式： mount [-t vfstype] -o options device dir 其中： -t vfstype 指定文件系统的类型，通常不必指定。mount 会自动选择正确的类型。常 用类型有： 光盘或光盘镜像：iso9660 DOS fat16文件系统：msdos Windows 9x fat32文件系统：vfat Windows NT ntfs文件系统：ntfs Mount Windows文件网络共享：smbfs UNIX(LINUX) 文件网络共享：nfs -o options 主要用来描述设备或档案的挂接方式。常用的参数有： loop：用来把一个文件当成硬盘分区挂接上系统ro：采用只读方式挂接设备rw：采用读写方式挂接设备 iocharset：指定访问文件系统所用字符集 device 要挂接(mount)的设备。 dir设备在系统上的挂接点(mount point)。 6.1.1 挂接光盘镜像文件由 于 近 年 来 磁 盘 技 术 的 巨 大 进 步， 新 的 电 脑 系 统 都 配 备 了 大 容 量 的 磁 盘 系 统， 在 Windows下许多人都习惯把软件和资料做成光盘镜像文件通过虚拟 光驱来使用。这样做有 许多好处：一、减轻了光驱的磨损;二、现在硬盘容量巨大存放几十个光盘镜像文件不成问 题，随用随调十分方便;三、硬盘的读取速度要远 远高于光盘的读取速度，CPU占用率大大 降低。其实linux系统下制作和使用光盘镜像比Windows系统更方便，不必借用任何第三方软 件包。 1.从光盘制作光盘镜像文件。将光盘放入光驱，执行下面的命令。 1cp /dev/cdrom /home/sunky/mydisk.iso 或 1dd if=/dev/cdrom of=/home/sunky/mydisk.iso 注：执行上面的任何一条命令都可将当前光驱里的光盘制作成光盘镜像文件/home/ sunky/mydisk.iso 2.文件和目录制作成光盘镜像文件，执行下面的命令。 1mkisofs -r -J -V mydisk -o /home/sunky/mydisk.iso /home/sunky/ mydir 注：这条命令将/home/sunky/mydir目录下所有的目录和文件制作成光盘镜像文件/ home/sunky/mydisk.iso，光盘卷标为：mydisk 3.光盘镜像文件的挂接(mount) 1mkdir /mnt/vcdrom 注：建立一个目录用来作挂接点(mount point) 1mount -o loop -t iso9660 /home/sunky/mydisk.iso /mnt/vcdrom 注：使用/mnt/vcdrom就可以访问盘镜像文件mydisk.iso里的所有文件了。 6.1.2 挂载U盘1.检测存储设备名称 1sudo fdisk -l 2.挂载存储设备sdb1到挂载点/mnt目录 1sudo mount /dev/sdb1 /mnt 3.访问/mnt 4.卸载/mnt 1sudo umount /mnt 6.2 umount卸载命令 1sudo umount 挂在点 6.3 dddd:拷贝 例1：拷贝光碟(注意，你的光碟是标准的 iso9660格式才可以这么做) 1dd if=/dev/cdrom of=cdrom.iso 例2：将文件sfile拷贝到文件 dfile中。 1$ dd if=sfile of=dfile 例3：创建一个100M的空文件 1dd if=/dev/zero of=hello.txt bs=100M count=1 /dev/null，外号叫无底洞，你可以向它输出任何数据，它通吃，并且不会撑着！ /dev/zero,是一个输入设备，你可你用它来初始化文件,从里面读出来的数据都是0。 压缩包管理7.1 tartar [主选项+辅选项] 文件或者目录 tar可以为文件和目录创建档案。 利用tar命令用户可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。使用该命令时，主选项是 必须要有的，辅选项是辅助使用的，可以选用。 主选项包括： c 创建新的档案文件。如果用户想备份一个目录或是一些文件，就要选择这个选项。 r 把要存档的文件追加到档案文件的未尾。 t 列出档案文件的内容，查看已经备份了哪些文件。 u 更新文件。用新增的文件取代原备份文件，如果在备份文件中找不到要更新的文件，则把它追加到备份文件的最 后。 x 从档案文件中释放文件。（常用） 辅选项包括： f 使用档案文件或设备，这个选项通常是必选的。（常用） k 保存已经存在的文件。 m 在还原文件时，把所有文件的修改时间设定为现在。 M 创建多卷的档案文件，以便在几个磁盘中存放。 v 详细报告tar处理的文件信息。如无此选项，tar不报告文件信息。（常用） w 每一步都要求确认。 z 用gzip来压缩/解压缩文件，加上该选项后可以将档案文件进行压缩，但还原时也一定要使用该选项进行解压 缩。（常用） j 用bzip2来压缩/解压缩文件，加上该选项后可以将档案文件进行压缩，但还原时也一定要使用该选项进行解压 缩。（常用） 要将文件备份到一个特定的设备，只需把设备名作为备份文件名。 打包： 1tar cvf dir.tar dir tar xvf dir.tar dir 打gz压缩包： 1tar zcvf dir.tar.gz dir tar zxvf dir.tar.gz 打bz2压缩包: 1tar jcvf dir.tar.bz2 dir tar jxvf dir.tar.bz2 指定目录解压缩： 1tar zxvf dir.tar.gz -C ~/test 7.2 rar打包：把dir压缩成newdir.rar 1rar a -r newdir dir 解包：把newdir.rar解压缩到当前目录 1unrar x newdir.rar ####7.3zip打包： 1zip -r dir.zip dir 解包： 1unzip dir.zip 进程管理8.1 who查看当前在线上的用户情况。所有的选项都是可选的，不使用任何选项时，who命令将 显示以下三项内容： login name：登录用户名； terminal line：使用终端设备； login time：登录到系统的时间。 12345sihai@ubuntu:~/demo$ who -uH名称 线路 时间 空闲 进程号 备注 sihai tty2 2014-08-14 13:31 . 6798sihai tty7 2014-08-14 01:31 旧 2423sihai pts/1 2014-08-14 01:31 12:00 2843 (:0)sihai pts/3 2014-08-14 10:39 . 2843 (:0) ####8.2 ps ps [选项] ps命令用于监控后台进程的工作情况，因为后台进程是不和屏幕键盘这些标准输入/输 出设备进行通信的，所以如果需要检测其情况，便可以使用ps命令了。选项部分如下： -e 显示所有进程。 -f 全格式。 -h 不显示标题。 -l 长格式。 -w 宽输出。 a 显示终端上的所有进程，包括其他用户的进程。 r 只显示正在运行的进程。 x 显示没有控制终端的进程。 这个命令参数有很多，但一般的用户只需掌握一些最常用的命令参数就可以了。 最常用的三个参数是u、a、x， 我们首先以root身份登录系统，查看当前进程状况 1234567891011121314sihai@ubuntu:~$ ps auxUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 1 0.0 0.0 3672 2008 ? Ss 08:46 0:01 /sbin/initsihai@ubuntu:~$ ps ajxPPID PID PGID SID TTY TPGID STAT UID TIME COMMAND 4592 6948 6948 4592 pts/3 6948 R+ 1000 0:00 ps ajxsihai@ubuntu:~$ ps -Lf 2423UID PID PPID LWP C NLWP STIME TTY STAT TIME CMD1000 2423 2282 2423 0 4 08:46 ? Ssl 0:00 gnome-session --session=ubuntu1000 2423 2282 2465 0 4 08:46 ? Ssl 0:00 gnome-session --session=ubuntu1000 2423 2282 2466 0 4 08:46 ? Ssl 0:00 gnome-session --session=ubuntu1000 2423 2282 2468 0 4 08:46 ? Ssl 0:00 gnome-session --session=ubuntu Head标头： USER 用户名UID 用户ID（User ID）PID 进程ID（Process ID）PPID 父进程的进程ID（Parent Process id） SID 会话ID（Session id）%CPU 进程的cpu占用率%MEM 进程的内存占用率VSZ 进程所使用的虚存的大小（Virtual Size）RSS 进程使用的驻留集大小或者是实际内存的大小，Kbytes字节。 TTY 与进程关联的终端（tty）STAT 进程的状态：进程状态使用字符表示的（STAT的状态码）R 运行 Runnable (on run queue) 正在运行或在运行队列中等待。S 睡眠 Sleeping 休眠中, 受阻, 在等待某个条件的形成或接受到信号。 I 空闲 IdleZ 僵死 Zombie（a defunct process) 进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调 用后释放。D 不可中断 Uninterruptible sleep (ususally IO) 收到信号不唤醒和不可运行, 进程必须等待直到有中 断发生。T 停止 Terminate 进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行。 P 等待交换页W 无驻留页 has no resident pages 没有足够的记忆体分页可分配。 X 死掉的进程&lt; 高优先级进程 高优先序的进程N 低优先 级进程 低优先序的进程L 内存锁页 Lock 有记忆体分页分配并缩在记忆体内 s 进程的领导者（在它之下有子进程）；l 多进程的（使用 CLONE_THREAD, 类似 NPTL pthreads） 位于后台的进程组START 进程启动时间和日期 TIME 进程使用的总cpu时间COMMAND 正在执行的命令行命令 NI 优先级(Nice)PRI 进程优先级编号(Priority)WCHAN 进程正在睡眠的内核函数名称；该函数的名称是从/root/system.map文件中获得的。 FLAGS 与进程相关的数字标识 8.4 fg fg [job…] 把指定的后台作业或挂起作业移到前台运行。 参数job是一个或多个进程的PID，或者 是命令名称，或者是作业号（作业号前面要带一个%号）。 通常在shell中输入命令启动进程后，如果该进程需要与用户交互，那么此后用户的键 盘输入都被该进程读取，直到该进程退出后才出现shell提示符$，这种进程为前台进程。 如果在命令行的末尾加上&amp;字符，则shell为这个命令创建一个后台进程，它虽然也可以 输出到屏幕，但是不能读取键盘输入，不管执行命令的进程有没有退出都立刻回到shell提 示符接受下一条命令的输入。如果该进程也需要读取键盘输入，则被挂起等待直到用户用fg 命令把它变成前台进程。如果一个命令需要较长的处理时间并且不需要与用户交互，就适合 把它放在后台执行。 8.5 bg bg [job…] 把被挂起的进程提到后台执行。 其中，job是一个或多个进程的PID、命令名称或者作 业号，在参数前要带%号。 8.6 kill向指定进程发送信号 kill [ -signal | -s signal ] pid … 查看信号编号 1kill -l [ signal ] 给一个进程发信号，或终止一个进程的运行。 kill命令如果不带参数而直接跟pid，就是发给该进程SIGTERM信号，大部分进程收到该 信号就会终止。但是被挂起的进程不能处理信号，所以必须发SIGKILL信号，由系统强制终 止进程。 8.7env查看当前进程环境变量 1$env vim ∼/.bashrc 配置当前用户环境变量 vim /etc/profile 配置系统环境变量,配置时需要有root权限 用户管理9.1 创建用户1sudo useradd -s /bin/bash -g sihai -d /home/sihai -m sihai sudo useradd -s /bin/sh -g group -G adm,root xwp 此命令新建了一个用户xwp，该用户的登录Shell是/bin/sh，他属于group用户组，同时 又属于adm和root用户组，其中group用户组是其主组。 -s 指定新用户登陆时shell类型 -g 指定所属组，该组必须已经存在 -G 指定附属组，该组必须已经存在 -d 用户家目录 -m 用户家目录不存在时，自动创建该目录 9.2 设置用户组1sudo groupadd sihai 9.3 设置密码1sudo passwd sihai 9.4 切换用户 su 用户名 1su sihai 9.5 root用户变成root用户 1sudo su 设置root密码 1passwd 9.6 删除用户 userdel 选项 用户名 常用的选项是-r，他的作用是把用户的主目录一起删除。 例如： 1sudo userdel -r sihai 此命令删除用户sihai在系统文件（主要是/etc/passwd，/etc/shadow，/etc/ group等）中的记录，同时删除用户的主目录。 网络管理10.1 ifconfig1.查看网卡信息 1ifconfig 2.关闭网卡 1sudo ifconfig eth0 down 3.开启网卡eth0 1sudo ifconfig eth0 up 4.给eth0配置临时IP 1sudo ifconfig eth0 IP 10.2ping ping [选项] 主机名/IP地址 查看网络上的主机是否在工作。它向该主机发送ICMP ECHO_REQUEST包。有时我们想从网络上的某台主机上下载文件，可是又不知道那台主机是否开着，就需要使用ping命令查看。 命令中各选项的含义如下： -c 数目 在发送指定数目的包后停止。-d 设定SO_DEBUG的选项。-f 大量且快速地送网络封包给一台机器，看它的回应。-I 秒数 设定间隔几秒送一个网络封包给一台机器，预设值是一秒送一次。-l 次数 在指定次数内，以最快的方式送封包数据到指定机器（只有超级用户可以使用此选项）。-q 不显示任何传送封包的信息，只显示最后的结果。-r 不经由网关而直接送封包到一台机器，通常是查看本机的网络接口是否有问题。-s 字节数 指定发送的数据字节数，预设值是56，加上8字节的ICMP头，一共是64ICMP数据字节。 10.3netstat netstat [选项] 显示网络连接、路由表和网络接口信息，可以让用户得知目前都有哪些网络连接正在运 作。命令中各选项的含义如下： -a 显示所有socket，包括正在监听的。-c 每隔1秒就重新显示一遍，直到用户中断它。-i 显示所有网络接口的信息，格式同“ifconfig -e”。-n 以网络IP地址代替名称，显示出网络连接情形。-r 显示核心路由表，格式同“route -e”。-t 显示TCP协议的连接情况。-u 显示UDP协议的连接情况。-v 显示正在进行的工作。 ####10.4nslookup nslookup name 查询一台机器的IP地址和其对应的域名。它通常需要一台域名服务器来提供域名服务。 如果用户已经设置好域名服务器，就可以用这个命令查看不同主机的IP地址对应的域名。 不带参数使用nslookup命令时，出现提示符“&gt;”，在后面输入要查询的IP地址或域名 并回车即可。如果要退出该命令，输入exit并回车即可。 1234sihai@ubuntu:~$ nslookup&gt; www.sihai.cnServer: 127.0.0.1Address: 127.0.0.1#53 10.5 fingerfinger [-lmsp] user [user@host …] 查询用户的信息，通常会显示系统中某个用 户的用户名、主目录、停滞时间、登录时间、登录shell等信息。如果要查询远程机上的用 户信息，需要在用户名后面接“@主机名”，采用[用户名@主机名]的格式，不过要查询的网 络主机需要运行finger守护进程。 命令中各选项的含义如下： -s 显示用户的注册名、实际姓名、终端名称、写状态、停滞时间、登录时间等信息。-l 除了用-s选项显示的信息外，还显示用户主目录、登录shell、邮件状态等信息，以 及用户主目录下的.plan、.project和.forward文件的内容。-p 除了不显示.plan文件和.project文件以外，与-l选项相同。 1234567sihai@ubuntu:~$ finger sihaiLogin: sihai Name: sihaiDirectory: /home/sihai Shell: /bin/bashOn since Mon Sep 8 08:55 (CST) on tty7 14 hours 48 minutes idle On since Mon Sep 8 21:57 (CST) on pts/1 from :011 minutes 18 seconds idleOn since Mon Sep 8 23:12 (CST) on pts/2 from :0 6 seconds idleNo mail. No Plan. 常用服务器构建11.1 ftp11.1.1ftp服务器1.安装vsftpd服务器 1sudo apt-get install vsftpd 2.配置vsftpd.conf文件 1sudo vi /etc/vsftpd.conf 添加下面设置 1234567anonymous_enable=YES anon_root=/home/sihai/ftp no_anon_password=YES write_enable=YES anon_upload_enable=YES anon_mkdir_write_enable=YES anon_umask=0022 3.重启服务器，重新加载/etc/vsftpd.conf配置文件 123456ubuntu12.04下sudo /etc/init.d/vsftpd restartubuntu14.04下sudo /lib/init/upstart-job vsftpd restart 4.进入你的/home/sihai/ftp目录下创建一个空目录，供用户上传 123cd ~/ftpmkdir anonymous chmod 777 anonymous 5.测试上传功能，登陆ftp服务器，进入到anonymous目录 12ftp IPcd anonymous 6.上传命令，可以把你当前目录下的文件上传到ftp服务器的anonymous目录 12put somefile get somefile 11.1.2 ftp客户端Ubuntu 默认已经安装ftp客户端 11.1.3 lftp客户端lftp 也 是 一 种 ftp 客 户 程 序。 它 是 以 文 本 方 式 操 作 的， 但 是 比 起 图 形 界 面 更 为 方 便。lftp几乎具有bash的所有方便功能，Tab 补全，bookmark, queue, 后台下载等可以 得到支持。用法与ftp类似，主要的指令如下： put 上传文件mput 上传多个文件 get 下载文件mget 下载多个文件mirror 下载整个目录及其子目录 mirror –R 上传整个目录及其子目录!command 调用本地shell执行命令command 注意，有的发行版可能缺省没有安装lftp工具，需要用户自己安装。如果是Debian或 Ubuntu系统，则安装lftp软件包。 1sudo apt-get install lftp 11.2 nfs1.安装nfs服务器 1sudo apt-get install nfs-kernel-server 2.设置/etc/exports配置文件 1sudo vi /etc/exports 添加这行配置 1/home/用户名/nfs *(rw,sync,no_root_squash) 3.在用户目录下创建nfs目录 1mkdir /home/用户名/nfs 4.重启服务器，重新加载配置文件 1sudo /etc/init.d/nfs-kernel-server restart 5.在/home/用户名/nfs目录下创建测试文件hello 1cd /home/用户名/nfs touch hello 6.测试服务器，把服务器共享目录nfs挂在到/mnt节点 1sudo mount -t nfs -o nolock -o tcp IP:/home/用户名/nfs /mnt 7.进入/mnt目录可以看到hello文件，表示构建成功 8.卸载网络共享目录 1sudo umount /mnt 11.3ssh1.安装ssh服务器 1sudo apt-get install openssh-server 2.远程登陆 1ssh 用户名@IP 其它命令12.1 终端翻页12Shift-pageup Shift-pagedown 12.2 man看手册(叫做manual或man page)。每一个命令和系统函数都有自己的man page。 12man manman read 查看read命令的man page 1man 2 read 查看read系统函数的man page(在第二个section中，表示为read(2)) man -k read 以read为关键字查找相关的man page 12.3 clear清屏。使光标和提示符回到屏幕第一行。 快捷键：Ctrl-l ####12.4 aliasalias [-p] name=value … 将 value 字 符 串 起 个 别 名 叫 name， 以 后 在 命 令 行 输 入 name，shell 自 动 将 其 解 释 为value，如果不带参数执行本命令，或以参数-p执行，则显示当前定义的别名列表。 12$ aliasalias ls='ls --color=auto' alias rm='rm -i' 12.5 echo echo [-n] 字符串 在显示器上显示一段文字，一般起到一个提示的作用。其中选项n表示输出文字后不换 行；字符串可以加引号，也可以不加引号。用echo命令输出加引号的字符串时，将字符串原 样输出；用echo命令输出不加引号的字符串时，将字符串中的各个单词作为字符串输出，各 字符串之间用一个空格分割。 查看上一个程序退出数值，正常情况程序退出值是0 1echo $? 12.6 date查看当前时间 12.7 umask umask [-p] -S [mode] umask指定用户创建文件时的掩码，其中的mode和chmod的命令中的格式一样。如果不用 mode参数，则显示当前的umask设置。如果用-S参数，则以符号形式显示设置。 12$ umask 0022$ umask -S u=rwx,g=rx,o=rx 比如该用户touch或gedit创建一个文件，则其默认权限为-rw-r-r–，如果该用户创 建一个可执行文件(比如编译生成的程序)，则其默认权限为-rwxr-xr-x。也就是说，由于 umask的设定，创建的文件默认是不具有g的w权限和o的w权限的，除非用chmod更改权限。 12.8 创建终端创建终端标签 1Ctrl + Shift + t 切换标签 1Alt+n（n=1） 新开终端 1Ctrl + Shift + n 关机重启关机重启这些操作都需要有root权限 13.1 poweroff13.2 shutdown shutdown -t 秒数 [-rkhncfF] 时间 [警告讯息] 选项： -t 秒数 : 设定在切换至不同的runlevel之前, 警告和删除二讯号之间的延迟时间(秒).-k : 仅送出警告讯息文字, 但不是真的要 shutdown.-r : shutdown 之後重新开机-h : shutdown 之後关机.-n : 不经过 init , 由 shutdown 指令本身来做关机动作.(不建议你用)-f : 重新开机时, 跳过 fsck 指令, 不检查档案系统.-F : 重新开机时, 强迫做 fsck 检查.-c : 将已经正在 shutdown 的动作取消. 例子: 1234shutdown -r now 立刻重新开机 shutdown -h now 立刻关机shutdown -k now 'Hey! Go away! now....' 发出警告讯息, 但没有真的关机 shutdown -t3 -r now 立刻重新开机, 但在警告和删除processes 之间, 延迟3秒钟. shutdown -h 10:42 'Hey! Go away!' 10:42 分关机shutdown -r 10 'Hey! Go away!' 10 分钟後关机shutdown -c 将刚才下的 shutdown 指令取消,必须切换至其它tty, 登入之後, 才能下此一指令. shutdown now 切换至单人操作模式(不加任何选项时) 注意事项:时间参数务必要加: 不是用 now, 便是用 hh:mm 或 mm now 其实就是 0 的意思. 13.3 reboot13.4 查看内核版本信息1uname -a 13.5 查看发行版信息1lsb_release -a 13.6 查看空闲内存1free -m vim16.1 vi简介vi是“Visual interface”的简称，它在Linux上的地位就仿佛Edit程序在DOS上一样。 它可以执行输出、删除、查找、替换、块操作等众多文本操作，而且用户可以根据自己的需 要对其进行定制。Vi不是一个排版程序，它不象Word或WPS那样可以对字体、格式、段落等 其他属性进行编排，它只是一个文本编辑程序。 vi没有菜单，只有命令，且命令繁多。 Vi有三种基本工作模式： 命令模式 文本输入模式 末行模式。 16.1.1 命令行模式任何时候，不管用户处于何种模式，只要按一下ESC键，即可使Vi进入命令模式；我们 在shell环境(提示符为$)下输入启动Vi命令，进入编辑器时，也是处于该模式下。在该模式 下，用户可以输入各种合法的Vi命令，用于管理自己的文档。此时从键盘上输入的任何字符 都被当做编辑命令来解释，若输入的字符是合法的Vi命令，则Vi在接受用户命令之后完成相 应的动作。但需注意的是，所输入的命令并不在屏幕上显示出来。若输入的字符不是Vi的合 法命令，Vi会响铃报警。 16.1.2 文本输入模式在命令模式下输入插入命令i、附加命令a 、打开命令o、修改命令c、取代命令r或替换 命令s都可以进入文本输入模式。在该模式下，用户输入的任何字符都被Vi当做文件内容保 存起来，并将其显示在屏幕上。在文本输入过程中，若想回到命令模式下，按键ESC即可。 16.1.3 末行模式末行模式也称ex转义模式。在命令模式下，用户按“:”键即可进入末行模式下，此时 Vi会在显示窗口的最后一行(通常也是屏幕的最后一行)显示一个“:”作为末行模式的提示 符，等待用户输入命令。多数文件管理命令都是在此模式下执行的(如把编辑缓冲区的内容 写到文件中等)。末行命令执行完后，Vi自动回到命令模式。例如： 1:sp newfile 则分出一个窗口编辑newfile文件。如果要从命令模式转换到编辑模式，可以键入命令a 或者i；如果需要从文本模式返回，则按Esc键即可。在命令模式下输入“:”即可切换到末 行模式，然后输入命令。 16.2 vim基础操作进入插入模式: i: 插入光标前一个字符 I: 插入行首a: 插入光标后一个字符 A: 插入行未o: 向下新开一行,插入行首 O: 向上新开一行,插入行首 进入命令模式: ESC:从插入模式或末行模式进入命令模式 移动光标: h: 左移 j: 下移 k: 上移 l: 右移M: 光标移动到中间行L: 光标移动到屏幕最后一行行首 G: 移动到指定行,行号 -Gw: 向后一次移动一个字 b: 向前一次移动一个字{: 按段移动,上移}: 按段移动,下移 Ctr-d: 向下翻半屏 Ctr-u: 向上翻半屏 Ctr-f: 向下翻一屏 Ctr-b: 向上翻一屏gg: 光标移动文件开头 G: 光标移动到文件末尾 删除命令: x: 删除光标后一个字符,相当于 DelX: 删除光标前一个字符,相当于 Backspacedd: 删除光标所在行,n dd 删除指定的行数 D: 删除光标后本行所有内容,包含光标所在字符 d0: 删除光标前本行所有内容,不包含光标所在字符dw: 删除光标开始位置的字,包含光标所在字符 撤销命令: u: 一步一步撤销U: 一次性撤销当前行所作的所有操作 Ctr-r: 反撤销 重复命令: .: 重复上一次操作的命令 文本行移动: : 文本行右移 &lt;&lt;: 文本行左移 复制粘贴: yy: 复制当前行,n yy 复制 n 行p: 在光标所在位置向下新开辟一行,粘贴 可视模式: v: 按字符移动,选中文本V: 按行移动,选中文本可视模式可以配合 d, y, &gt;&gt;, &lt;&lt; 实现对文本块的删除,复制,左右移动 替换操作: r: 替换当前字符R: 替换当前行光标后的字符 查找命令: /: str查找n: 下一个N：上一个 替换命令： 把abc全部替换成123 1:%s/abc/123/g 代码排版: gg=G: 代码自动缩进排版 16.3 vim分屏操作分屏操作: sp: 上下分屏,后可跟文件名vsp: 左右分屏,后可跟文件名Ctr+w+w: 在多个窗口切换 启动分屏 1.使用大写O参数进行垂直分屏 1$ vim -On file1 file2 ... 2.使用小写o参数进行水平分屏 1$ vim -on file1 file2 ... 注: n是数字，表示分屏的数量,n要大于等于文件个数 关闭分屏 1.关闭当前窗口 1ctrl+w c 2.关闭当前窗口，如果只剩最后一个，则退出vim 1ctrl+w q 编辑中分屏 1.上下分割当前打开的文件 1ctrl+w s 2.上下分割，并打开一个新的文件 1:sp filename 3.左右分割当前打开的文件 1ctrl+w v 4.左右分割，并打开一个新的文件 1:vsp filename 分屏编辑中光标的移动 vi中的光标键是h,j,k,l,要在各个屏之间切换，只需要先按一下ctrl+w 1.把光标移动到上边的屏 1ctrl+w k 2.把光标移动到下边的屏 1ctrl+w j 3.把光标移动到右边的屏 1ctrl+w l 4.把光标移动到左边的屏 1ctrl+w h 5.把光标移动到下一个的屏 1ctrl+w w 移动分屏 1.向上移动 1ctrl+w K 2.向下移动 1ctrl+w J 3.向右移动 1ctrl+w L 4.向左移动 1ctrl+w H 屏幕尺寸 1.增加高度 1ctrl+w + 2.减少高度 1ctrl+w - 3.让所有屏的高度一致 1ctrl+w = 4.左加宽度 1ctrl+w &gt; 5.右加宽度 1ctrl+w &lt; 6.右增加n宽 (如：n=30) 1ctrl+w n &lt;","link":"/2020/02/17/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"专业英语学习笔记","text":"integrated 集成 serial串行 parallerl 并行 faculty全体成员","link":"/2020/03/06/%E4%B8%93%E4%B8%9A%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"markdown学习笔记","text":"markdown笔记 - 常用快捷键加粗 Ctrl + B斜体 Ctrl + I引用 Ctrl + Q插入链接 Ctrl + L插入代码 Ctrl + K插入图片 Ctrl + G提升标题 Ctrl + H有序列表 Ctrl + O无序列表 Ctrl + U横线 Ctrl + R撤销 Ctrl + Z重做 Ctrl + Y Markdown标题：这是一级标题===========这是二级标题 一级标题二级标题三级标题四级标题五级标题六级标题字体斜体文本斜体文本粗体文本粗体文本粗斜体文本粗斜体文本 分隔线 删除线 下划线 [^脚注]：markdown中的说明 markdown列表无序列表 第一项 第二项 第三项 第一项 第二项 第三项 第一项 第二项 第三项 有序列表1.第一项： -嵌套 -嵌套2.第二项：3.第三项： markdown区块 区块引用 我的笔记 加油 markdown代码一个函数或者片段的代码 代码区块使用 4 个空格或者一个制表符（Tab 键）12345public class HelloWorld{ pulic static void main(String[] args){ System.out.println(\"Hello World!\"); }} markdown连接链接名称 或者 https://music.163.com/#/my/m/music/playlist?id=2061638738 链接也可以用变量来代替，文档末尾附带变量地址：这个链接用 1 作为网址变量 Google 然后在文档的结尾为变量赋值（网址） markdown图片 markdown表格 表头 表头 单元格 单元格 单元格 单元格 markdown高级技巧不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。 目前支持的 HTML 元素有： 等使用 Ctrl+Alt+Del 重启电脑 转义文本加粗** 正常显示星号 ** 123456789st=&gt;start: 开始框op=&gt;operation: 处理框cond=&gt;condition: 判断框(是或否?)sub1=&gt;subroutine: 子流程io=&gt;inputoutput: 输入输出框e=&gt;end: 结束框st(right)-&gt;op(right)-&gt;condcond(yes)-&gt;io(bottom)-&gt;econd(no)-&gt;sub1(right)-&gt;op","link":"/2020/02/15/markdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"编译技术学习笔记","text":"题1，编译器和解释器是两种高级语言处理程序，与编译器相比 解释器参与运行控制，程序执行的速度慢 2，编译程序是一种翻译程序。","link":"/2020/03/04/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"java基础学习笔记","text":"java笔记[TOC] java简介 Java是由Sun Microsystems公司于1995年5月推出的Java面向对象程序设计语言和Java平台的总称。由James Gosling和同事们共同研发，并在1995年正式推出。 java基础语法 对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 类：类是一个模板，它描述一类对象的行为和状态。 方法：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。 实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。 *大小写敏感：Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。 *类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 。 *方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。 *源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 .java。（如果文件名和类名不相同则会导致编译错误）。 *主方法入口：所有的 Java 程序由 public static void main(String []args) 方法开始执行。 *Java修饰符 像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符： 访问控制修饰符 : default, public , protected, private 非访问控制修饰符 : final, abstract, static, synchronized *Java 标识符 Java 所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。 *接口 在 Java 中，接口可理解为对象间相互通信的协议。接口在继承中扮演着很重要的角色。接口只定义派生要用到的方法，但是方法的具体实现完全取决于派生类。 java对象和类 多态 继承 封装 抽象 类：类是一个模板，它描述一类对象的行为和状态。 对象：对象是类的一个实例 实例 方法 重载 *变量 局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。 成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。 类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。 *创建对象 声明：声明一个对象，包括对象名称和对象类型。 实例化：使用关键字new来创建一个对象。 初始化：使用new创建对象时，会调用构造方法初始化对象。 12345678910public class Puppy{ public Puppy(String name){ //这个构造器仅有一个参数：name System.out.println(\"小狗的名字是 : \" + name ); } public static void main(String[] args){ // 下面的语句将创建一个Puppy对象 Puppy myPuppy = new Puppy( \"tommy\" ); }} *访问实例变量和方法 123456789101112131415161718192021222324252627public class Puppy{ int puppyAge; public Puppy(String name){ // 这个构造器仅有一个参数：name System.out.println(\"小狗的名字是 : \" + name ); } public void setAge( int age ){ puppyAge = age; } public int getAge( ){ System.out.println(\"小狗的年龄为 : \" + puppyAge ); return puppyAge; } public static void main(String[] args){ /* 创建对象 */ Puppy myPuppy = new Puppy( \"tommy\" ); /* 通过方法来设定age */ myPuppy.setAge( 2 ); /* 调用另一个方法获取age */ myPuppy.getAge( ); /*你也可以像下面这样访问成员变量 */ System.out.println(\"变量值 : \" + myPuppy.puppyAge ); }} *源文件声明规则 一个源文件中只能有一个public类 一个源文件可以有多个非pubic类 源文件的名称应该和public类的类名保持一致 java包主要用来对类和接口进行分类 import语句import java.io.*; java基础数据类型*java的两大数据类型 *内置数据类型 ​ 1234567891011121314151617 六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。byte 1,short 2, int 4(一般整型变量默认为 int 类型), long 8 ,float 4, double 8, boolean true&amp;flase, char 2 ,默认值`u0000 ` *引用数据类型 - 在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。 - 对象、数组都是引用数据类型。 - 所有引用类型的默认值都是null。 - 一个引用变量可以用来引用任何与之兼容的类型。 123456 ***java常量**用final关键字来修饰常量，声明方式和变量类似； final double PI = 3.1415927; 12***自动类型转换** 整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。 转换从低级到高级。低 ————————————&gt; 高 byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double 、 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例(int)23.7==23; 12***强制类型转换** 格式：(type)value 隐含强制类型转换：整数的默认类型是int，浮点数不存在这种情况，因为在定义float类型时必须在数字后面加上F或者f. 123456## java变量类型Java语言支持的变量类型有：- 类变量(静态变量)：独立于方法之外的变量，用 static 修饰。 类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。 静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。 静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。 静态变量在第一次被访问时创建，在程序结束时销毁。 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。 默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。 静态变量可以通过：ClassName.VariableName的方式访问。 类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。 1234 - 实例变量：独立于方法之外的变量，不过没有 static 修饰。 实例变量声明在一个类中，但在方法、构造方法和语句块之外； 当一个对象被实例化之后，每个实例变量的值就跟着确定； 实例变量在对象创建的时候创建，在对象被销毁的时候销毁； 实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息； 实例变量可以声明在使用前或者使用后； 访问修饰符可以修饰实例变量； 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见； 实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定； 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。 1234567891011121314151617 - 局部变量：类的方法中的变量。访问修饰符不能用于局部变量；局部变量是在栈上分配的。局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。 ```java public class Variable{ static int allClicks=0; // 类变量 String str=&quot;hello world&quot;; // 实例变量 public void method(){ int i =0; // 局部变量 } } java修饰符:basketball_man:访问修饰符 public&gt;protected&gt;default&gt;private 修饰符 当前类 同一包内 子孙类(同一包) 子孙类(不同包) 其他包 public Y Y Y Y Y protected Y Y Y Y/N（说明） N default Y Y Y N N private Y N N N N default:默认,在一个包内可见；使用对象：类，接口，变量，方法。 private:在同一类内可见，使用对象：变量，方法。注意：不能修饰类（外部类) public:对所有的类可见。使用对象：类，接口，变量，方法 protected:对同一包内的类和所有子类可见。使用对象变量和方法。注意：不能修饰类（外部类）。 接口里的变量都隐式声明为 public static final,而接口里的方法默认情况下访问权限为 public。 :basketball_man:非访问修饰符 static修饰符，用来修饰类方法和类变量。静态变量也被称为类变量。静态方法不能使用类的非静态变量。 final修饰符，用来修饰类，方法和变量，final修饰的类不能够被继承。修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。 abstract修饰符，用来创建抽象类和抽象方法。抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。 synchronized和volatile修饰符，主要用于线程的编程。volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。 transient 修饰符。序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。 123实例public transient int limit = 55; // 不会持久化 public int b; // 持久化 java运算符 算术运算符 +-*/%++– 关系运算符 == ！= &lt; &gt; &gt;= &lt;= 位运算符 &amp; | ^ ~ &lt;&lt; &gt;&gt; &gt;&gt;&gt;按位右移补零操作符。eg: A&gt;&gt;&gt;2得到15即0000 1111 逻辑运算符 &amp;&amp; || ! 赋值运算符 = += -= *= /= (%)= &lt;&lt;= &gt;&gt;= &amp;= ^= |= 条件运算符 三元运算符 ？ ： instanceof运算符：该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。 java运算符优先级 类别 操作符 关联性 后缀 () [] . (点操作符) 左到右 一元 + + - ！〜 从右到左 乘性 * /％ 左到右 加性 + - 左到右 移位 &gt;&gt; &gt;&gt;&gt; &lt;&lt; 左到右 关系 &gt;&gt; = &lt;&lt; = 左到右 相等 == != 左到右 按位与 ＆ 左到右 按位异或 ^ 左到右 按位或 | 左到右 逻辑与 &amp;&amp; 左到右 逻辑或 | | 左到右 条件 ？： 从右到左 赋值 = + = - = * = / =％= &gt;&gt; = &lt;&lt; =＆= ^ = | = 从右到左 逗号 ， 左到右 java循环结构-for,while及do…while123for(初始化; 布尔表达式; 更新) { //代码语句} 123 //代码语句}while(布尔表达式); 123while( 布尔表达式 ) { //循环内容} :basketball_man:java增强for循环 java5引入了一种主要用于数组的增强型for循环。 1234567891011121314for(声明语句：表达式){ //代码句子}声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。表达式：表达式是要访问的数组名，或者是返回值为数组的方法。例子： int [] numbers = {10, 20, 30, 40, 50}; for(int x : numbers ){ System.out.print( x ); System.out.print(\",\"); } break关键字 break 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。break 跳出最里层的循环，并且继续执行该循环下面的语句。 continue 关键字 continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。在 for 循环中，continue 语句使程序立即跳转到更新语句。在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。 java条件语句-if…else1234567if…else 的用法如下：if(布尔表达式){ //如果布尔表达式的值为true}else{ //如果布尔表达式的值为false} 123456789if(布尔表达式 1){ //如果布尔表达式 1的值为true执行代码}else if(布尔表达式 2){ //如果布尔表达式 2的值为true执行代码}else if(布尔表达式 3){ //如果布尔表达式 3的值为true执行代码}else { //如果以上布尔表达式都不为true执行代码} 123456if(布尔表达式 1){ ////如果布尔表达式 1的值为true执行代码 if(布尔表达式 2){ ////如果布尔表达式 2的值为true执行代码 }} java switch case 语句switch case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。 123456789101112switch(expression){ case value : //语句 break; //可选 case value : //语句 break; //可选 //你可以有任意数量的case语句 default : //可选 //语句}switch 语句可以包含一个 default 分支，该分支一般是 switch 语句的最后一个分支（可以在任何位置，但建议在最后一个）。default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句。 java Number &amp;Math类 所有的包装类（Integer、Long、Byte、Double、Float、Short）都是抽象类 Number 的子类。这种由编译器特别支持的包装称为装箱，所以当内置数据类型被当作对象使用的时候，编译器会把内置类型装箱为包装类。 Java Math 类 Java 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。 Number &amp; Math 类方法下面的表中列出的是 Number &amp; Math 类常用的一些方法： 序号 方法与描述 1 xxxValue() 将 Number 对象转换为xxx数据类型的值并返回。 2 compareTo() 将number对象与参数比较。 3 equals() 判断number对象是否与参数相等。 4 valueOf() 返回一个 Number 对象指定的内置数据类型 5 toString() 以字符串形式返回值。 6 parseInt() 将字符串解析为int类型。 7 abs() 返回参数的绝对值。 8 ceil() 返回大于等于( &gt;= )给定参数的的最小整数，类型为双精度浮点型。 9 floor() 返回小于等于（&lt;=）给定参数的最大整数 。 10 rint() 返回与参数最接近的整数。返回类型为double。 11 round() 它表示四舍五入，算法为 Math.floor(x+0.5)，即将原来的数字加上 0.5 后再向下取整，所以，Math.round(11.5) 的结果为12，Math.round(-11.5) 的结果为-11。 12 min() 返回两个参数中的最小值。 13 max() 返回两个参数中的最大值。 14 exp() 返回自然数底数e的参数次方。 15 log() 返回参数的自然数底数的对数值。 16 pow() 返回第一个参数的第二个参数次方。 17 sqrt() 求参数的算术平方根。 18 sin() 求指定double类型参数的正弦值。 19 cos() 求指定double类型参数的余弦值。 20 tan() 求指定double类型参数的正切值。 21 asin() 求指定double类型参数的反正弦值。 22 acos() 求指定double类型参数的反余弦值。 23 atan() 求指定double类型参数的反正切值。 24 atan2() 将笛卡尔坐标转换为极坐标，并返回极坐标的角度值。 25 toDegrees() 将参数转化为角度。 26 toRadians() 将角度转换为弧度。 27 random() 返回一个随机数。 java Character类Character 类用于对单个字符进行操作。Character 类在对象中包装一个基本类型 char 的值。 在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情况。为了解决这个问题，Java语言为内置数据类型char提供了包装类Character类。 在某些情况下，Java编译器会自动创建一个Character对象。 例如，将一个char类型的参数传递给需要一个Character类型参数的方法时，那么编译器会自动地将char类型参数转换为Character对象。 这种特征称为装箱，反过来称为拆箱。 1234567实例// 原始字符 'a' 装箱到 Character 对象 ch 中Character ch = 'a'; // 原始字符 'x' 用 test 方法装箱// 返回拆箱的值到 'c'char c = test('x'); Character 方法 下面是Character类的方法： 序号 方法与描述 1 isLetter() 是否是一个字母 2 isDigit() 是否是一个数字字符 3 isWhitespace() 是否是一个空白字符 4 isUpperCase() 是否是大写字母 5 isLowerCase() 是否是小写字母 6 toUpperCase() 指定字母的大写形式 7 toLowerCase() 指定字母的小写形式 8 toString() 返回字符的字符串形式，字符串的长度仅为1 java String 类字符串广泛应用在java编程中，在java中字符串属于对象，java提供了String类来创建和操作字符串。String 类有 11 种构造方法，这些方法提供不同的参数来初始化字符串，比如提供一个字符数组参数。 注意:String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了（详看笔记部分解析）。如果需要对字符串做很多修改，那么应该选择使用 StringBuffer &amp; StringBuilder 类。 :basketball_man:字符串长度：String 类的一个访问器方法是length（）方法，它返回字符串对象包含的字符数。 :basketball_man:连接字符串： string1.concat(string2); “hello”+”world”; :basketball_man:创建格式化字符串： 12345678910111213141516我们知道输出格式化数字可以使用 printf() 和 format() 方法。String 类使用静态方法 format() 返回一个String 对象而不是 PrintStream 对象。String 类的静态方法 format() 能用来创建可复用的格式化字符串，而不仅仅是用于一次打印输出。 System.out.printf(\"浮点型变量的值为 \" + \"%f, 整型变量的值为 \" + \" %d, 字符串变量的值为 \" + \"is %s\", floatVar, intVar, stringVar);或 String fs; fs = String.format(\"浮点型变量的值为 \" + \"%f, 整型变量的值为 \" + \" %d, 字符串变量的值为 \" + \" %s\", floatVar, intVar, stringVar); :basketball_man:String 方法 下面是 String 类支持的方法，更多详细，参看 Java String API 文档: SN(序号) 方法描述 1 char charAt(int index) 返回指定索引处的 char 值。 2 int compareTo(Object o) 把这个字符串和另一个对象比较。 3 int compareTo(String anotherString) 按字典顺序比较两个字符串。 4 int compareToIgnoreCase(String str) 按字典顺序比较两个字符串，不考虑大小写。 5 String concat(String str) 将指定字符串连接到此字符串的结尾。 6 boolean contentEquals(StringBuffer sb) 当且仅当字符串与指定的StringBuffer有相同顺序的字符时候返回真。 7 static String copyValueOf(char[] data) 返回指定数组中表示该字符序列的 String。 8 static String copyValueOf(char[] data, int offset, int count) 返回指定数组中表示该字符序列的 String。 9 boolean endsWith(String suffix) 测试此字符串是否以指定的后缀结束。 10 boolean equals(Object anObject) 将此字符串与指定的对象比较。 11 boolean equalsIgnoreCase(String anotherString) 将此 String 与另一个 String 比较，不考虑大小写。 12 byte[] getBytes() 使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 13 byte[] getBytes(String charsetName) 使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 14 void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 将字符从此字符串复制到目标字符数组。 15 int hashCode() 返回此字符串的哈希码。 16 int indexOf(int ch) 返回指定字符在此字符串中第一次出现处的索引。 17 int indexOf(int ch, int fromIndex) 返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。 18 int indexOf(String str) 返回指定子字符串在此字符串中第一次出现处的索引。 19 int indexOf(String str, int fromIndex) 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。 20 String intern() 返回字符串对象的规范化表示形式。 21 int lastIndexOf(int ch) 返回指定字符在此字符串中最后一次出现处的索引。 22 int lastIndexOf(int ch, int fromIndex) 返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。 23 int lastIndexOf(String str) 返回指定子字符串在此字符串中最右边出现处的索引。 24 int lastIndexOf(String str, int fromIndex) 返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。 25 int length() 返回此字符串的长度。 26 boolean matches(String regex) 告知此字符串是否匹配给定的正则表达式。 27 boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len) 测试两个字符串区域是否相等。 28 boolean regionMatches(int toffset, String other, int ooffset, int len) 测试两个字符串区域是否相等。 29 String replace(char oldChar, char newChar) 返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 30 String replaceAll(String regex, String replacement) 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。 31 String replaceFirst(String regex, String replacement) 使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。 32 String[] split(String regex) 根据给定正则表达式的匹配拆分此字符串。 33 String[] split(String regex, int limit) 根据匹配给定的正则表达式来拆分此字符串。 34 boolean startsWith(String prefix) 测试此字符串是否以指定的前缀开始。 35 boolean startsWith(String prefix, int toffset) 测试此字符串从指定索引开始的子字符串是否以指定前缀开始。 36 CharSequence subSequence(int beginIndex, int endIndex) 返回一个新的字符序列，它是此序列的一个子序列。 37 String substring(int beginIndex) 返回一个新的字符串，它是此字符串的一个子字符串。 38 String substring(int beginIndex, int endIndex) 返回一个新字符串，它是此字符串的一个子字符串。 39 char[] toCharArray() 将此字符串转换为一个新的字符数组。 40 String toLowerCase() 使用默认语言环境的规则将此 String 中的所有字符都转换为小写。 41 String toLowerCase(Locale locale) 使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。 42 String toString() 返回此对象本身（它已经是一个字符串！）。 43 String toUpperCase() 使用默认语言环境的规则将此 String 中的所有字符都转换为大写。 44 String toUpperCase(Locale locale) 使用给定 Locale 的规则将此 String 中的所有字符都转换为大写。 45 String trim() 返回字符串的副本，忽略前导空白和尾部空白。 46 static String valueOf(primitive data type x) 返回给定data type类型x参数的字符串表示形式。 java StringBuffer和StringBuilder类当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。 和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。 StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。 由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。 StringBuffer 方法以下是 StringBuffer 类支持的主要方法： 序号 方法描述 1 public StringBuffer append(String s) 将指定的字符串追加到此字符序列。 2 public StringBuffer reverse() 将此字符序列用其反转形式取代。 3 public delete(int start, int end) 移除此序列的子字符串中的字符。 4 public insert(int offset, int i) 将 int 参数的字符串表示形式插入此序列中。 5 replace(int start, int end, String str) 使用给定 String 中的字符替换此序列的子字符串中的字符。 下面的列表里的方法和 String 类的方法类似： 序号 方法描述 1 int capacity() 返回当前容量。 2 char charAt(int index) 返回此序列中指定索引处的 char 值。 3 void ensureCapacity(int minimumCapacity) 确保容量至少等于指定的最小值。 4 void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 将字符从此序列复制到目标字符数组 dst。 5 int indexOf(String str) 返回第一次出现的指定子字符串在该字符串中的索引。 6 int indexOf(String str, int fromIndex) 从指定的索引处开始，返回第一次出现的指定子字符串在该字符串中的索引。 7 int lastIndexOf(String str) 返回最右边出现的指定子字符串在此字符串中的索引。 8 int lastIndexOf(String str, int fromIndex) 返回 String 对象中子字符串最后出现的位置。 9 int length() 返回长度（字符数）。 10 void setCharAt(int index, char ch) 将给定索引处的字符设置为 ch。 11 void setLength(int newLength) 设置字符序列的长度。 12 CharSequence subSequence(int start, int end) 返回一个新的字符序列，该字符序列是此序列的子序列。 13 String substring(int start) 返回一个新的 String，它包含此字符序列当前所包含的字符子序列。 14 String substring(int start, int end) 返回一个新的 String，它包含此序列当前所包含的字符子序列。 15 String toString() 返回此序列中数据的字符串表示形式。 java数组Java 语言中提供的数组是用来存储固定大小的同类型元素 :basketball_man:声明数组变量 首先必须声明数组变量，才能在程序中使用数组。下面是声明数组变量的语法： 123dataType[] arrayRefVar; // 首选的方法 或 dataType arrayRefVar[]; // 效果相同，但不是首选方法 :basketball_man:创建数组 Java语言使用new操作符来创建数组，语法如下： 1arrayRefVar = new dataType[arraySize]; 上面的语法语句做了两件事： 使用 dataType[arraySize] 创建了一个数组。 2.把新创建的数组的引用赋值给变量 arrayRefVar。 数组变量的声明，和创建数组可以用一条语句完成，如下所示： 1dataType[] arrayRefVar = new dataType[arraySize]; 另外，你还可以使用如下的方式创建数组。 1dataType[] arrayRefVar = {value0, value1, ..., valuek}; 数组的元素是通过索引访问的。数组索引从 0 开始，所以索引值从 0 到 arrayRefVar.length-1。 :basketball_man:处理数组 数组的元素类型和数组的大小都是确定的，所以当处理数组元素时候，我们通常使用基本循环或者 For-Each 循环。 1234567891011121314151617181920212223基本循环：public class TestArray { public static void main(String[] args) { double[] myList = {1.9, 2.9, 3.4, 3.5}; // 打印所有数组元素 for (int i = 0; i &lt; myList.length; i++) { System.out.println(myList[i] + \" \"); } // 计算所有元素的总和 double total = 0; for (int i = 0; i &lt; myList.length; i++) { total += myList[i]; } System.out.println(\"Total is \" + total); // 查找最大元素 double max = myList[0]; for (int i = 1; i &lt; myList.length; i++) { if (myList[i] &gt; max) max = myList[i]; } System.out.println(\"Max is \" + max); }} 123456789101112131415for-each循环for(type element: array){ System.out.println(element);}public class TestArray { public static void main(String[] args) { double[] myList = {1.9, 2.9, 3.4, 3.5}; // 打印所有数组元素 for (double element: myList) { System.out.println(element); } }} :biking_man:数组作为函数的参数 12345public static void printArray(int[] array) { for (int i = 0; i &lt; array.length; i++) { System.out.print(array[i] + \" \"); }} :biking_man:数组作为函数的返回值 12345678public static int[] reverse(int[] list) { int[] result = new int[list.length]; for (int i = 0, j = result.length - 1; i &lt; list.length; i++, j--) { result[j] = list[i]; } return result;} :bike:多维数组 String str/[/]/[/] = new type /[typeLength1/]/[typeLenth2/]; 12345678String s[][] = new String[2][];s[0] = new String[2];s[1] = new String[3];s[0][0] = new String(\"Good\");s[0][1] = new String(\"Luck\");s[1][0] = new String(\"to\");s[1][1] = new String(\"you\");s[1][2] = new String(\"!\"); :basketball_man:Arrays 类 java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。 具有以下功能： 给数组赋值：通过 fill 方法。 对数组排序：通过 sort 方法, 按升序。 比较数组：通过 equals 方法比较数组中元素值是否相等。 查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。 具体说明请查看下表： 序号 方法和说明 1 public static int binarySearch(Object[] a, Object key) 用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(插入点) - 1)。 2 public static boolean equals(long[] a, long[] a2) 如果两个指定的 long 型数组彼此相等，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 3 public static void fill(int[] a, int val) 将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 4 public static void sort(Object[] a) 对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 java日期时间java.util 包提供了 Date 类来封装当前的日期和时间。 Date 类提供两个构造函数来实例化 Date 对象。 第一个构造函数使用当前日期和时间来初始化对象。Date( ) 第二个构造函数接收一个参数，该参数是从1970年1月1日起的毫秒数Date(long millisec) Date对象创建以后，可以调用下面的方法。 序号 方法和描述 1 boolean after(Date date) 若当调用此方法的Date对象在指定日期之后返回true,否则返回false。 2 boolean before(Date date) 若当调用此方法的Date对象在指定日期之前返回true,否则返回false。 3 Object clone( ) 返回此对象的副本。 4 int compareTo(Date date) 比较当调用此方法的Date对象和指定日期。两者相等时候返回0。调用对象在指定日期之前则返回负数。调用对象在指定日期之后则返回正数。 5 int compareTo(Object obj) 若obj是Date类型则操作等同于compareTo(Date) 。否则它抛出ClassCastException。 6 boolean equals(Object date) 当调用此方法的Date对象和指定日期相等时候返回true,否则返回false。 7 long getTime( ) 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。 8 int hashCode( ) 返回此对象的哈希码值。 9 void setTime(long time) 用自1970年1月1日00:00:00 GMT以后time毫秒数设置时间和日期。 10 String toString( ) 把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat) :biking_man:获取当前日期时间： 1234567891011import java.util.Date; public class DateDemo { public static void main(String args[]) { // 初始化 Date 对象 Date date = new Date(); // 使用 toString() 函数显示日期时间 System.out.println(date.toString()); }} :basketball_man:日期比较 Java使用以下三种方法来比较两个日期： 使用 getTime() 方法获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值。 使用方法 before()，after() 和 equals()。例如，一个月的12号比18号早，则 new Date(99, 2, 12).before(new Date (99, 2, 18)) 返回true。 使用 compareTo() 方法，它是由 Comparable 接口定义的，Date 类实现了这个接口。 :basketball_man:使用 SimpleDateFormat 格式化日期 SimpleDateFormat 是一个以语言环境敏感的方式来格式化和分析日期的类。SimpleDateFormat 允许你选择任何用户自定义日期时间格式来运行。例如： 123456789101112import java.util.*;import java.text.*; public class DateDemo { public static void main(String args[]) { Date dNow = new Date( ); SimpleDateFormat ft = new SimpleDateFormat (\"yyyy-MM-dd hh:mm:ss\"); System.out.println(\"当前时间为: \" + ft.format(dNow)); }} :basketball_man:解析字符串为时间 SimpleDateFormat 类有一些附加的方法，特别是parse()，它试图按照给定的SimpleDateFormat 对象的格式化存储来解析字符串。例如： 12345678910111213141516171819202122import java.util.*;import java.text.*; public class DateDemo { public static void main(String args[]) { SimpleDateFormat ft = new SimpleDateFormat (\"yyyy-MM-dd\"); String input = args.length == 0 ? \"1818-11-11\" : args[0]; System.out.print(input + \" Parses as \"); Date t; try { t = ft.parse(input); System.out.println(t); } catch (ParseException e) { System.out.println(\"Unparseable using \" + ft); } }} :basketball_man:java休眠（sleep） sleep()使当前线程进入停滞状态（阻塞当前线程），让出CPU的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会。 12345678910111213import java.util.*; public class SleepDemo { public static void main(String args[]) { try { System.out.println(new Date( ) + \"\\n\"); Thread.sleep(1000*3); // 休眠3秒 System.out.println(new Date( ) + \"\\n\"); } catch (Exception e) { System.out.println(\"Got an exception!\"); } }} :basketball_man:Calendar类 我们又如何在日期的这些部分加上或者减去值呢? 答案是使用Calendar 类。 Calendar类的功能要比Date类强大很多，而且在实现方式上也比Date类要复杂一些。 Calendar类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用getInstance方法创建即可。 123//创建一个代表2020年2月12日的Calendar对象Calendar c1 = Calendar.getInstance();c1.set(2020, 2 - 1, 12); :basketball_man:Calendar类对象字段类型** Calendar类中用以下这些常量表示不同的意义，jdk内的很多类其实都是采用的这种思想 常量 描述 Calendar.YEAR 年份 Calendar.MONTH 月份 Calendar.DATE 日期 Calendar.DAY_OF_MONTH 日期，和上面的字段意义完全相同 Calendar.HOUR 12小时制的小时 Calendar.HOUR_OF_DAY 24小时制的小时 Calendar.MINUTE 分钟 Calendar.SECOND 秒 Calendar.DAY_OF_WEEK 星期几 :basketball_man:Calendar类对象信息的设置 Set设置: 123Calendar c1 = Calendar.getInstance();public final void set(int year,int month,int date) c1.set(2020, 2, 12);//把Calendar对象c1的年月日分别设这为2020.2.12 利用字段类型设置 如果只设定某个字段，例如日期的值，则可以使用如下set方法： 1public void set(int field,int value) 把 c1对象代表的日期设置为10号，其它所有的数值会被重新计算 1c1.set(Calendar.DATE,10); 把c1对象代表的年份设置为2008年，其他的所有数值会被重新计算 1c1.set(Calendar.YEAR,2008); 其他字段属性set的意义以此类推 Add设置 1Calendar c1 = Calendar.getInstance(); 把c1对象的日期加上10，也就是c1也就表示为10天后的日期，其它所有的数值会被重新计算 1c1.add(Calendar.DATE, 10); 把c1对象的日期减去10，也就是c1也就表示为10天前的日期，其它所有的数值会被重新计算 1c1.add(Calendar.DATE, -10); 其他字段属性的add的意义以此类推 1234567891011 Calendar类对象信息的获得Calendar c1 = Calendar.getInstance(); // 获得年份 int year = c1.get(Calendar.YEAR); // 获得月份int month = c1.get(Calendar.MONTH) + 1; // 获得日期int date = c1.get(Calendar.DATE); // 获得小时 int hour = c1.get(Calendar.HOUR_OF_DAY); // 获得分钟int minute = c1.get(Calendar.MINUTE); // 获得秒int second = c1.get(Calendar.SECOND); // 获得星期几（注意（这个与Date类是不同的）：1代表星期日、2代表星期1、3代表星期二，以此类推） int day = c1.get(Calendar.DAY_OF_WEEK); :basketball_man:GregorianCalendar类 Calendar类实现了公历日历，GregorianCalendar是Calendar类的一个具体实现。 Calendar 的getInstance（）方法返回一个默认用当前的语言环境和时区初始化的GregorianCalendar对象。GregorianCalendar定义了两个字段：AD和BC。这是代表公历定义的两个时代。 下面列出GregorianCalendar对象的几个构造方法： 序号 构造函数和说明 1 GregorianCalendar() 在具有默认语言环境的默认时区内使用当前时间构造一个默认的 GregorianCalendar。 2 GregorianCalendar(int year, int month, int date) 在具有默认语言环境的默认时区内构造一个带有给定日期设置的 GregorianCalendar 3 GregorianCalendar(int year, int month, int date, int hour, int minute) 为具有默认语言环境的默认时区构造一个具有给定日期和时间设置的 GregorianCalendar。 4 GregorianCalendar(int year, int month, int date, int hour, int minute, int second) 为具有默认语言环境的默认时区构造一个具有给定日期和时间设置的 GregorianCalendar。 5 GregorianCalendar(Locale aLocale) 在具有给定语言环境的默认时区内构造一个基于当前时间的 GregorianCalendar。 6 GregorianCalendar(TimeZone zone) 在具有默认语言环境的给定时区内构造一个基于当前时间的 GregorianCalendar。 7 GregorianCalendar(TimeZone zone, Locale aLocale) 在具有给定语言环境的给定时区内构造一个基于当前时间的 GregorianCalendar。 这里是GregorianCalendar 类提供的一些有用的方法列表： 序号 方法和说明 1 void add(int field, int amount) 根据日历规则，将指定的（有符号的）时间量添加到给定的日历字段中。 2 protected void computeFields() 转换UTC毫秒值为时间域值 3 protected void computeTime() 覆盖Calendar ，转换时间域值为UTC毫秒值 4 boolean equals(Object obj) 比较此 GregorianCalendar 与指定的 Object。 5 int get(int field) 获取指定字段的时间值 6 int getActualMaximum(int field) 返回当前日期，给定字段的最大值 7 int getActualMinimum(int field) 返回当前日期，给定字段的最小值 8 int getGreatestMinimum(int field) 返回此 GregorianCalendar 实例给定日历字段的最高的最小值。 9 Date getGregorianChange() 获得格里高利历的更改日期。 10 int getLeastMaximum(int field) 返回此 GregorianCalendar 实例给定日历字段的最低的最大值 11 int getMaximum(int field) 返回此 GregorianCalendar 实例的给定日历字段的最大值。 12 Date getTime() 获取日历当前时间。 13 long getTimeInMillis() 获取用长整型表示的日历的当前时间 14 TimeZone getTimeZone() 获取时区。 15 int getMinimum(int field) 返回给定字段的最小值。 16 int hashCode() 重写hashCode. 17 boolean isLeapYear(int year) 确定给定的年份是否为闰年。 18 void roll(int field, boolean up) 在给定的时间字段上添加或减去（上/下）单个时间单元，不更改更大的字段。 19 void set(int field, int value) 用给定的值设置时间字段。 20 void set(int year, int month, int date) 设置年、月、日的值。 21 void set(int year, int month, int date, int hour, int minute) 设置年、月、日、小时、分钟的值。 22 void set(int year, int month, int date, int hour, int minute, int second) 设置年、月、日、小时、分钟、秒的值。 23 void setGregorianChange(Date date) 设置 GregorianCalendar 的更改日期。 24 void setTime(Date date) 用给定的日期设置Calendar的当前时间。 25 void setTimeInMillis(long millis) 用给定的long型毫秒数设置Calendar的当前时间。 26 void setTimeZone(TimeZone value) 用给定时区值设置当前时区。 27 String toString() 返回代表日历的字符串。 java正则表达式正则表达式定义了字符串的模式。可以用来搜索，编辑或者处理文本。一个字符串其实就是一个简单的正则表达式。 java.util.regex 包主要包括以下三个类： Pattern 类： pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。 Matcher 类： Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。 PatternSyntaxException： PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。 :basketball_man:正则表达式语法 在其他语言中，\\ 表示：我想要在正则表达式中插入一个普通的（字面上的）反斜杠，请不要给它任何特殊的意义。 在 Java 中，\\ 表示：我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。 所以，在其他的语言中（如Perl），一个反斜杠 \\ 就足以具有转义的作用，而在 Java 中正则表达式中则需要有两个反斜杠才能被解析为其他语言中的转义作用。也可以简单的理解在 Java 的正则表达式中，两个 \\ 代表其他语言中的一个 \\，这也就是为什么表示一位数字的正则表达式是 \\d，而表示一个普通的反斜杠是 \\\\。 字符 说明 \\ 将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，”n”匹配字符”n”。”\\n”匹配换行符。序列”\\\\“匹配”\\“，”\\(“匹配”(“。 ^ 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与”\\n”或”\\r”之后的位置匹配。 $ 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与”\\n”或”\\r”之前的位置匹配。 * 零次或多次匹配前面的字符或子表达式。例如，zo* 匹配”z”和”zoo”。* 等效于 {0,}。 + 一次或多次匹配前面的字符或子表达式。例如，”zo+”与”zo”和”zoo”匹配，但与”z”不匹配。+ 等效于 {1,}。 ? 零次或一次匹配前面的字符或子表达式。例如，”do(es)?”匹配”do”或”does”中的”do”。? 等效于 {0,1}。 {n} n 是非负整数。正好匹配 n 次。例如，”o{2}”与”Bob”中的”o”不匹配，但与”food”中的两个”o”匹配。 {n,} n 是非负整数。至少匹配 n 次。例如，”o{2,}”不匹配”Bob”中的”o”，而匹配”foooood”中的所有 o。”o{1,}”等效于”o+”。”o{0,}”等效于”o*”。 {n,m} m 和 n 是非负整数，其中 n &lt;= m。匹配至少 n 次，至多 m 次。例如，”o{1,3}”匹配”fooooood”中的头三个 o。’o{0,1}’ 等效于 ‘o?’。注意：您不能将空格插入逗号和数字之间。 ? 当此字符紧随任何其他限定符（、+、?、{*n}、{n,}、{n,m}）之后时，匹配模式是”非贪心的”。”非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的”贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串”oooo”中，”o+?”只匹配单个”o”，而”o+”匹配所有”o”。 . 匹配除”\\r\\n”之外的任何单个字符。若要匹配包括”\\r\\n”在内的任意字符，请使用诸如”[\\s\\S]”之类的模式。 (pattern) 匹配 pattern 并捕获该匹配的子表达式。可以使用 $0…$9 属性从结果”匹配”集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用”(“或者”)“。 (?:pattern) 匹配 pattern 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用”or”字符 (|) 组合模式部件的情况很有用。例如，’industr(?:y|ies) 是比 ‘industry|industries’ 更经济的表达式。 (?=pattern) 执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 pattern 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?=95|98|NT|2000)’ 匹配”Windows 2000”中的”Windows”，但不匹配”Windows 3.1”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。 (?!pattern) 执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 pattern 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?!95|98|NT|2000)’ 匹配”Windows 3.1”中的 “Windows”，但不匹配”Windows 2000”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。 x|y 匹配 x 或 y。例如，’z|food’ 匹配”z”或”food”。’(z|f)ood’ 匹配”zood”或”food”。 [xyz] 字符集。匹配包含的任一字符。例如，”[abc]”匹配”plain”中的”a”。 [^xyz] 反向字符集。匹配未包含的任何字符。例如，”[^abc]”匹配”plain”中”p”，”l”，”i”，”n”。 [a-z] 字符范围。匹配指定范围内的任何字符。例如，”[a-z]”匹配”a”到”z”范围内的任何小写字母。 [^a-z] 反向范围字符。匹配不在指定的范围内的任何字符。例如，”[^a-z]”匹配任何不在”a”到”z”范围内的任何字符。 \\b 匹配一个字边界，即字与空格间的位置。例如，”er\\b”匹配”never”中的”er”，但不匹配”verb”中的”er”。 \\B 非字边界匹配。”er\\B”匹配”verb”中的”er”，但不匹配”never”中的”er”。 \\cx 匹配 x 指示的控制字符。例如，\\cM 匹配 Control-M 或回车符。x 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是”c”字符本身。 \\d 数字字符匹配。等效于 [0-9]。 \\D 非数字字符匹配。等效于 [^0-9]。 \\f 换页符匹配。等效于 \\x0c 和 \\cL。 \\n 换行符匹配。等效于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等效于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等。与 [ \\f\\n\\r\\t\\v] 等效。 \\S 匹配任何非空白字符。与 [^ \\f\\n\\r\\t\\v] 等效。 \\t 制表符匹配。与 \\x09 和 \\cI 等效。 \\v 垂直制表符匹配。与 \\x0b 和 \\cK 等效。 \\w 匹配任何字类字符，包括下划线。与”[A-Za-z0-9_]”等效。 \\W 与任何非单词字符匹配。与”[^A-Za-z0-9_]”等效。 \\xn 匹配 n，此处的 n 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，”\\x41”匹配”A”。”\\x041”与”\\x04”&amp;”1”等效。允许在正则表达式中使用 ASCII 代码。 *num* 匹配 num*，此处的 *num 是一个正整数。到捕获匹配的反向引用。例如，”(.)\\1”匹配两个连续的相同字符。 *n* 标识一个八进制转义码或反向引用。如果 *n* 前面至少有 n 个捕获子表达式，那么 n 是反向引用。否则，如果 n 是八进制数 (0-7)，那么 n 是八进制转义码。 *nm* 标识一个八进制转义码或反向引用。如果 *nm* 前面至少有 nm 个捕获子表达式，那么 nm 是反向引用。如果 *nm* 前面至少有 n 个捕获，则 n 是反向引用，后面跟有字符 m。如果两种前面的情况都不存在，则 *nm* 匹配八进制值 nm*，其中 *n 和 m 是八进制数字 (0-7)。 \\nml 当 n 是八进制数 (0-3)，m 和 l 是八进制数 (0-7) 时，匹配八进制转义码 nml。 \\un 匹配 n，其中 n 是以四位十六进制数表示的 Unicode 字符。例如，\\u00A9 匹配版权符号 (©)。 根据 Java Language Specification 的要求，Java 源代码的字符串中的反斜线被解释为 Unicode 转义或其他字符转义。因此必须在字符串字面值中使用两个反斜线，表示正则表达式受到保护，不被 Java 字节码编译器解释。例如，当解释为正则表达式时，字符串字面值 “\\b” 与单个退格字符匹配，而 “\\b” 与单词边界匹配。字符串字面值 “(hello)“ 是非法的，将导致编译时错误；要与字符串 (hello) 匹配，必须使用字符串字面值 “\\(hello\\)”。 java方法Java方法是语句的集合，它们在一起执行一个功能。 方法是解决一类问题的步骤的有序组合 方法包含于类或对象中 方法在程序中被创建，在其他地方被引用 方法的定义 一般情况下，定义一个方法包含以下语法： 修饰符 返回值类型 方法名(参数类型 参数名){ … 方法体 … return 返回值; } 注意： 在一些其它语言中方法指过程和函数。一个返回非void类型返回值的方法称为函数；一个返回void类型返回值的方法叫做过程。 方法调用 Java 支持两种调用方法的方式，根据方法是否返回值来选择。 当方法返回一个值的时候，方法调用通常被当做一个值。例如： 1int larger = max(30, 40); 如果方法返回值是void，方法调用一定是一条语句。例如，方法println返回void。下面的调用是个语句： 1System.out.println(\"欢迎访问菜鸟教程！\"); 一个void方法的调用一定是一个语句。 所以，它被在main方法第三行以语句形式调用。就像任何以分号结束的语句一样。 示例下面的例子演示按值传递的效果。 该程序创建一个方法，该方法用于交换两个变量。 TestPassByValue.java 文件代码： 123456789101112131415161718192021222324252627public class TestPassByValue { public static void main(String[] args) { int num1 = 1; int num2 = 2; System.out.println(\"交换前 num1 的值为：\" + num1 + \" ，num2 的值为：\" + num2); // 调用swap方法 swap(num1, num2); System.out.println(\"交换后 num1 的值为：\" + num1 + \" ，num2 的值为：\" + num2); } /** 交换两个变量的方法 */ public static void swap(int n1, int n2) { System.out.println(\"\\t进入 swap 方法\"); System.out.println(\"\\t\\t交换前 n1 的值为：\" + n1 + \"，n2 的值：\" + n2); // 交换 n1 与 n2的值 int temp = n1; n1 = n2; n2 = temp; System.out.println(\"\\t\\t交换后 n1 的值为 \" + n1 + \"，n2 的值：\" + n2); }} 以上实例编译运行结果如下： 12345交换前 num1 的值为：1 ，num2 的值为：2 进入 swap 方法 交换前 n1 的值为：1，n2 的值：2 交换后 n1 的值为 2，n2 的值：1交换后 num1 的值为：1 ，num2 的值为：2 传递两个参数调用swap方法。有趣的是，方法被调用后，实参的值并没有改变。 构造方法 当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值。 通常会使用构造方法给一个类的实例变量赋初值，或者执行其它必要的步骤来创建一个完整的对象。 不管你是否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个默认构造方法，默认构造方法的访问修改符和类的访问修改符相同(类为 public，构造函数也为 public；类改为 protected，构造函数也改为 protected)。 一旦你定义了自己的构造方法，默认构造方法就会失效。 :basketball_man:可变参数 JDK 1.5 开始，Java支持传递同类型的可变参数给一个方法。 方法的可变参数的声明如下所示： typeName… parameterName 在方法声明中，在指定参数类型后加一个省略号(…) 。 一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。 实例 1234567891011121314151617181920212223public class VarargsDemo { public static void main(String args[]) { // 调用可变参数的方法 printMax(34, 3, 3, 2, 56.5); printMax(new double[]{1, 2, 3}); } public static void printMax( double... numbers) { if (numbers.length == 0) { System.out.println(\"No argument passed\"); return; } double result = numbers[0]; for (int i = 1; i &lt; numbers.length; i++){ if (numbers[i] &gt; result) { result = numbers[i]; } } System.out.println(\"The max value is \" + result); }} 以上实例编译运行结果如下： 12The max value is 56.5The max value is 3.0 java流（Stream）、文件（File)和IO读取控制台输入 Java 的控制台输入由 System.in 完成。 为了获得一个绑定到控制台的字符流，你可以把 System.in 包装在一个 BufferedReader 对象中来创建一个字符流。 下面是创建 BufferedReader 的基本语法： 1BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedReader 对象创建后，我们便可以使用 read() 方法从控制台读取一个字符，或者用 readLine() 方法读取一个字符串。 从控制台读取多字符输入 从 BufferedReader 对象读取一个字符要使用 read() 方法，它的语法如下： int read( ) throws IOException 每次调用 read() 方法，它从输入流读取一个字符并把该字符作为整数值返回。 当流结束的时候返回 -1。该方法抛出 IOException。 下面的程序示范了用 read() 方法从控制台不断读取字符直到用户输入 “q”。 1234567891011121314151617//使用 BufferedReader 在控制台读取字符 import java.io.*; public class BRRead { public static void main(String args[]) throws IOException { char c; // 使用 System.in 创建 BufferedReader BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"输入字符, 按下 'q' 键退出。\"); // 读取字符 do { c = (char) br.read(); System.out.println(c); } while (c != 'q'); }} 从控制台读取字符串 从标准输入读取一个字符串需要使用 BufferedReader 的 readLine() 方法。 它的一般格式是： 1String readLine( ) throws IOException 读写文件 :basketball_man:FileInputStream 该流用于从文件读取数据，它的对象可以用关键字 new 来创建。 有多种构造方法可用来创建对象。 可以使用字符串类型的文件名来创建一个输入流对象来读取文件： InputStream f = new FileInputStream(“C:/java/hello”); 也可以使用一个文件对象来创建一个输入流对象来读取文件。我们首先得使用 File() 方法来创建一个文件对象： File f = new File(“C:/java/hello”); InputStream out = new FileInputStream(f); 创建了InputStream对象，就可以使用下面的方法来读取流或者进行其他的流操作。 序号 方法及描述 1 public void close() throws IOException{} 关闭此文件输入流并释放与此流有关的所有系统资源。抛出IOException异常。 2 protected void finalize()throws IOException {} 这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其 close 方法。抛出IOException异常。 3 public int read(int r)throws IOException{} 这个方法从 InputStream 对象读取指定字节的数据。返回为整数值。返回下一字节数据，如果已经到结尾则返回-1。 4 public int read(byte[] r) throws IOException{} 这个方法从输入流读取r.length长度的字节。返回读取的字节数。如果是文件结尾则返回-1。 5 public int available() throws IOException{} 返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取的字节数。返回一个整数值。 :basketball_man:FileOutputStream 该类用来创建一个文件并向文件中写数据。 如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件。 有两个构造方法可以用来创建 FileOutputStream 对象。 使用字符串类型的文件名来创建一个输出流对象： OutputStream f = new FileOutputStream(“C:/java/hello”) 也可以使用一个文件对象来创建一个输出流来写文件。我们首先得使用File()方法来创建一个文件对象： File f = new File(“C:/java/hello”); OutputStream f = new FileOutputStream(f); 创建OutputStream 对象完成后，就可以使用下面的方法来写入流或者进行其他的流操作。 序号 方法及描述 1 public void close() throws IOException{} 关闭此文件输入流并释放与此流有关的所有系统资源。抛出IOException异常。 2 protected void finalize()throws IOException {} 这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其 close 方法。抛出IOException异常。 3 public void write(int w)throws IOException{} 这个方法把指定的字节写到输出流中。 4 public void write(byte[] w) 把指定数组中w.length长度的字节写到OutputStream中。 :man:Java中的目录 创建目录： File类中有两个方法可以用来创建文件夹： mkdir( )方法创建一个文件夹，成功则返回true，失败则返回false。失败表明File对象指定的路径已经存在，或者由于整个路径还不存在，该文件夹不能被创建。 mkdirs()方法创建一个文件夹和它的所有父文件夹。 下面的例子创建 “/tmp/user/java/bin”文件夹： CreateDir.java 文件代码： import java.io.File; public class CreateDir { public static void main(String args[]) { String dirname = “/tmp/user/java/bin”; File d = new File(dirname); // 现在创建目录 d.mkdirs(); } } 编译并执行上面代码来创建目录 “/tmp/user/java/bin”。 注意： Java 在 UNIX 和 Windows 自动按约定分辨文件路径分隔符。如果你在 Windows 版本的 Java 中使用分隔符 (/) ，路径依然能够被正确解析。 读取目录 一个目录其实就是一个 File 对象，它包含其他文件和文件夹。 如果创建一个 File 对象并且它是一个目录，那么调用 isDirectory() 方法会返回 true。 可以通过调用该对象上的 list() 方法，来提取它包含的文件和文件夹的列表。 12345678910111213141516171819202122232425下面展示的例子说明如何使用 list() 方法来检查一个文件夹中包含的内容：DirList.java 文件代码：import java.io.File; public class DirList { public static void main(String args[]) { String dirname = \"/tmp\"; File f1 = new File(dirname); if (f1.isDirectory()) { System.out.println(\"目录 \" + dirname); String s[] = f1.list(); for (int i = 0; i &lt; s.length; i++) { File f = new File(dirname + \"/\" + s[i]); if (f.isDirectory()) { System.out.println(s[i] + \" 是一个目录\"); } else { System.out.println(s[i] + \" 是一个文件\"); } } } else { System.out.println(dirname + \" 不是一个目录\"); } }} 1234567891011121314151617181920212223242526272829303132333435删除目录或文件删除文件可以使用 java.io.File.delete() 方法。以下代码会删除目录 /tmp/java/，需要注意的是当删除某一目录时，必须保证该目录下没有其他文件才能正确删除，否则将删除失败。测试目录结构：/tmp/java/|-- 1.log|-- testDeleteFileDemo.java 文件代码：import java.io.File; public class DeleteFileDemo { public static void main(String args[]) { // 这里修改为自己的测试目录 File folder = new File(\"/tmp/java/\"); deleteFolder(folder); } // 删除文件及目录 public static void deleteFolder(File folder) { File[] files = folder.listFiles(); if (files != null) { for (File f : files) { if (f.isDirectory()) { deleteFolder(f); } else { f.delete(); } } } folder.delete(); }} java Scanner类java.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。 下面是创建 Scanner 对象的基本语法： Scanner s = new Scanner(System.in); 接下来我们演示一个最简单的数据输入，并通过 Scanner 类的 next() 与 nextLine() 方法获取输入的字符串，在读取前我们一般需要 使用 hasNext 与 hasNextLine 判断是否还有输入的数据： 使用 next 方法：ScannerDemo.java 文件代码：ava.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。 下面是创建 Scanner 对象的基本语法： Scanner s = new Scanner(System.in); 接下来我们演示一个最简单的数据输入，并通过 Scanner 类的 next() 与 nextLine() 方法获取输入的字符串，在读取前我们一般需要 使用 hasNext 与 hasNextLine 判断是否还有输入的数据： 使用 next 方法： 1234567891011121314151617import java.util.Scanner; public class ScannerDemo { public static void main(String[] args) { Scanner scan = new Scanner(System.in); // 从键盘接收数据 // next方式接收字符串 System.out.println(\"next方式接收：\"); // 判断是否还有输入 if (scan.hasNext()) { String str1 = scan.next(); System.out.println(\"输入的数据为：\" + str1); } scan.close(); }} 执行以上程序输出结果为： 12345$ javac ScannerDemo.java$ java ScannerDemonext方式接收：runoob com输入的数据为：runoob 12345678910111213141516171819使用 nextLine 方法：ScannerDemo.java 文件代码：import java.util.Scanner; public class ScannerDemo { public static void main(String[] args) { Scanner scan = new Scanner(System.in); // 从键盘接收数据 // nextLine方式接收字符串 System.out.println(\"nextLine方式接收：\"); // 判断是否还有输入 if (scan.hasNextLine()) { String str2 = scan.nextLine(); System.out.println(\"输入的数据为：\" + str2); } scan.close(); }} next(): 1、一定要读取到有效字符后才可以结束输入。 2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。 3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。 next() 不能得到带有空格的字符串。 nextLine()： 1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。 2、可以获得空白。 如果要输入 int 或 float 类型的数据，在 Scanner 类中也有支持，但是在输入之前最好先使用 hasNextXxx() 方法进行验证，再使用 nextXxx() 来读取： 12345678910111213141516171819202122232425262728293031import java.util.Scanner; public class ScannerDemo { public static void main(String[] args) { Scanner scan = new Scanner(System.in); // 从键盘接收数据 int i = 0; float f = 0.0f; System.out.print(\"输入整数：\"); if (scan.hasNextInt()) { // 判断输入的是否是整数 i = scan.nextInt(); // 接收整数 System.out.println(\"整数数据：\" + i); } else { // 输入错误的信息 System.out.println(\"输入的不是整数！\"); } System.out.print(\"输入小数：\"); if (scan.hasNextFloat()) { // 判断输入的是否是小数 f = scan.nextFloat(); // 接收小数 System.out.println(\"小数数据：\" + f); } else { // 输入错误的信息 System.out.println(\"输入的不是小数！\"); } scan.close(); }} java异常处理要理解Java异常处理是如何工作的， 需要掌握以下三种类型的异常： 检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。 运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。 错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。 Error 用来指示运行时环境发生的错误。 例如，JVM 内存溢出。一般地，程序不会从错误中恢复。 异常类有两个主要的子类：IOException 类和 RuntimeException 类。 异常方法 下面的列表是 Throwable 类的主要方法: 序号 方法及说明 1 public String getMessage() 返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。 2 public Throwable getCause() 返回一个Throwable 对象代表异常原因。 3 public String toString() 使用getMessage()的结果返回类的串级名字。 4 public void printStackTrace() 打印toString()结果和栈层次到System.err，即错误输出流。 5 public StackTraceElement [] getStackTrace() 返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。 6 public Throwable fillInStackTrace() 用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。 捕获异常 使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。 try/catch代码块中的代码称为保护代码，使用 try/catch 的语法如下： 1234567try{ // 程序代码}catch(ExceptionName e1){ //Catch 块} Catch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。 如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块，这和传递一个参数到方法是一样。 多重捕获块 一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获。 多重捕获块的语法如下所示： try{ // 程序代码 }catch(异常类型1 异常的变量名1){ // 程序代码 }catch(异常类型2 异常的变量名2){ // 程序代码 }catch(异常类型2 异常的变量名2){ // 程序代码 } throws/throw 关键字： 如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。 也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。 12345678910import java.io.*;public class className{ public void deposit(double amount) throws RemoteException { // Method implementation throw new RemoteException(); } //Remainder of class definition} 一个方法可以声明抛出多个异常，多个异常之间用逗号隔开。 finally关键字 finally 关键字用来创建在 try 代码块后面执行的代码块。 无论是否发生异常，finally 代码块中的代码总会被执行。 在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。 finally 代码块出现在 catch 代码块最后，语法如下： 12345try{ // 程序代码 }catch(异常类型1 异常的变量名1){ // 程序代码 }catch(异常类型2 异常的变量名2){ // 程序代码 }finally{ // 程序代码 } 注意下面事项： catch 不能独立于 try 存在。 在 try/catch 后面添加 finally 块并非强制性要求的。 try 代码后不能既没 catch 块也没 finally 块。 try, catch, finally 块之间不能添加任何代码。 声明自定义异常 在 Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。 所有异常都必须是 Throwable 的子类。 如果希望写一个检查性异常类，则需要继承 Exception 类。 如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。 1class MyException extends Exception{ } 通用异常 在Java中定义了两种类型的异常和错误。 JVM(Java**虚拟机) 异常：由 JVM 抛出的异常或错误。例如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类。 程序级异常：由程序或者API程序抛出的异常。例如 IllegalArgumentException 类，IllegalStateException 类。","link":"/2020/02/15/java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"SpringBoot经典学习笔记","text":"跟武哥一起学习Spring Boot作者信息本课程首发于 CSDN GitChat 达人课《跟武哥一起学Spring Boot》，该文档为课程详细笔记。作者：倪升武（武哥）微信公众号：武哥聊编程 版权申明：本课程已经免费，但版权属于 CSDN 和作者，未经允许，不得将该笔记用于商业用途和其他不正当用途，否则追究法律责任。 导读：课程概览1. Spring Boot是什么我们知道，从 2002 年开始，Spring 一直在飞速的发展，如今已经成为了在Java EE（Java Enterprise Edition）开发中真正意义上的标准，但是随着技术的发展，Java EE使用 Spring 逐渐变得笨重起来，大量的 XML 文件存在于项目之中。繁琐的配置，整合第三方框架的配置问题，导致了开发和部署效率的降低。 2012 年 10 月，Mike Youngstrom 在 Spring jira 中创建了一个功能请求，要求在 Spring 框架中支持无容器 Web 应用程序体系结构。他谈到了在主容器引导 spring 容器内配置 Web 容器服务。这是 jira 请求的摘录： 我认为 Spring 的 Web 应用体系结构可以大大简化，如果它提供了从上到下利用 Spring 组件和配置模型的工具和参考体系结构。在简单的 main()方法引导的 Spring 容器内嵌入和统一这些常用Web 容器服务的配置。 这一要求促使了 2013 年初开始的 Spring Boot 项目的研发，到今天，Spring Boot 的版本已经到了 2.0.3 RELEASE。Spring Boot 并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。 它集成了大量常用的第三方库配置，Spring Boot应用中这些第三方库几乎可以是零配置的开箱即用（out-of-the-box），大部分的 Spring Boot 应用都只需要非常少量的配置代码（基于 Java 的配置），开发者能够更加专注于业务逻辑。 2. 为什么学习Spring Boot2.1 从Spring官方来看我们打开 Spring 的官方网站，可以看到下图： 我们可以看到图中官方对 Spring Boot 的定位：Build Anything， Build任何东西。Spring Boot旨在尽可能快地启动和运行，并且只需最少的 Spring 前期配置。 同时我们也来看一下官方对后面两个的定位： SpringCloud：Coordinate Anything，协调任何事情；SpringCloud Data Flow：Connect everything，连接任何东西。 仔细品味一下，Spring 官网对 Spring Boot、SpringCloud 和 SpringCloud Data Flow三者定位的措辞非常有味道，同时也可以看出，Spring 官方对这三个技术非常重视，是现在以及今后学习的重点（SpringCloud 相关达人课课程届时也会上线）。 2.2 从Spring Boot的优点来看Spring Boot 有哪些优点？主要给我们解决了哪些问题呢？我们以下图来说明： 2.2.1 良好的基因Spring Boot 是伴随着 Spring 4.0 诞生的，从字面理解，Boot是引导的意思，因此 Spring Boot 旨在帮助开发者快速搭建 Spring 框架。Spring Boot 继承了原有 Spring 框架的优秀基因，使 Spring 在使用中更加方便快捷。 2.2.2 简化编码举个例子，比如我们要创建一个 web 项目，使用 Spring 的朋友都知道，在使用 Spring 的时候，需要在 pom 文件中添加多个依赖，而 Spring Boot 则会帮助开发着快速启动一个 web 容器，在 Spring Boot 中，我们只需要在 pom 文件中添加如下一个 starter-web 依赖即可。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 我们点击进入该依赖后可以看到，Spring Boot 这个 starter-web 已经包含了多个依赖，包括之前在 Spring 工程中需要导入的依赖，我们看一下其中的一部分，如下： 12345678910111213&lt;!-- .....省略其他依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.0.7.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.0.7.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; 由此可以看出，Spring Boot 大大简化了我们的编码，我们不用一个个导入依赖，直接一个依赖即可。 2.2.3 简化配置Spring 虽然使Java EE轻量级框架，但由于其繁琐的配置，一度被人认为是“配置地狱”。各种XML、Annotation配置会让人眼花缭乱，而且配置多的话，如果出错了也很难找出原因。Spring Boot更多的是采用 Java Config 的方式，对 Spring 进行配置。举个例子： 我新建一个类，但是我不用 @Service注解，也就是说，它是个普通的类，那么我们如何使它也成为一个 Bean 让 Spring 去管理呢？只需要@Configuration 和@Bean两个注解即可，如下： 12345public class TestService { public String sayHello () { return \"Hello Spring Boot!\"; }} 12345678910import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class JavaConfig { @Bean public TestService getTestService() { return new TestService(); }} @Configuration表示该类是个配置类，@Bean表示该方法返回一个 Bean。这样就把TestService作为 Bean 让 Spring 去管理了，在其他地方，我们如果需要使用该 Bean，和原来一样，直接使用@Resource注解注入进来即可使用，非常方便。 12@Resourceprivate TestService testService; 另外，部署配置方面，原来 Spring 有多个 xml 和 properties配置，在 Spring Boot 中只需要个 application.yml即可。 2.2.4 简化部署在使用 Spring 时，项目部署时需要我们在服务器上部署 tomcat，然后把项目打成 war 包扔到 tomcat里，在使用 Spring Boot 后，我们不需要在服务器上去部署 tomcat，因为 Spring Boot 内嵌了 tomcat，我们只需要将项目打成 jar 包，使用 java -jar xxx.jar一键式启动项目。 另外，也降低对运行环境的基本要求，环境变量中有JDK即可。 2.2.5 简化监控我们可以引入 spring-boot-start-actuator 依赖，直接使用 REST 方式来获取进程的运行期性能参数，从而达到监控的目的，比较方便。但是 Spring Boot 只是个微框架，没有提供相应的服务发现与注册的配套功能，没有外围监控集成方案，没有外围安全管理方案，所以在微服务架构中，还需要 Spring Cloud 来配合一起使用。 2.3 从未来发展的趋势来看微服务是未来发展的趋势，项目会从传统架构慢慢转向微服务架构，因为微服务可以使不同的团队专注于更小范围的工作职责、使用独立的技术、更安全更频繁地部署。而 继承了 Spring 的优良特性，与 Spring 一脉相承，而且 支持各种REST API 的实现方式。Spring Boot 也是官方大力推荐的技术，可以看出，Spring Boot 是未来发展的一个大趋势。 3. 本课程能学到什么本课程使用目前 Spring Boot 最新版本2.0.3 RELEASE，课程文章均为作者在实际项目中剥离出来的场景和demo，目标是带领学习者快速上手 Spring Boot，将 Spring Boot 相关技术点快速运用在微服务项目中。全篇分为两部分：基础篇和进阶篇。 基础篇（01—10课）主要介绍 Spring Boot 在项目中最常使用的一些功能点，旨在带领学习者快速掌握 Spring Boot 在开发时需要的知识点，能够把 Spring Boot 相关技术运用到实际项目架构中去。该部分以 Spring Boot 框架为主线，内容包括Json数据封装、日志记录、属性配置、MVC支持、在线文档、模板引擎、异常处理、AOP 处理、持久层集成等等。 进阶篇（11—17课）主要是介绍 Spring Boot 在项目中拔高一些的技术点，包括集成的一些组件，旨在带领学习者在项目中遇到具体的场景时能够快速集成，完成对应的功能。该部分以 Spring Boot 框架为主线，内容包括拦截器、监听器、缓存、安全认证、分词插件、消息队列等等。 认真读完该系列文章之后，学习者会快速了解并掌握 Spring Boot 在项目中最常用的技术点，作者课程的最后，会基于课程内容搭建一个 Spring Boot 项目的空架构，该架构也是从实际项目中剥离出来，学习者可以运用该架构于实际项目中，具备使用 Spring Boot 进行实际项目开发的能力。 课程所有源码提供免费下载：下载地址。 欢迎关注我的为微信公众号：武哥聊编程 4. 适合阅读的人群本课程适合以下人群阅读： 有一定的Java语言基础，了解Spring、Maven的在校学生或自学者 有传统项目经验，想往微服务方向发展的工作人员 热衷于新技术并对 Spring Boot 感兴趣的人员 希望了解 Spring Boot 2.0.3 的研究人员5. 本课程开发环境和插件 本课程的开发环境： 开发工具：IDEA 2017 JDK版本： JDK 1.8 Spring Boot版本：2.0.3 RELEASE Maven版本：3.5.2 涉及到的插件： FastJson Swagger2 Thymeleaf MyBatis Redis ActiveMQ Shiro Lucence 6. 课程目录 导读：课程概览 第01课：Spring Boot开发环境搭建和项目启动 第02课：Spring Boot返回Json数据及数据封装 第03课：Spring Boot使用slf4j进行日志记录 第04课：Spring Boot中的项目属性配置 第05课：Spring Boot中的MVC支持 第06课：Spring Boot集成Swagger2展现在线接口文档 第07课：Spring Boot集成Thymeleaf模板引擎 第08课：Spring Boot中的全局异常处理 第09课：Spring Boot中的切面AOP处理 第10课：Spring Boot中集成MyBatis 第11课：Spring Boot事务配置管理 第12课：Spring Boot中使用监听器 第13课：Spring Boot中使用拦截器 第14课：Spring Boot中集成Redis 第15课：Spring Boot中集成ActiveMQ 第16课：Spring Boot中集成Shiro 第17课：Spring Boot中结成Lucence 第18课：Spring Boot搭建实际项目开发中的架构 欢迎关注我的为微信公众号：武哥聊编程 第01课：Spring Boot开发环境搭建和项目启动上一节对 SpringBoot 的特性做了一个介绍，本节主要对 jdk 的配置、Spring Boot工程的构建和项目的启动、Spring Boot 项目工程的结构做一下讲解和分析。 1. jdk 的配置本课程是使用 IDEA 进行开发，在IDEA 中配置 jdk 的方式很简单，打开File-&gt;Project Structure，如下图所： 选择 SDKs 在 JDK home path 中选择本地 jdk 的安装目录 在 Name 中为 jdk 自定义名字 通过以上三步骤，即可导入本地安装的 jdk。如果是使用 STS 或者 eclipse 的朋友，可以通过两步骤添加： window-&gt;preference-&gt;java-&gt;Instralled JRES来添加本地 jdk。 window--&gt;preference--&gt;java--&gt;Compiler选择 jre，和 jdk 保持一致。 2. Spring Boot 工程的构建2.1 IDEA 快速构建IDEA 中可以通过File-&gt;New-&gt;Project来快速构建 Spring Boot 工程。如下，选择 Spring Initializr，在 Project SDK 中选择刚刚我们导入的 jdk，点击 Next，到了项目的配置信息。 Group：填企业域名，本课程使用com.itcodai Artifact：填项目名称，本课程中每一课的工程名以course+课号命令，这里使用 course01 Dependencies：可以添加我们项目中所需要的依赖信息，根据实际情况来添加，本课程只需要选择 Web 即可。 2.2 官方构建第二种方式可以通过官方构建，步骤如下： 访问 http://start.spring.io/。 在页面上输入相应的 Spring Boot 版本、Group 和 Artifact 信息以及项目依赖，然后创建项目。 解压后，使用 IDEA 导入该 maven 工程：File-&gt;New-&gt;Model from Existing Source，然后选择解压后的项目文件夹即可。如果是使用 eclipse 的朋友，可以通过Import-&gt;Existing Maven Projects-&gt;Next，然后选择解压后的项目文件夹即可。 2.3 maven配置创建了 Spring Boot 项目之后，需要进行 maven 配置。打开File-&gt;settings，搜索 maven，配置一下本地的 maven 信息。如下： 在 Maven home directory 中选择本地 Maven 的安装路径；在 User settings file 中选择本地 Maven 的配置文件所在路径。在配置文件中，我们配置一下国内阿里的镜像，这样在下载 maven 依赖时，速度很快。 123456&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt; 如果是使用 eclipse 的朋友，可以通过window--&gt;preference--&gt;Maven--&gt;User Settings来配置，配置方式和上面一致。 2.4 编码配置同样地，新建项目后，我们一般都需要配置编码，这点非常重要，很多初学者都会忘记这一步，所以要养成良好的习惯。 IDEA 中，仍然是打开File-&gt;settings，搜索 encoding，配置一下本地的编码信息。如下： 如果是使用 eclipse 的朋友，有两个地方需要设置一下编码： window–&gt; perferences–&gt;General–&gt;Workspace，将Text file encoding改成utf-8 window–&gt;perferences–&gt;General–&gt;content types，选中Text，将Default encoding填入utf-8 OK，编码设置完成即可启动项目工程了。 3. Spring Boot 项目工程结构Spring Boot 项目总共有三个模块，如下图所示： src/main/java路径：主要编写业务程序 src/main/resources路径：存放静态文件和配置文件 src/test/java路径：主要编写测试程序 默认情况下，如上图所示会创建一个启动类 Course01Application，该类上面有个@SpringBootApplication注解，该启动类中有个 main 方法，没错，Spring Boot 启动只要运行该 main 方法即可，非常方便。另外，Spring Boot 内部集成了 tomcat，不需要我们人为手动去配置 tomcat，开发者只需要关注具体的业务逻辑即可。 到此为止，Spring Boot 就启动成功了，为了比较清楚的看到效果，我们写一个 Controller 来测试一下，如下： 1234567891011121314package com.itcodai.course01.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping(\"/start\")public class StartController { @RequestMapping(\"/springboot\") public String startSpringBoot() { return \"Welcome to the world of Spring Boot!\"; }} 重新运行 main 方法启动项目，在浏览器中输入 localhost:8080/start/springboot，如果看到 “Welcome to the world of Spring Boot!”，那么恭喜你项目启动成功！Spring Boot 就是这么简单方便！端口号默认是8080，如果想要修改，可以在 application.yml 文件中使用 server.port 来人为指定端口，如8001端口： 12server: port: 8001 4. 总结本节我们快速学习了如何在 IDEA 中导入 jdk，以及使用 IDEA 如何配置 maven 和编码，如何快速的创建和启动 Spring Boot 工程。IDEA 对 Spring Boot 的支持非常友好，建议大家使用 IDEA 进行 Spring Boot 的开发，从下一课开始，我们真正进入 Spring Boot 的学习中。课程源代码下载地址：戳我下载 欢迎关注我的为微信公众号：武哥聊编程 第02课：Spring Boot返回Json数据及数据封装在项目开发中，接口与接口之间，前后端之间数据的传输都使用 Json 格式，在 Spring Boot 中，接口返回 Json 格式的数据很简单，在 Controller 中使用@RestController注解即可返回 Json 格式的数据，@RestController也是 Spring Boot 新增的一个注解，我们点进去看一下该注解都包含了哪些东西。 12345678@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Controller@ResponseBodypublic @interface RestController { String value() default \"\";} 可以看出， @RestController 注解包含了原来的 @Controller 和 @ResponseBody 注解，使用过 Spring 的朋友对 @Controller 注解已经非常了解了，这里不再赘述， @ResponseBody 注解是将返回的数据结构转换为 Json 格式。所以在默认情况下，使用了 @RestController 注解即可将返回的数据结构转换成 Json 格式，Spring Boot 中默认使用的 Json 解析技术框架是 jackson。我们点开 pom.xml 中的 spring-boot-starter-web 依赖，可以看到一个 spring-boot-starter-json 依赖： 123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt; &lt;version&gt;2.0.3.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; Spring Boot 中对依赖都做了很好的封装，可以看到很多 spring-boot-starter-xxx 系列的依赖，这是 Spring Boot 的特点之一，不需要人为去引入很多相关的依赖了，starter-xxx 系列直接都包含了所必要的依赖，所以我们再次点进去上面这个 spring-boot-starter-json 依赖，可以看到： 123456789101112131415161718192021222324&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.6&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt; &lt;artifactId&gt;jackson-datatype-jdk8&lt;/artifactId&gt; &lt;version&gt;2.9.6&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt; &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt; &lt;version&gt;2.9.6&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.module&lt;/groupId&gt; &lt;artifactId&gt;jackson-module-parameter-names&lt;/artifactId&gt; &lt;version&gt;2.9.6&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; 到此为止，我们知道了 Spring Boot 中默认使用的 json 解析框架是 jackson。下面我们看一下默认的 jackson 框架对常用数据类型的转 Json 处理。 1. Spring Boot 默认对Json的处理在实际项目中，常用的数据结构无非有类对象、List对象、Map对象，我们看一下默认的 jackson 框架对这三个常用的数据结构转成 json 后的格式如何。 1.1 创建 User 实体类为了测试，我们需要创建一个实体类，这里我们就用 User 来演示。 123456public class User { private Long id; private String username; private String password; /* 省略get、set和带参构造方法 */} 1.2 创建Controller类然后我们创建一个 Controller，分别返回 User对象、List&lt;User&gt; 和 Map&lt;String, Object&gt;。 1234567891011121314151617181920212223242526272829303132333435363738import com.itcodai.course02.entity.User;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;@RestController@RequestMapping(\"/json\")public class JsonController { @RequestMapping(\"/user\") public User getUser() { return new User(1, \"倪升武\", \"123456\"); } @RequestMapping(\"/list\") public List&lt;User&gt; getUserList() { List&lt;User&gt; userList = new ArrayList&lt;&gt;(); User user1 = new User(1, \"倪升武\", \"123456\"); User user2 = new User(2, \"达人课\", \"123456\"); userList.add(user1); userList.add(user2); return userList; } @RequestMapping(\"/map\") public Map&lt;String, Object&gt; getMap() { Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(3); User user = new User(1, \"倪升武\", \"123456\"); map.put(\"作者信息\", user); map.put(\"博客地址\", \"http://blog.itcodai.com\"); map.put(\"CSDN地址\", \"http://blog.csdn.net/eson_15\"); map.put(\"粉丝数量\", 4153); return map; }} 1.3 测试不同数据类型返回的jsonOK，写好了接口，分别返回了一个 User 对象、一个 List 集合和一个 Map 集合，其中 Map 集合中的 value 存的是不同的数据类型。接下来我们依次来测试一下效果。 在浏览器中输入：localhost:8080/json/user 返回 json 如下： 1{\"id\":1,\"username\":\"倪升武\",\"password\":\"123456\"} 在浏览器中输入：localhost:8080/json/list 返回 json 如下： 1[{\"id\":1,\"username\":\"倪升武\",\"password\":\"123456\"},{\"id\":2,\"username\":\"达人课\",\"password\":\"123456\"}] 在浏览器中输入：localhost:8080/json/map 返回 json 如下： 1{\"作者信息\":{\"id\":1,\"username\":\"倪升武\",\"password\":\"123456\"},\"CSDN地址\":\"http://blog.csdn.net/eson_15\",\"粉丝数量\":4153,\"博客地址\":\"http://blog.itcodai.com\"} 可以看出，map 中不管是什么数据类型，都可以转成相应的 json 格式，这样就非常方便。 1.4 jackson 中对null的处理在实际项目中，我们难免会遇到一些 null 值出现，我们转 json 时，是不希望有这些 null 出现的，比如我们期望所有的 null 在转 json 时都变成 “” 这种空字符串，那怎么做呢？在 Spring Boot 中，我们做一下配置即可，新建一个 jackson 的配置类： 12345678910111213141516171819202122232425262728import com.fasterxml.jackson.core.JsonGenerator;import com.fasterxml.jackson.databind.JsonSerializer;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.SerializerProvider;import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;import java.io.IOException;@Configurationpublic class JacksonConfig { @Bean @Primary @ConditionalOnMissingBean(ObjectMapper.class) public ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) { ObjectMapper objectMapper = builder.createXmlMapper(false).build(); objectMapper.getSerializerProvider().setNullValueSerializer(new JsonSerializer&lt;Object&gt;() { @Override public void serialize(Object o, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException { jsonGenerator.writeString(\"\"); } }); return objectMapper; }} 然后我们修改一下上面返回 map 的接口，将几个值改成 null 测试一下： 12345678910@RequestMapping(\"/map\")public Map&lt;String, Object&gt; getMap() { Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(3); User user = new User(1, \"倪升武\", null); map.put(\"作者信息\", user); map.put(\"博客地址\", \"http://blog.itcodai.com\"); map.put(\"CSDN地址\", null); map.put(\"粉丝数量\", 4153); return map;} 重启项目，再次输入：localhost:8080/json/map，可以看到 jackson 已经将所有 null 字段转成了空字符串了。 1{\"作者信息\":{\"id\":1,\"username\":\"倪升武\",\"password\":\"\"},\"CSDN地址\":\"\",\"粉丝数量\":4153,\"博客地址\":\"http://blog.itcodai.com\"} 2. 使用阿里巴巴FastJson的设置2.1 jackson 和 fastJson 的对比有很多朋友习惯于使用阿里巴巴的 fastJson 来做项目中 json 转换的相关工作，目前我们项目中使用的就是阿里的 fastJson，那么 jackson 和 fastJson 有哪些区别呢？根据网上公开的资料比较得到下表。| 选项 | fastJson | jackson || :-: | :-: | :-: || 上手难易程度 | 容易 | 中等 || 高级特性支持 | 中等 | 丰富 || 官方文档、Example支持 | 中文 | 英文 || 处理json速度 | 略快 | 快 | 关于 fastJson 和 jackson 的对比，网上有很多资料可以查看，主要是根据自己实际项目情况来选择合适的框架。从扩展上来看，fastJson 没有 jackson 灵活，从速度或者上手难度来看，fastJson 可以考虑，我们项目中目前使用的是阿里的 fastJson，挺方便的。 2.2 fastJson依赖导入使用 fastJson 需要导入依赖，本课程使用 1.2.35 版本，依赖如下： 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.35&lt;/version&gt;&lt;/dependency&gt; 2.2 使用 fastJson 处理 null使用 fastJson 时，对 null 的处理和 jackson 有些不同，需要继承 WebMvcConfigurationSupport 类，然后覆盖 configureMessageConverters 方法，在方法中，我们可以选择对要实现 null 转换的场景，配置好即可。如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import com.alibaba.fastjson.serializer.SerializerFeature;import com.alibaba.fastjson.support.config.FastJsonConfig;import com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter;import org.springframework.context.annotation.Configuration;import org.springframework.http.MediaType;import org.springframework.http.converter.HttpMessageConverter;import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;import java.nio.charset.Charset;import java.util.ArrayList;import java.util.List;@Configurationpublic class fastJsonConfig extends WebMvcConfigurationSupport { /** * 使用阿里 FastJson 作为JSON MessageConverter * @param converters */ @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) { FastJsonHttpMessageConverter converter = new FastJsonHttpMessageConverter(); FastJsonConfig config = new FastJsonConfig(); config.setSerializerFeatures( // 保留map空的字段 SerializerFeature.WriteMapNullValue, // 将String类型的null转成\"\" SerializerFeature.WriteNullStringAsEmpty, // 将Number类型的null转成0 SerializerFeature.WriteNullNumberAsZero, // 将List类型的null转成[] SerializerFeature.WriteNullListAsEmpty, // 将Boolean类型的null转成false SerializerFeature.WriteNullBooleanAsFalse, // 避免循环引用 SerializerFeature.DisableCircularReferenceDetect); converter.setFastJsonConfig(config); converter.setDefaultCharset(Charset.forName(\"UTF-8\")); List&lt;MediaType&gt; mediaTypeList = new ArrayList&lt;&gt;(); // 解决中文乱码问题，相当于在Controller上的@RequestMapping中加了个属性produces = \"application/json\" mediaTypeList.add(MediaType.APPLICATION_JSON); converter.setSupportedMediaTypes(mediaTypeList); converters.add(converter); }} 3. 封装统一返回的数据结构以上是 Spring Boot 返回 json 的几个代表的例子，但是在实际项目中，除了要封装数据之外，我们往往需要在返回的 json 中添加一些其他信息，比如返回一些状态码 code ，返回一些 msg 给调用者，这样调用者可以根据 code 或者 msg 做一些逻辑判断。所以在实际项目中，我们需要封装一个统一的 json 返回结构存储返回信息。 3.1 定义统一的 json 结构由于封装的 json 数据的类型不确定，所以在定义统一的 json 结构时，我们需要用到泛型。统一的 json 结构中属性包括数据、状态码、提示信息即可，构造方法可以根据实际业务需求做相应的添加即可，一般来说，应该有默认的返回结构，也应该有用户指定的返回结构。如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class JsonResult&lt;T&gt; { private T data; private String code; private String msg; /** * 若没有数据返回，默认状态码为0，提示信息为：操作成功！ */ public JsonResult() { this.code = \"0\"; this.msg = \"操作成功！\"; } /** * 若没有数据返回，可以人为指定状态码和提示信息 * @param code * @param msg */ public JsonResult(String code, String msg) { this.code = code; this.msg = msg; } /** * 有数据返回时，状态码为0，默认提示信息为：操作成功！ * @param data */ public JsonResult(T data) { this.data = data; this.code = \"0\"; this.msg = \"操作成功！\"; } /** * 有数据返回，状态码为0，人为指定提示信息 * @param data * @param msg */ public JsonResult(T data, String msg) { this.data = data; this.code = \"0\"; this.msg = msg; } // 省略get和set方法} 3.2 修改 Controller 中的返回值类型及测试由于 JsonResult 使用了泛型，所以所有的返回值类型都可以使用该统一结构，在具体的场景将泛型替换成具体的数据类型即可，非常方便，也便于维护。在实际项目中，还可以继续封装，比如状态码和提示信息可以定义一个枚举类型，以后我们只需要维护这个枚举类型中的数据即可（在本课程中就不展开了）。根据以上的 JsonResult，我们改写一下 Controller，如下： 12345678910111213141516171819202122232425262728293031@RestController@RequestMapping(\"/jsonresult\")public class JsonResultController { @RequestMapping(\"/user\") public JsonResult&lt;User&gt; getUser() { User user = new User(1, \"倪升武\", \"123456\"); return new JsonResult&lt;&gt;(user); } @RequestMapping(\"/list\") public JsonResult&lt;List&gt; getUserList() { List&lt;User&gt; userList = new ArrayList&lt;&gt;(); User user1 = new User(1, \"倪升武\", \"123456\"); User user2 = new User(2, \"达人课\", \"123456\"); userList.add(user1); userList.add(user2); return new JsonResult&lt;&gt;(userList, \"获取用户列表成功\"); } @RequestMapping(\"/map\") public JsonResult&lt;Map&gt; getMap() { Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(3); User user = new User(1, \"倪升武\", null); map.put(\"作者信息\", user); map.put(\"博客地址\", \"http://blog.itcodai.com\"); map.put(\"CSDN地址\", null); map.put(\"粉丝数量\", 4153); return new JsonResult&lt;&gt;(map); }} 我们重新在浏览器中输入：localhost:8080/jsonresult/user 返回 json 如下： 1{\"code\":\"0\",\"data\":{\"id\":1,\"password\":\"123456\",\"username\":\"倪升武\"},\"msg\":\"操作成功！\"} 输入：localhost:8080/jsonresult/list，返回 json 如下： 1{\"code\":\"0\",\"data\":[{\"id\":1,\"password\":\"123456\",\"username\":\"倪升武\"},{\"id\":2,\"password\":\"123456\",\"username\":\"达人课\"}],\"msg\":\"获取用户列表成功\"} 输入：localhost:8080/jsonresult/map，返回 json 如下： 1{\"code\":\"0\",\"data\":{\"作者信息\":{\"id\":1,\"password\":\"\",\"username\":\"倪升武\"},\"CSDN地址\":null,\"粉丝数量\":4153,\"博客地址\":\"http://blog.itcodai.com\"},\"msg\":\"操作成功！\"} 通过封装，我们不但将数据通过 json 传给前端或者其他接口，还带上了状态码和提示信息，这在实际项目场景中应用非常广泛。 4. 总结本节主要对 Spring Boot 中 json 数据的返回做了详细的分析，从 Spring Boot 默认的 jackson 框架到阿里巴巴的 fastJson 框架，分别对它们的配置做了相应的讲解。另外，结合实际项目情况，总结了实际项目中使用的 json 封装结构体，加入了状态码和提示信息，使得返回的 json 数据信息更加完整。课程源代码下载地址：戳我下载 欢迎关注我的为微信公众号：武哥聊编程 第03课：Spring Boot使用slf4j进行日志记录在开发中，我们经常使用 System.out.println() 来打印一些信息，但是这样不好，因为大量的使用 System.out 会增加资源的消耗。我们实际项目中使用的是 slf4j 的 logback 来输出日志，效率挺高的，Spring Boot 提供了一套日志系统，logback 是最优的选择。 1. slf4j 介绍引用百度百科里的一段话： SLF4J，即简单日志门面（Simple Logging Facade for Java），不是具体的日志解决方案，它只服务于各种各样的日志系统。按照官方的说法，SLF4J是一个用于日志系统的简单Facade，允许最终用户在部署其应用时使用其所希望的日志系统。 这段的大概意思是：你只需要按统一的方式写记录日志的代码，而无需关心日志是通过哪个日志系统，以什么风格输出的。因为它们取决于部署项目时绑定的日志系统。例如，在项目中使用了 slf4j 记录日志，并且绑定了 log4j（即导入相应的依赖），则日志会以 log4j 的风格输出；后期需要改为以 logback 的风格输出日志，只需要将 log4j 替换成 logback 即可，不用修改项目中的代码。这对于第三方组件的引入的不同日志系统来说几乎零学习成本，况且它的优点不仅仅这一个而已，还有简洁的占位符的使用和日志级别的判断。 正因为 sfl4j 有如此多的优点，阿里巴巴已经将 slf4j 作为他们的日志框架了。在《阿里巴巴Java开发手册(正式版)》中，日志规约一项第一条就强制要求使用 slf4j： 1.【强制】应用中不可直接使用日志系统（Log4j、Logback）中的API，而应依赖使用日志框架SLF4J中的API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。 “强制”两个字体现出了 slf4j 的优势，所以建议在实际项目中，使用 slf4j 作为自己的日志框架。使用 slf4j 记录日志非常简单，直接使用 LoggerFactory 创建即可。 1234567import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class Test { private static final Logger logger = LoggerFactory.getLogger(Test.class); // ……} 2. application.yml 中对日志的配置Spring Boot 对 slf4j 支持的很好，内部已经集成了 slf4j，一般我们在使用的时候，会对slf4j 做一下配置。application.yml 文件是 Spring Boot 中唯一一个需要配置的文件，一开始创建工程的时候是 application.properties 文件，个人比较细化用 yml 文件，因为 yml 文件的层次感特别好，看起来更直观，但是 yml 文件对格式要求比较高，比如英文冒号后面必须要有个空格，否则项目估计无法启动，而且也不报错。用 properties 还是 yml 视个人习惯而定，都可以。本课程使用 yml。 我们看一下 application.yml 文件中对日志的配置： 1234logging: config: logback.xml level: com.itcodai.course03.dao: trace logging.config 是用来指定项目启动的时候，读取哪个配置文件，这里指定的是日志配置文件是根路径下的 logback.xml 文件，关于日志的相关配置信息，都放在 logback.xml 文件中了。logging.level 是用来指定具体的 mapper 中日志的输出级别，上面的配置表示 com.itcodai.course03.dao 包下的所有 mapper 日志输出级别为 trace，会将操作数据库的 sql 打印出来，开发时设置成 trace 方便定位问题，在生产环境上，将这个日志级别再设置成 error 级别即可（本节课不讨论 mapper 层，在后面 Spring Boot 集成 MyBatis 时再详细讨论）。 常用的日志级别按照从高到低依次为：ERROR、WARN、INFO、DEBUG。 3. logback.xml 配置文件解析在上面 application.yml 文件中，我们指定了日志配置文件 logback.xml，logback.xml 文件中主要用来做日志的相关配置。在 logback.xml 中，我们可以定义日志输出的格式、路径、控制台输出格式、文件大小、保存时长等等。下面来分析一下： 3.1 定义日志输出格式和存储路径1234&lt;configuration&gt; &lt;property name=\"LOG_PATTERN\" value=\"%date{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n\" /&gt; &lt;property name=\"FILE_PATH\" value=\"D:/logs/course03/demo.%d{yyyy-MM-dd}.%i.log\" /&gt;&lt;/configuration&gt; 我们来看一下这个定义的含义：首先定义一个格式，命名为 “LOG_PATTERN”，该格式中 %date 表示日期，%thread 表示线程名，%-5level 表示级别从左显示5个字符宽度，%logger{36} 表示 logger 名字最长36个字符，%msg 表示日志消息，%n 是换行符。 然后再定义一下名为 “FILE_PATH” 文件路径，日志都会存储在该路径下。%i 表示第 i 个文件，当日志文件达到指定大小时，会将日志生成到新的文件里，这里的 i 就是文件索引，日志文件允许的大小可以设置，下面会讲解。这里需要注意的是，不管是 windows 系统还是 Linux 系统，日志存储的路径必须要是绝对路径。 3.2 定义控制台输出12345678&lt;configuration&gt; &lt;appender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder&gt; &lt;!-- 按照上面配置的LOG_PATTERN来打印日志 --&gt; &lt;pattern&gt;${LOG_PATTERN}&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt;&lt;/configuration&gt; 使用 &lt;appender&gt; 节点设置个控制台输出（class=&quot;ch.qos.logback.core.ConsoleAppender&quot;）的配置，定义为 “CONSOLE”。使用上面定义好的输出格式（LOG_PATTERN）来输出，使用 ${} 引用进来即可。 3.3 定义日志文件的相关参数12345678910111213141516171819&lt;configuration&gt; &lt;appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!-- 按照上面配置的FILE_PATH路径来保存日志 --&gt; &lt;fileNamePattern&gt;${FILE_PATH}&lt;/fileNamePattern&gt; &lt;!-- 日志保存15天 --&gt; &lt;maxHistory&gt;15&lt;/maxHistory&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"&gt; &lt;!-- 单个日志文件的最大，超过则新建日志文件存储 --&gt; &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;!-- 按照上面配置的LOG_PATTERN来打印日志 --&gt; &lt;pattern&gt;${LOG_PATTERN}&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt;&lt;/configuration&gt; 使用 &lt;appender&gt; 定义一个名为 “FILE” 的文件配置，主要是配置日志文件保存的时间、单个日志文件存储的大小、以及文件保存的路径和日志的输出格式。 3.4 定义日志输出级别1234567&lt;configuration&gt; &lt;logger name=\"com.itcodai.course03\" level=\"INFO\" /&gt; &lt;root level=\"INFO\"&gt; &lt;appender-ref ref=\"CONSOLE\" /&gt; &lt;appender-ref ref=\"FILE\" /&gt; &lt;/root&gt;&lt;/configuration&gt; 有了上面那些定义后，最后我们使用 &lt;logger&gt; 来定义一下项目中默认的日志输出级别，这里定义级别为 INFO，然后针对 INFO 级别的日志，使用 &lt;root&gt; 引用上面定义好的控制台日志输出和日志文件的参数。这样 logback.xml 文件中的配置就设置完了。 4. 使用Logger在项目中打印日志在代码中，我们一般使用 Logger 对象来打印出一些 log 信息，可以指定打印出的日志级别，也支持占位符，很方便。 1234567891011121314151617181920212223242526import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping(\"/test\")public class TestController { private final static Logger logger = LoggerFactory.getLogger(TestController.class); @RequestMapping(\"/log\") public String testLog() { logger.debug(\"=====测试日志debug级别打印====\"); logger.info(\"======测试日志info级别打印=====\"); logger.error(\"=====测试日志error级别打印====\"); logger.warn(\"======测试日志warn级别打印=====\"); // 可以使用占位符打印出一些参数信息 String str1 = \"blog.itcodai.com\"; String str2 = \"blog.csdn.net/eson_15\"; logger.info(\"======倪升武的个人博客：{}；倪升武的CSDN博客：{}\", str1, str2); return \"success\"; }} 启动该项目，在浏览器中输入 localhost:8080/test/log 后可以看到控制台的日志记录： ======测试日志info级别打印==========测试日志error级别打印==========测试日志warn级别打印===========倪升武的个人博客：blog.itcodai.com；倪升武的CSDN博客：blog.csdn.net/eson_15 因为 INFO 级别比 DEBUG 级别高，所以 debug 这条没有打印出来，如果将 logback.xml 中的日志级别设置成 DEBUG，那么四条语句都会打印出来，这个大家自己去测试了。同时可以打开 D:\\logs\\course03\\ 目录，里面有刚刚项目启动，以后后面生成的所有日志记录。在项目部署后，我们大部分都是通过查看日志文件来定位问题。 5. 总结本节课主要对 slf4j 做了一个简单的介绍，并且对 Spring Boot 中如何使用 slf4j 输出日志做了详细的说明，着重分析了 logback.xml 文件中对日志相关信息的配置，包括日志的不同级别。最后针对这些配置，在代码中使用 Logger 打印出一些进行测试。在实际项目中，这些日志都是排查问题的过程中非常重要的资料。课程源代码下载地址：戳我下载 欢迎关注我的为微信公众号：武哥聊编程 第04课：Spring Boot中的项目属性配置我们知道，在项目中，很多时候需要用到一些配置的信息，这些信息可能在测试环境和生产环境下会有不同的配置，后面根据实际业务情况有可能还会做修改，针对这种情况，我们不能将这些配置在代码中写死，最好就是写到配置文件中。比如可以把这些信息写到 application.yml 文件中。 1. 少量配置信息的情形举个例子，在微服务架构中，最常见的就是某个服务需要调用其他服务来获取其提供的相关信息，那么在该服务的配置文件中需要配置被调用的服务地址，比如在当前服务里，我们需要调用订单微服务获取订单相关的信息，假设 订单服务的端口号是 8002，那我们可以做如下配置： 1234567server: port: 8001# 配置微服务的地址url: # 订单微服务的地址 orderUrl: http://localhost:8002 然后在业务代码中如何获取到这个配置的订单服务地址呢？我们可以使用 @Value 注解来解决。在对应的类中加上一个属性，在属性上使用 @Value 注解即可获取到配置文件中的配置信息，如下： 123456789101112131415161718192021import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping(\"/test\")public class ConfigController { private static final Logger LOGGER = LoggerFactory.getLogger(ConfigController.class); @Value(\"${url.orderUrl}\") private String orderUrl; @RequestMapping(\"/config\") public String testConfig() { LOGGER.info(\"=====获取的订单服务地址为：{}\", orderUrl); return \"success\"; }} @Value 注解上通过 ${key} 即可获取配置文件中和 key 对应的 value 值。我们启动一下项目，在浏览器中输入 localhost:8080/test/config 请求服务后，可以看到控制台会打印出订单服务的地址： 1=====获取的订单服务地址为：http://localhost:8002 说明我们成功获取到了配置文件中的订单微服务地址，在实际项目中也是这么用的，后面如果因为服务器部署的原因，需要修改某个服务的地址，那么只要在配置文件中修改即可。 2. 多个配置信息的情形这里再引申一个问题，随着业务复杂度的增加，一个项目中可能会有越来越多的微服务，某个模块可能需要调用多个微服务获取不同的信息，那么就需要在配置文件中配置多个微服务的地址。可是，在需要调用这些微服务的代码中，如果这样一个个去使用 @Value 注解引入相应的微服务地址的话，太过于繁琐，也不科学。 所以，在实际项目中，业务繁琐，逻辑复杂的情况下，需要考虑封装一个或多个配置类。举个例子：假如在当前服务中，某个业务需要同时调用订单微服务、用户微服务和购物车微服务，分别获取订单、用户和购物车相关信息，然后对这些信息做一定的逻辑处理。那么在配置文件中，我们需要将这些微服务的地址都配置好： 12345678# 配置多个微服务的地址url: # 订单微服务的地址 orderUrl: http://localhost:8002 # 用户微服务的地址 userUrl: http://localhost:8003 # 购物车微服务的地址 shoppingUrl: http://localhost:8004 也许实际业务中，远远不止这三个微服务，甚至十几个都有可能。对于这种情况，我们可以先定义一个 MicroServiceUrl 类来专门保存微服务的 url，如下： 123456789@Component@ConfigurationProperties(prefix = \"url\")public class MicroServiceUrl { private String orderUrl; private String userUrl; private String shoppingUrl; // 省去get和set方法} 细心的朋友应该可以看到，使用 @ConfigurationProperties 注解并且使用 prefix 来指定一个前缀，然后该类中的属性名就是配置中去掉前缀后的名字，一一对应即可。即：前缀名 + 属性名就是配置文件中定义的 key。同时，该类上面需要加上 @Component 注解，把该类作为组件放到Spring容器中，让 Spring 去管理，我们使用的时候直接注入即可。 需要注意的是，使用 @ConfigurationProperties 注解需要导入它的依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; OK，到此为止，我们将配置写好了，接下来写个 Controller 来测试一下。此时，不需要在代码中一个个引入这些微服务的 url 了，直接通过 @Resource 注解将刚刚写好配置类注入进来即可使用了，非常方便。如下： 123456789101112131415161718@RestController@RequestMapping(\"/test\")public class TestController { private static final Logger LOGGER = LoggerFactory.getLogger(TestController.class); @Resource private MicroServiceUrl microServiceUrl; @RequestMapping(\"/config\") public String testConfig() { LOGGER.info(\"=====获取的订单服务地址为：{}\", microServiceUrl.getOrderUrl()); LOGGER.info(\"=====获取的用户服务地址为：{}\", microServiceUrl.getUserUrl()); LOGGER.info(\"=====获取的购物车服务地址为：{}\", microServiceUrl.getShoppingUrl()); return \"success\"; }} 再次启动项目，请求一下可以看到，控制台打印出如下信息，说明配置文件生效，同时正确获取配置文件内容： 1234=====获取的订单服务地址为：http://localhost:8002=====获取的订单服务地址为：http://localhost:8002=====获取的用户服务地址为：http://localhost:8003=====获取的购物车服务地址为：http://localhost:8004 3. 指定项目配置文件我们知道，在实际项目中，一般有两个环境：开发环境和生产环境。开发环境中的配置和生产环境中的配置往往不同，比如：环境、端口、数据库、相关地址等等。我们不可能在开发环境调试好之后，部署到生产环境后，又要将配置信息全部修改成生产环境上的配置，这样太麻烦，也不科学。 最好的解决方法就是开发环境和生产环境都有一套对用的配置信息，然后当我们在开发时，指定读取开发环境的配置，当我们将项目部署到服务器上之后，再指定去读取生产环境的配置。 我们新建两个配置文件： application-dev.yml 和 application-pro.yml，分别用来对开发环境和生产环境进行相关配置。这里为了方便，我们分别设置两个访问端口号，开发环境用 8001，生产环境用 8002. 123# 开发环境配置文件server: port: 8001 123# 开发环境配置文件server: port: 8002 然后在 application.yml 文件中指定读取哪个配置文件即可。比如我们在开发环境下，指定读取 applicationn-dev.yml 文件，如下： 1234spring: profiles: active: - dev 这样就可以在开发的时候，指定读取 application-dev.yml 文件，访问的时候使用 8001 端口，部署到服务器后，只需要将 application.yml 中指定的文件改成 application-pro.yml 即可，然后使用 8002 端口访问，非常方便。 4. 总结本节课主要讲解了 Spring Boot 中如何在业务代码中读取相关配置，包括单一配置和多个配置项，在微服务中，这种情况非常常见，往往会有很多其他微服务需要调用，所以封装一个配置类来接收这些配置是个很好的处理方式。除此之外，例如数据库相关的连接参数等等，也可以放到一个配置类中，其他遇到类似的场景，都可以这么处理。最后介绍了开发环境和生产环境配置的快速切换方式，省去了项目部署时，诸多配置信息的修改。课程源代码下载地址：戳我下载 欢迎关注我的为微信公众号：武哥聊编程 第05课：Spring Boot中的MVC支持Spring Boot 的 MVC 支持主要来介绍实际项目中最常用的几个注解，包括 @RestController、 @RequestMapping、@PathVariable、@RequestParam 以及 @RequestBody。主要介绍这几个注解常用的使用方式和特点。 1. @RestController@RestController 是 Spring Boot 新增的一个注解，我们看一下该注解都包含了哪些东西。 12345678@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Controller@ResponseBodypublic @interface RestController { String value() default \"\";} 可以看出， @RestController 注解包含了原来的 @Controller 和 @ResponseBody 注解，使用过 Spring 的朋友对 @Controller 注解已经非常了解了，这里不再赘述， @ResponseBody 注解是将返回的数据结构转换为 Json 格式。所以 @RestController 可以看作是 @Controller 和 @ResponseBody 的结合体，相当于偷个懒，我们使用 @RestController 之后就不用再使用 @Controller 了。但是需要注意一个问题：如果是前后端分离，不用模板渲染的话，比如 Thymeleaf，这种情况下是可以直接使用@RestController 将数据以 json 格式传给前端，前端拿到之后解析；但如果不是前后端分离，需要使用模板来渲染的话，一般 Controller 中都会返回到具体的页面，那么此时就不能使用@RestController了，比如： 123public String getUser() { return \"user\";} 其实是需要返回到 user.html 页面的，如果使用 @RestController 的话，会将 user 作为字符串返回的，所以这时候我们需要使用 @Controller 注解。这在下一节 Spring Boot 集成 Thymeleaf 模板引擎中会再说明。 2. @RequestMapping@RequestMapping 是一个用来处理请求地址映射的注解，它可以用于类上，也可以用于方法上。在类的级别上的注解会将一个特定请求或者请求模式映射到一个控制器之上，表示类中的所有响应请求的方法都是以该地址作为父路径；在方法的级别表示进一步指定到处理方法的映射关系。 该注解有6个属性，一般在项目中比较常用的有三个属性：value、method 和 produces。 value 属性：指定请求的实际地址，value 可以省略不写 method 属性：指定请求的类型，主要有 GET、PUT、POST、DELETE，默认为 GET produces属性：指定返回内容类型，如 produces = “application/json; charset=UTF-8” @RequestMapping 注解比较简单，举个例子： 123456789@RestController@RequestMapping(value = \"/test\", produces = \"application/json; charset=UTF-8\")public class TestController { @RequestMapping(value = \"/get\", method = RequestMethod.GET) public String testGet() { return \"success\"; }} 这个很简单，启动项目在浏览器中输入 localhost:8080/test/get 测试一下即可。 针对四种不同的请求方式，是有相应注解的，不用每次在 @RequestMapping 注解中加 method 属性来指定，上面的 GET 方式请求可以直接使用 @GetMapping(&quot;/get&quot;) 注解，效果一样。相应地，PUT 方式、POST 方式和 DELETE 方式对应的注解分别为 @PutMapping、@PostMapping 和 DeleteMapping。 3. @PathVariable@PathVariable 注解主要是用来获取 url 参数，Spring Boot 支持 restfull 风格的 url，比如一个 GET 请求携带一个参数 id 过来，我们将 id 作为参数接收，可以使用 @PathVariable 注解。如下： 12345@GetMapping(\"/user/{id}\")public String testPathVariable(@PathVariable Integer id) { System.out.println(\"获取到的id为：\" + id); return \"success\";} 这里需要注意一个问题，如果想要 url 中占位符中的 id 值直接赋值到参数 id 中，需要保证 url 中的参数和方法接收参数一致，否则就无法接收。如果不一致的话，其实也可以解决，需要用 @PathVariable 中的 value 属性来指定对应关系。如下： 12345@RequestMapping(\"/user/{idd}\")public String testPathVariable(@PathVariable(value = \"idd\") Integer id) { System.out.println(\"获取到的id为：\" + id); return \"success\";} 对于访问的 url，占位符的位置可以在任何位置，不一定非要在最后，比如这样也行：/xxx/{id}/user。另外，url 也支持多个占位符，方法参数使用同样数量的参数来接收，原理和一个参数是一样的，例如： 123456@GetMapping(\"/user/{idd}/{name}\") public String testPathVariable(@PathVariable(value = \"idd\") Integer id, @PathVariable String name) { System.out.println(\"获取到的id为：\" + id); System.out.println(\"获取到的name为：\" + name); return \"success\"; } 运行项目，在浏览器中请求 localhost:8080/test/user/2/zhangsan 可以看到控制台输出如下信息： 12获取到的id为：2获取到的name为：zhangsan 所以支持多个参数的接收。同样地，如果 url 中的参数和方法中的参数名称不同的话，也需要使用 value 属性来绑定两个参数。 4. @RequestParam@RequestParam 注解顾名思义，也是获取请求参数的，上面我们介绍了 @PathValiable 注解也是获取请求参数的，那么 @RequestParam 和 @PathVariable 有什么不同呢？主要区别在于： @PathValiable 是从 url 模板中获取参数值， 即这种风格的 url：http://localhost:8080/user/{id} ；而 @RequestParam 是从 request 里面获取参数值，即这种风格的 url：http://localhost:8080/user?id=1 。我们使用该 url 带上参数 id 来测试一下如下代码： 12345@GetMapping(\"/user\")public String testRequestParam(@RequestParam Integer id) { System.out.println(\"获取到的id为：\" + id); return \"success\";} 可以正常从控制台打印出 id 信息。同样地，url 上面的参数和方法的参数需要一致，如果不一致，也需要使用 value 属性来说明，比如 url 为：http://localhost:8080/user?idd=1 12345@RequestMapping(\"/user\")public String testRequestParam(@RequestParam(value = \"idd\", required = false) Integer id) { System.out.println(\"获取到的id为：\" + id); return \"success\";} 除了 value 属性外，还有个两个属性比较常用： required 属性：true 表示该参数必须要传，否则就会报 404 错误，false 表示可有可无。 defaultValue 属性：默认值，表示如果请求中没有同名参数时的默认值。 从 url 中可以看出，@RequestParam 注解用于 GET 请求上时，接收拼接在 url 中的参数。除此之外，该注解还可以用于 POST 请求，接收前端表单提交的参数，假如前端通过表单提交 username 和 password 两个参数，那我们可以使用 @RequestParam 来接收，用法和上面一样。 123456@PostMapping(\"/form1\") public String testForm(@RequestParam String username, @RequestParam String password) { System.out.println(\"获取到的username为：\" + username); System.out.println(\"获取到的password为：\" + password); return \"success\"; } 我们使用 postman 来模拟一下表单提交，测试一下接口： 那么问题来了，如果表单数据很多，我们不可能在后台方法中写上很多参数，每个参数还要 @RequestParam 注解。针对这种情况，我们需要封装一个实体类来接收这些参数，实体中的属性名和表单中的参数名一致即可。 12345public class User { private String username; private String password; // set get} 使用实体接收的话，我们不能在前面加 @RequestParam 注解了，直接使用即可。 123456@PostMapping(\"/form2\") public String testForm(User user) { System.out.println(\"获取到的username为：\" + user.getUsername()); System.out.println(\"获取到的password为：\" + user.getPassword()); return \"success\"; } 使用 postman 再次测试一下表单提交，观察一下返回值和控制台打印出的日志即可。在实际项目中，一般都是封装一个实体类来接收表单数据，因为实际项目中表单数据一般都很多。 5. @RequestBody@RequestBody 注解用于接收前端传来的实体，接收参数也是对应的实体，比如前端通过 json 提交传来两个参数 username 和 password，此时我们需要在后端封装一个实体来接收。在传递的参数比较多的情况下，使用 @RequestBody 接收会非常方便。例如： 12345public class User { private String username; private String password; // set get} 123456@PostMapping(\"/user\")public String testRequestBody(@RequestBody User user) { System.out.println(\"获取到的username为：\" + user.getUsername()); System.out.println(\"获取到的password为：\" + user.getPassword()); return \"success\";} 我们使用 postman 工具来测试一下效果，打开 postman，然后输入请求地址和参数，参数我们用 json 来模拟，如下图所有，调用之后返回 success。 同时看一下后台控制台输出的日志： 12获取到的username为：倪升武获取到的password为：123456 可以看出，@RequestBody 注解用于 POST 请求上，接收 json 实体参数。它和上面我们介绍的表单提交有点类似，只不过参数的格式不同，一个是 json 实体，一个是表单提交。在实际项目中根据具体场景和需要使用对应的注解即可。 6. 总结本节课主要讲解了 Spring Boot 中对 MVC 的支持，分析了 @RestController、 @RequestMapping、@PathVariable、 @RequestParam 和 @RequestBody 四个注解的使用方式，由于 @RestController 中集成了 @ResponseBody 所以对返回 json 的注解不再赘述。以上四个注解是使用频率很高的注解，在所有的实际项目中基本都会遇到，要熟练掌握。 课程源代码下载地址：戳我下载 欢迎关注我的为微信公众号：武哥聊编程 第06课：Spring Boot集成 Swagger2 展现在线接口文档1. Swagger 简介1.1 解决的问题随着互联网技术的发展，现在的网站架构基本都由原来的后端渲染，变成了前后端分离的形态，而且前端技术和后端技术在各自的道路上越走越远。前端和后端的唯一联系，变成了 API 接口，所以 API 文档变成了前后端开发人员联系的纽带，变得越来越重要。 那么问题来了，随着代码的不断更新，开发人员在开发新的接口或者更新旧的接口后，由于开发任务的繁重，往往文档很难持续跟着更新，Swagger 就是用来解决该问题的一款重要的工具，对使用接口的人来说，开发人员不需要给他们提供文档，只要告诉他们一个 Swagger 地址，即可展示在线的 API 接口文档，除此之外，调用接口的人员还可以在线测试接口数据，同样地，开发人员在开发接口时，同样也可以利用 Swagger 在线接口文档测试接口数据，这给开发人员提供了便利。 1.2 Swagger 官方我们打开 Swagger 官网，官方对 Swagger 的定义为： The Best APIs are Built with Swagger Tools 翻译成中文是：“最好的 API 是使用 Swagger 工具构建的”。由此可见，Swagger 官方对其功能和所处的地位非常自信，由于其非常好用，所以官方对其定位也合情合理。如下图所示： 本文主要讲解在 Spring Boot 中如何导入 Swagger2 工具来展现项目中的接口文档。本节课使用的 Swagger 版本为 2.2.2。下面开始进入 Swagger2 之旅。 2. Swagger2 的 maven 依赖使用 Swagger2 工具，必须要导入 maven 依赖，当前官方最高版本是 2.8.0，我尝试了一下，个人感觉页面展示的效果不太好，而且不够紧凑，不利于操作。另外，最新版本并不一定是最稳定版本，当前我们实际项目中使用的是 2.2.2 版本，该版本稳定，界面友好，所以本节课主要围绕着 2.2.2 版本来展开，依赖如下： 12345678910&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt; 3. Swagger2 的配置使用 Swagger2 需要进行配置，Spring Boot 中对 Swagger2 的配置非常方便，新建一个配置类，Swagger2 的配置类上除了添加必要的 @Configuration 注解外，还需要添加 @EnableSwagger2 注解。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;/** * @author shengwu ni */@Configuration@EnableSwagger2public class SwaggerConfig { @Bean public Docket createRestApi() { return new Docket(DocumentationType.SWAGGER_2) // 指定构建api文档的详细信息的方法：apiInfo() .apiInfo(apiInfo()) .select() // 指定要生成api接口的包路径，这里把controller作为包路径，生成controller中的所有接口 .apis(RequestHandlerSelectors.basePackage(\"com.itcodai.course06.controller\")) .paths(PathSelectors.any()) .build(); } /** * 构建api文档的详细信息 * @return */ private ApiInfo apiInfo() { return new ApiInfoBuilder() // 设置页面标题 .title(\"Spring Boot集成Swagger2接口总览\") // 设置接口描述 .description(\"跟武哥一起学Spring Boot第06课\") // 设置联系方式 .contact(\"倪升武，\" + \"CSDN：http://blog.csdn.net/eson_15\") // 设置版本 .version(\"1.0\") // 构建 .build(); }} 在该配置类中，已经使用注释详细解释了每个方法的作用了，在此不再赘述。到此为止，我们已经配置好了 Swagger2 了。现在我们可以测试一下配置有没有生效，启动项目，在浏览器中输入 localhost:8080/swagger-ui.html，即可看到 swagger2 的接口页面，如下图所示，说明Swagger2 集成成功。 结合该图，对照上面的 Swagger2 配置文件中的配置，可以很明确的知道配置类中每个方法的作用。这样就很容易理解和掌握 Swagger2 中的配置了，也可以看出，其实 Swagger2 配置很简单。 【友情提示】可能有很多朋友在配置 Swagger 的时候会遇到下面的情况，而且还关不掉的，这是因为浏览器缓存引起的，清空一下浏览器缓存即可解决问题。 4. Swagger2 的使用上面我们已经配置好了 Swagger2，并且也启动测试了一下，功能正常，下面我们开始使用 Swagger2，主要来介绍 Swagger2 中的几个常用的注解，分别在实体类上、 Controller 类上以及 Controller 中的方法上，最后我们看一下 Swagger2 是如何在页面上呈现在线接口文档的，并且结合 Controller 中的方法在接口中测试一下数据。 4.1 实体类注解本节我们建一个 User 实体类，主要介绍一下 Swagger2 中的 @ApiModel 和 @ApiModelProperty 注解，同时为后面的测试做准备。 1234567891011121314151617import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;@ApiModel(value = \"用户实体类\")public class User { @ApiModelProperty(value = \"用户唯一标识\") private Long id; @ApiModelProperty(value = \"用户姓名\") private String username; @ApiModelProperty(value = \"用户密码\") private String password; // 省略set和get方法} 解释下 @ApiModel 和 @ApiModelProperty 注解： @ApiModel 注解用于实体类，表示对类进行说明，用于参数用实体类接收。@ApiModelProperty 注解用于类中属性，表示对 model 属性的说明或者数据操作更改。 该注解在在线 API 文档中的具体效果在下文说明。 4.2 Controller 类中相关注解我们写一个 TestController，再写几个接口，然后学习一下 Controller 中和 Swagger2 相关的注解。 1234567891011121314151617181920212223import com.itcodai.course06.entiy.JsonResult;import com.itcodai.course06.entiy.User;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import io.swagger.annotations.ApiParam;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping(\"/swagger\")@Api(value = \"Swagger2 在线接口文档\")public class TestController { @GetMapping(\"/get/{id}\") @ApiOperation(value = \"根据用户唯一标识获取用户信息\") public JsonResult&lt;User&gt; getUserInfo(@PathVariable @ApiParam(value = \"用户唯一标识\") Long id) { // 模拟数据库中根据id获取User信息 User user = new User(id, \"倪升武\", \"123456\"); return new JsonResult(user); }} 我们来学习一下 @Api 、 @ApiOperation 和 @ApiParam 注解。 @Api 注解用于类上，表示标识这个类是 swagger 的资源。@ApiOperation 注解用于方法，表示一个 http 请求的操作。@ApiParam 注解用于参数上，用来标明参数信息。 这里返回的是 JsonResult，是第02课中学习返回 json 数据时封装的实体。以上是 Swagger 中最常用的 5 个注解，接下来运行一下项目工程，在浏览器中输入 localhost:8080/swagger-ui.html 看一下 Swagger 页面的接口状态。 可以看出，Swagger 页面对该接口的信息展示的非常全面，每个注解的作用以及展示的地方在上图中已经标明，通过页面即可知道该接口的所有信息，那么我们直接在线测试一下该接口返回的信息，输入id为1，看一下返回数据： 可以看出，直接在页面返回了 json 格式的数据，开发人员可以直接使用该在线接口来测试数据的正确与否，非常方便。上面是对于单个参数的输入，如果输入参数为某个对象这种情况，Swagger 是什么样子呢？我们再写一个接口。 123456@PostMapping(\"/insert\") @ApiOperation(value = \"添加用户信息\") public JsonResult&lt;Void&gt; insertUser(@RequestBody @ApiParam(value = \"用户信息\") User user) { // 处理添加逻辑 return new JsonResult&lt;&gt;(); } 重启项目，在浏览器中输入 localhost:8080/swagger-ui.html 看一下效果： 5. 总结OK，本节课详细分析了 Swagger 的优点，以及 Spring Boot 如何集成 Swagger2，包括配置，相关注解的讲解，涉及到了实体类和接口类，以及如何使用。最后通过页面测试，体验了 Swagger 的强大之处，基本上是每个项目组中必备的工具之一，所以要掌握该工具的使用，也不难。 课程源代码下载地址：戳我下载 欢迎关注我的为微信公众号：武哥聊编程 第07课：Spring Boot集成Thymeleaf模板引擎1. Thymeleaf 介绍 Thymeleaf 是适用于 Web 和独立环境的现代服务器端 Java 模板引擎。Thymeleaf 的主要目标是为您的开发工作流程带来优雅的自然模板 - 可以在浏览器中正确显示的HTML，也可以用作静态原型，从而在开发团队中实现更强大的协作。 以上翻译自 Thymeleaf 官方网站。传统的 JSP+JSTL 组合是已经过去了，Thymeleaf 是现代服务端的模板引擎，与传统的 JSP 不同，Thymeleaf 可以使用浏览器直接打开，因为可以忽略掉拓展属性，相当于打开原生页面，给前端人员也带来一定的便利。 什么意思呢？就是说在本地环境或者有网络的环境下，Thymeleaf 均可运行。由于 thymeleaf 支持 html 原型，也支持在 html 标签里增加额外的属性来达到 “模板+数据” 的展示方式，所以美工可以直接在浏览器中查看页面效果，当服务启动后，也可以让后台开发人员查看带数据的动态页面效果。比如： 1234&lt;div class=\"ui right aligned basic segment\"&gt; &lt;div class=\"ui orange basic label\" th:text=\"${blog.flag}\"&gt;静态原创信息&lt;/div&gt;&lt;/div&gt;&lt;h2 class=\"ui center aligned header\" th:text=\"${blog.title}\"&gt;这是静态标题&lt;/h2&gt; 类似与上面这样，在静态页面时，会展示静态信息，当服务启动后，动态获取数据库中的数据后，就可以展示动态数据，th:text 标签是用来动态替换文本的，这会在下文说明。该例子说明浏览器解释 html 时会忽略 html 中未定义的标签属性（比如 th:text），所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示数据。 2. 依赖导入在 Spring Boot 中使用 thymeleaf 模板需要引入依赖，可以在创建项目工程时勾选 Thymeleaf，也可以创建之后再手动导入，如下： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 另外，在 html 页面上如果要使用 thymeleaf 模板，需要在页面标签中引入： 1&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt; 3. Thymeleaf相关配置因为 Thymeleaf 中已经有默认的配置了，我们不需要再对其做过多的配置，有一个需要注意一下，Thymeleaf 默认是开启页面缓存的，所以在开发的时候，需要关闭这个页面缓存，配置如下。 123spring: thymeleaf: cache: false #关闭缓存 否则会有缓存，导致页面没法及时看到更新后的效果。 比如你修改了一个文件，已经 update 到 tomcat 了，但刷新页面还是之前的页面，就是因为缓存引起的。 4. Thymeleaf 的使用4.1 访问静态页面这个和 Thymeleaf 没啥关系，应该说是通用的，我把它一并写到这里的原因是一般我们做网站的时候，都会做一个 404 页面和 500 页面，为了出错时给用户一个友好的展示，而不至于一堆异常信息抛出来。Spring Boot 中会自动识别模板目录（templates/）下的 404.html 和 500.html 文件。我们在 templates/ 目录下新建一个 error 文件夹，专门放置错误的 html 页面，然后分别打印些信息。以 404.html 为例： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 这是404页面&lt;/body&gt;&lt;/html&gt; 我们再写一个 controller 来测试一下 404 和 500 页面： 123456789101112131415@Controller@RequestMapping(\"/thymeleaf\")public class ThymeleafController { @RequestMapping(\"/test404\") public String test404() { return \"index\"; } @RequestMapping(\"/test500\") public String test500() { int i = 1 / 0; return \"index\"; }} 当我们在浏览器中输入 localhost:8080/thymeleaf/test400 时，故意输入错误，找不到对应的方法，就会跳转到 404.html 显示。当我们在浏览器中输入 localhost:8088/thymeleaf/test505 时，会抛出异常，然后会自动跳转到 500.html 显示。 【注】这里有个问题需要注意一下，前面的课程中我们说了微服务中会走向前后端分离，我们在 Controller 层上都是使用的 @RestController 注解，自动会把返回的数据转成 json 格式。但是在使用模板引擎时，Controller 层就不能用 @RestController 注解了，因为在使用 thymeleaf 模板时，返回的是视图文件名，比如上面的 Controller 中是返回到 index.html 页面，如果使用 @RestController 的话，会把 index 当作 String 解析了，直接返回到页面了，而不是去找 index.html 页面，大家可以试一下。所以在使用模板时要用 @Controller 注解。 4.2 Thymeleaf 中处理对象我们来看一下 thymeleaf 模板中如何处理对象信息，假如我们在做个人博客的时候，需要给前端传博主相关信息来展示，那么我们会封装成一个博主对象，比如： 123456public class Blogger { private Long id; private String name; private String pass; // 省去set和get} 然后在controller层中初始化一下： 123456@GetMapping(\"/getBlogger\")public String getBlogger(Model model) { Blogger blogger = new Blogger(1L, \"倪升武\", \"123456\"); model.addAttribute(\"blogger\", blogger); return \"blogger\";} 我们先初始化一个 Blogger 对象，然后将该对象放到 Model 中，然后返回到 blogger.html 页面去渲染。接下来我们再写一个 blogger.html 来渲染 blogger 信息： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;博主信息&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"\" th:object=\"${blogger}\" &gt; 用户编号：&lt;input name=\"id\" th:value=\"${blogger.id}\"/&gt;&lt;br&gt; 用户姓名：&lt;input type=\"text\" name=\"username\" th:value=\"${blogger.getName()}\" /&gt;&lt;br&gt; 登陆密码：&lt;input type=\"text\" name=\"password\" th:value=\"*{pass}\" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 可以看出，在 thymeleaf 模板中，使用 th:object=&quot;${}&quot; 来获取对象信息，然后在表单里面可以有三种方式来获取对象属性。如下： 使用 th:value=&quot;*{属性名}&quot;使用 th:value=&quot;${对象.属性名}&quot;，对象指的是上面使用 th:object 获取的对象使用 th:value=&quot;${对象.get方法}&quot;，对象指的是上面使用 th:object 获取的对象 可以看出，在 Thymeleaf 中可以像写 java 一样写代码，很方便。我们在浏览器中输入 localhost:8080/thymeleaf/getBlogger 来测试一下数据： 4.3 Thymeleaf 中处理 List处理 List 的话，和处理上面介绍的对象差不多，但是需要在 thymeleaf 中进行遍历。我们先在 Controller 中模拟一个 List。 12345678910@GetMapping(\"/getList\")public String getList(Model model) { Blogger blogger1 = new Blogger(1L, \"倪升武\", \"123456\"); Blogger blogger2 = new Blogger(2L, \"达人课\", \"123456\"); List&lt;Blogger&gt; list = new ArrayList&lt;&gt;(); list.add(blogger1); list.add(blogger2); model.addAttribute(\"list\", list); return \"list\";} 接下来我们写一个 list.html 来获取该 list 信息，然后在 list.html 中遍历这个list。如下： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;博主信息&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"\" th:each=\"blogger : ${list}\" &gt; 用户编号：&lt;input name=\"id\" th:value=\"${blogger.id}\"/&gt;&lt;br&gt; 用户姓名：&lt;input type=\"text\" name=\"password\" th:value=\"${blogger.name}\"/&gt;&lt;br&gt; 登录密码：&lt;input type=\"text\" name=\"username\" th:value=\"${blogger.getPass()}\"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 可以看出，其实和处理单个对象信息差不多，Thymeleaf 使用 th:each 进行遍历，${} 取 model 中传过来的参数，然后自定义 list 中取出来的每个对象，这里定义为 blogger。表单里面可以直接使用 ${对象.属性名} 来获取 list 中对象的属性值，也可以使用 ${对象.get方法} 来获取，这点和上面处理对象信息是一样的，但是不能使用 *{属性名} 来获取对象中的属性，thymeleaf 模板获取不到。 4.4 其他常用 thymeleaf 操作我们来总结一下 thymeleaf 中的一些常用的标签操作，如下： 标签 功能 例子 th:value 给属性赋值 &lt;input th:value=&quot;${blog.name}&quot; /&gt; th:style 设置样式 th:style=&quot;'display:'+@{(${sitrue}?'none':'inline-block')} + ''&quot; th:onclick 点击事件 th:onclick=&quot;'getInfo()'&quot; th:if 条件判断 &lt;a th:if=&quot;${userId == collect.userId}&quot; &gt; th:href 超链接 &lt;a th:href=&quot;@{/blogger/login}&quot;&gt;Login&lt;/a&gt; /&gt; th:unless 条件判断和th:if相反 &lt;a th:href=&quot;@{/blogger/login}&quot; th:unless=${session.user != null}&gt;Login&lt;/a&gt; th:switch 配合th:case &lt;div th:switch=&quot;${user.role}&quot;&gt; th:case 配合th:switch &lt;p th:case=&quot;'admin'&quot;&gt;administator&lt;/p&gt; th:src 地址引入 &lt;img alt=&quot;csdn logo&quot; th:src=&quot;@{/img/logo.png}&quot; /&gt; th:action 表单提交的地址 &lt;form th:action=&quot;@{/blogger/update}&quot;&gt; Thymeleaf 还有很多其他用法，这里就不总结了，具体的可以参考Thymeleaf的官方文档（v3.0）。主要要学会如何在 Spring Boot 中去使用 thymeleaf，遇到对应的标签或者方法，查阅官方文档即可。 5. 总结Thymeleaf 在 Spring Boot 中使用非常广泛，本节课主要分析了 thymeleaf 的优点，以及如何在 Spring Boot 中集成并使用 thymeleaf 模板，包括依赖、配置，相关数据的获取、以及一些注意事项等等。最后列举了一些 thymeleaf 中常用的标签，在实际项目中多使用，多查阅就能熟练掌握，thymeleaf 中的一些标签或者方法不用死记硬背，用到什么去查阅什么，关键是要会在 Spring Boot 中集成，用的多了就熟能生巧。 课程源代码下载地址：戳我下载 欢迎关注我的为微信公众号：武哥聊编程 第08课：Spring Boot中的全局异常处理在项目开发过程中，不管是对底层数据库的操作过程，还是业务层的处理过程，还是控制层的处理过程，都不可避免会遇到各种可预知的、不可预知的异常需要处理。如果对每个过程都单独作异常处理，那系统的代码耦合度会变得很高，此外，开发工作量也会加大而且不好统一，这也增加了代码的维护成本。针对这种实际情况，我们需要将所有类型的异常处理从各处理过程解耦出来，这样既保证了相关处理过程的功能单一，也实现了异常信息的统一处理和维护。同时，我们也不希望直接把异常抛给用户，应该对异常进行处理，对错误信息进行封装，然后返回一个友好的信息给用户。这节主要总结一下项目中如何使用 Spring Boot 如何拦截并处理全局的异常。 1. 定义返回的统一 json 结构前端或者其他服务请求本服务的接口时，该接口需要返回对应的 json 数据，一般该服务只需要返回请求着需要的参数即可，但是在实际项目中，我们需要封装更多的信息，比如状态码 code、相关信息 msg 等等，这一方面是在项目中可以有个统一的返回结构，整个项目组都适用，另一方面是方便结合全局异常处理信息，因为异常处理信息中一般我们需要把状态码和异常内容反馈给调用方。这个统一的 json 结构这可以参考第02课：Spring Boot 返回 JSON 数据及数据封装中封装的统一 json 结构，本节内容我们简化一下，只保留状态码 code 和异常信息 msg即可。如下： 12345678910111213141516171819202122public class JsonResult { /** * 异常码 */ protected String code; /** * 异常信息 */ protected String msg; public JsonResult() { this.code = \"200\"; this.msg = \"操作成功\"; } public JsonResult(String code, String msg) { this.code = code; this.msg = msg; } // get set} 2. 处理系统异常新建一个 GlobalExceptionHandler 全局异常处理类，然后加上 @ControllerAdvice 注解即可拦截项目中抛出的异常，如下： 1234567@ControllerAdvice@ResponseBodypublic class GlobalExceptionHandler { // 打印log private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class); // ……} 我们点开 @ControllerAdvice 注解可以看到，@ControllerAdvice 注解包含了 @Component 注解，说明在 Spring Boot 启动时，也会把该类作为组件交给 Spring 来管理。除此之外，该注解还有个 basePackages 属性，该属性是用来拦截哪个包中的异常信息，一般我们不指定这个属性，我们拦截项目工程中的所有异常。@ResponseBody 注解是为了异常处理完之后给调用方输出一个 json 格式的封装数据。在项目中如何使用呢？Spring Boot 中很简单，在方法上通过 @ExceptionHandler 注解来指定具体的异常，然后在方法中处理该异常信息，最后将结果通过统一的 json 结构体返回给调用者。下面我们举几个例子来说明如何来使用。 2.1 处理参数缺失异常在前后端分离的架构中，前端请求后台的接口都是通过 rest 风格来调用，有时候，比如 POST 请求 需要携带一些参数，但是往往有时候参数会漏掉。另外，在微服务架构中，涉及到多个微服务之间的接口调用时，也可能出现这种情况，此时我们需要定义一个处理参数缺失异常的方法，来给前端或者调用方提示一个友好信息。 参数缺失的时候，会抛出 HttpMessageNotReadableException，我们可以拦截该异常，做一个友好处理，如下： 123456789101112/*** 缺少请求参数异常* @param ex HttpMessageNotReadableException* @return*/@ExceptionHandler(MissingServletRequestParameterException.class)@ResponseStatus(value = HttpStatus.BAD_REQUEST)public JsonResult handleHttpMessageNotReadableException( MissingServletRequestParameterException ex) { logger.error(\"缺少请求参数，{}\", ex.getMessage()); return new JsonResult(\"400\", \"缺少必要的请求参数\");} 我们来写个简单的 Controller 测试一下该异常，通过 POST 请求方式接收两个参数：姓名和密码。 1234567891011121314@RestController@RequestMapping(\"/exception\")public class ExceptionController { private static final Logger logger = LoggerFactory.getLogger(ExceptionController.class); @PostMapping(\"/test\") public JsonResult test(@RequestParam(\"name\") String name, @RequestParam(\"pass\") String pass) { logger.info(\"name：{}\", name); logger.info(\"pass：{}\", pass); return new JsonResult(); }} 然后使用 Postman 来调用一下该接口，调用的时候，只传姓名，不传密码，就会抛缺少参数异常，该异常被捕获之后，就会进入我们写好的逻辑，给调用方返回一个友好信息，如下： 2.2 处理空指针异常空指针异常是开发中司空见惯的东西了，一般发生的地方有哪些呢？先来聊一聊一些注意的地方，比如在微服务中，经常会调用其他服务获取数据，这个数据主要是 json 格式的，但是在解析 json 的过程中，可能会有空出现，所以我们在获取某个 jsonObject 时，再通过该 jsonObject 去获取相关信息时，应该要先做非空判断。还有一个很常见的地方就是从数据库中查询的数据，不管是查询一条记录封装在某个对象中，还是查询多条记录封装在一个 List 中，我们接下来都要去处理数据，那么就有可能出现空指针异常，因为谁也不能保证从数据库中查出来的东西就一定不为空，所以在使用数据时一定要先做非空判断。对空指针异常的处理很简单，和上面的逻辑一样，将异常信息换掉即可。如下： 123456789101112131415161718@ControllerAdvice@ResponseBodypublic class GlobalExceptionHandler { private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class); /** * 空指针异常 * @param ex NullPointerException * @return */ @ExceptionHandler(NullPointerException.class) @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR) public JsonResult handleTypeMismatchException(NullPointerException ex) { logger.error(\"空指针异常，{}\", ex.getMessage()); return new JsonResult(\"500\", \"空指针异常了\"); }} 这个我就不测试了，代码中 ExceptionController 有个 testNullPointException 方法，模拟了一个空指针异常，我们在浏览器中请求一下对应的 url 即可看到返回的信息： 1{\"code\":\"500\",\"msg\":\"空指针异常了\"} 2.3 一劳永逸？当然了，异常很多，比如还有 RuntimeException，数据库还有一些查询或者操作异常等等。由于 Exception 异常是父类，所有异常都会继承该异常，所以我们可以直接拦截 Exception 异常，一劳永逸： 1234567891011121314151617@ControllerAdvice@ResponseBodypublic class GlobalExceptionHandler { private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class); /** * 系统异常 预期以外异常 * @param ex * @return */ @ExceptionHandler(Exception.class) @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR) public JsonResult handleUnexpectedServer(Exception ex) { logger.error(\"系统异常：\", ex); return new JsonResult(\"500\", \"系统发生异常，请联系管理员\"); }} 但是项目中，我们一般都会比较详细的去拦截一些常见异常，拦截 Exception 虽然可以一劳永逸，但是不利于我们去排查或者定位问题。实际项目中，可以把拦截 Exception 异常写在 GlobalExceptionHandler 最下面，如果都没有找到，最后再拦截一下 Exception 异常，保证输出信息友好。 3. 拦截自定义异常在实际项目中，除了拦截一些系统异常外，在某些业务上，我们需要自定义一些业务异常，比如在微服务中，服务之间的相互调用很平凡，很常见。要处理一个服务的调用时，那么可能会调用失败或者调用超时等等，此时我们需要自定义一个异常，当调用失败时抛出该异常，给 GlobalExceptionHandler 去捕获。 3.1 定义异常信息由于在业务中，有很多异常，针对不同的业务，可能给出的提示信息不同，所以为了方便项目异常信息管理，我们一般会定义一个异常信息枚举类。比如： 123456789101112131415161718192021222324252627282930/** * 业务异常提示信息枚举类 * @author shengwu ni */public enum BusinessMsgEnum { /** 参数异常 */ PARMETER_EXCEPTION(\"102\", \"参数异常!\"), /** 等待超时 */ SERVICE_TIME_OUT(\"103\", \"服务调用超时！\"), /** 参数过大 */ PARMETER_BIG_EXCEPTION(\"102\", \"输入的图片数量不能超过50张!\"), /** 500 : 一劳永逸的提示也可以在这定义 */ UNEXPECTED_EXCEPTION(\"500\", \"系统发生异常，请联系管理员！\"); // 还可以定义更多的业务异常 /** * 消息码 */ private String code; /** * 消息内容 */ private String msg; private BusinessMsgEnum(String code, String msg) { this.code = code; this.msg = msg; } // set get方法} 3.2 拦截自定义异常然后我们可以定义一个业务异常，当出现业务异常时，我们就抛这个自定义的业务异常即可。比如我们定义一个 BusinessErrorException 异常，如下： 1234567891011121314151617181920212223/** * 自定义业务异常 * @author shengwu ni */public class BusinessErrorException extends RuntimeException { private static final long serialVersionUID = -7480022450501760611L; /** * 异常码 */ private String code; /** * 异常提示信息 */ private String message; public BusinessErrorException(BusinessMsgEnum businessMsgEnum) { this.code = businessMsgEnum.code(); this.message = businessMsgEnum.msg(); } // get set方法} 在构造方法中，传入我们上面自定义的异常枚举类，所以在项目中，如果有新的异常信息需要添加，我们直接在枚举类中添加即可，很方便，做到统一维护，然后再拦截该异常时获取即可。 123456789101112131415161718@ControllerAdvice@ResponseBodypublic class GlobalExceptionHandler { private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class); /** * 拦截业务异常，返回业务异常信息 * @param ex * @return */ @ExceptionHandler(BusinessErrorException.class) @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR) public JsonResult handleBusinessError(BusinessErrorException ex) { String code = ex.getCode(); String message = ex.getMessage(); return new JsonResult(code, message); }} 在业务代码中，我们可以直接模拟一下抛出业务异常，测试一下： 12345678910111213141516@RestController@RequestMapping(\"/exception\")public class ExceptionController { private static final Logger logger = LoggerFactory.getLogger(ExceptionController.class); @GetMapping(\"/business\") public JsonResult testException() { try { int i = 1 / 0; } catch (Exception e) { throw new BusinessErrorException(BusinessMsgEnum.UNEXPECTED_EXCEPTION); } return new JsonResult(); }} 运行一下项目，测试一下，返回 json 如下，说明我们自定义的业务异常捕获成功： 1{\"code\":\"500\",\"msg\":\"系统发生异常，请联系管理员！\"} 4. 总结本节课程主要讲解了Spring Boot 的全局异常处理，包括异常信息的封装、异常信息的捕获和处理，以及在实际项目中，我们用到的自定义异常枚举类和业务异常的捕获与处理，在项目中运用的非常广泛，基本上每个项目中都需要做全局异常处理。 课程源代码下载地址：戳我下载 欢迎关注我的为微信公众号：武哥聊编程 第09课：Spring Boot中的切面AOP处理1. 什么是AOPAOP：Aspect Oriented Programming 的缩写，意为：面向切面编程。面向切面编程的目标就是分离关注点。什么是关注点呢？就是关注点，就是你要做的事情。假如你是一位公子哥，没啥人生目标，每天衣来伸手，饭来张口，整天只知道一件事：玩（这就是你的关注点，你只要做这一件事）！但是有个问题，你在玩之前，你还需要起床、穿衣服、穿鞋子、叠被子、做早饭等等等等，但是这些事情你不想关注，也不用关注，你只想想玩，那么怎么办呢？ 对！这些事情通通交给下人去干。你有一个专门的仆人 A 帮你穿衣服，仆人 B 帮你穿鞋子，仆人 C 帮你叠好被子，仆人 D 帮你做饭，然后你就开始吃饭、去玩（这就是你一天的正事），你干完你的正事之后，回来，然后一系列仆人又开始帮你干这个干那个，然后一天就结束了！ 这就是 AOP。AOP 的好处就是你只需要干你的正事，其它事情别人帮你干。也许有一天，你想裸奔，不想穿衣服，那么你把仆人 A 解雇就是了！也许有一天，出门之前你还想带点钱，那么你再雇一个仆人 E 专门帮你干取钱的活！这就是AOP。每个人各司其职，灵活组合，达到一种可配置的、可插拔的程序结构。 2. Spring Boot 中的 AOP 处理2.1 AOP 依赖使用AOP，首先需要引入AOP的依赖。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt; 2.2 实现 AOP 切面Spring Boot 中使用 AOP 非常简单，假如我们要在项目中打印一些 log，在引入了上面的依赖之后，我们新建一个类 LogAspectHandler，用来定义切面和处理方法。只要在类上加个@Aspect注解即可。@Aspect 注解用来描述一个切面类，定义切面类的时候需要打上这个注解。@Component 注解让该类交给 Spring 来管理。 12345@Aspect@Componentpublic class LogAspectHandler {} 这里主要介绍几个常用的注解及使用： 1.@Pointcut：定义一个切面，即上面所描述的关注的某件事入口。2.@Before：在做某件事之前做的事。3.@After：在做某件事之后做的事。4.@AfterReturning：在做某件事之后，对其返回值做增强处理。5.@AfterThrowing：在做某件事抛出异常时，处理。 2.2.1 @Pointcut 注解@Pointcut 注解：用来定义一个切面（切入点），即上文中所关注的某件事情的入口。切入点决定了连接点关注的内容，使得我们可以控制通知什么时候执行。 12345678910@Aspect@Componentpublic class LogAspectHandler { /** * 定义一个切面，拦截com.itcodai.course09.controller包和子包下的所有方法 */ @Pointcut(\"execution(* com.itcodai.course09.controller..*.*(..))\") public void pointCut() {}} @Pointcut 注解指定一个切面，定义需要拦截的东西，这里介绍两个常用的表达式：一个是使用 execution()，另一个是使用 annotation()。以 execution(* com.itcodai.course09.controller..*.*(..))) 表达式为例，语法如下： execution() 为表达式主体第一个 * 号的位置：表示返回值类型，* 表示所有类型包名：表示需要拦截的包名，后面的两个句点表示当前包和当前包的所有子包，com.itcodai.course09.controller 包、子包下所有类的方法第二个 * 号的位置：表示类名，* 表示所有类*(..) ：这个星号表示方法名，* 表示所有的方法，后面括弧里面表示方法的参数，两个句点表示任何参数 annotation() 方式是针对某个注解来定义切面，比如我们对具有@GetMapping注解的方法做切面，可以如下定义切面： 12@Pointcut(\"@annotation(org.springframework.web.bind.annotation.GetMapping)\")public void annotationCut() {} 然后使用该切面的话，就会切入注解是 @GetMapping 的方法。因为在实际项目中，可能对于不同的注解有不同的逻辑处理，比如 @GetMapping、@PostMapping、@DeleteMapping 等。所以这种按照注解的切入方式在实际项目中也很常用。 2.2.2 @Before 注解@Before 注解指定的方法在切面切入目标方法之前执行，可以做一些 log 处理，也可以做一些信息的统计，比如获取用户的请求 url 以及用户的 ip 地址等等，这个在做个人站点的时候都能用得到，都是常用的方法。例如： 1234567891011121314151617181920212223242526272829303132@Aspect@Componentpublic class LogAspectHandler { private final Logger logger = LoggerFactory.getLogger(this.getClass()); /** * 在上面定义的切面方法之前执行该方法 * @param joinPoint jointPoint */ @Before(\"pointCut()\") public void doBefore(JoinPoint joinPoint) { logger.info(\"====doBefore方法进入了====\"); // 获取签名 Signature signature = joinPoint.getSignature(); // 获取切入的包名 String declaringTypeName = signature.getDeclaringTypeName(); // 获取即将执行的方法名 String funcName = signature.getName(); logger.info(\"即将执行方法为: {}，属于{}包\", funcName, declaringTypeName); // 也可以用来记录一些信息，比如获取请求的url和ip ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); HttpServletRequest request = attributes.getRequest(); // 获取请求url String url = request.getRequestURL().toString(); // 获取请求ip String ip = request.getRemoteAddr(); logger.info(\"用户请求的url为：{}，ip地址为：{}\", url, ip); }} JointPoint 对象很有用，可以用它来获取一个签名，然后利用签名可以获取请求的包名、方法名，包括参数（通过 joinPoint.getArgs() 获取）等等。 2.2.3 @After 注解@After 注解和 @Before 注解相对应，指定的方法在切面切入目标方法之后执行，也可以做一些完成某方法之后的 log 处理。 12345678910111213141516171819202122232425@Aspect@Componentpublic class LogAspectHandler { private final Logger logger = LoggerFactory.getLogger(this.getClass()); /** * 定义一个切面，拦截com.itcodai.course09.controller包下的所有方法 */ @Pointcut(\"execution(* com.itcodai.course09.controller..*.*(..))\") public void pointCut() {} /** * 在上面定义的切面方法之后执行该方法 * @param joinPoint jointPoint */ @After(\"pointCut()\") public void doAfter(JoinPoint joinPoint) { logger.info(\"====doAfter方法进入了====\"); Signature signature = joinPoint.getSignature(); String method = signature.getName(); logger.info(\"方法{}已经执行完\", method); }} 到这里，我们来写一个 Controller 来测试一下执行结果，新建一个 AopController 如下： 123456789@RestController@RequestMapping(\"/aop\")public class AopController { @GetMapping(\"/{name}\") public String testAop(@PathVariable String name) { return \"Hello \" + name; }} 启动项目，在浏览器中输入 localhost:8080/aop/CSDN，观察一下控制台的输出信息： 12345====doBefore方法进入了==== 即将执行方法为: testAop，属于com.itcodai.course09.controller.AopController包 用户请求的url为：http://localhost:8080/aop/name，ip地址为：0:0:0:0:0:0:0:1 ====doAfter方法进入了==== 方法testAop已经执行完 从打印出来的 log 中可以看出程序执行的逻辑与顺序，可以很直观的掌握 @Before 和 @After 两个注解的实际作用。 2.2.4 @AfterReturning 注解@AfterReturning 注解和 @After 有些类似，区别在于 @AfterReturning 注解可以用来捕获切入方法执行完之后的返回值，对返回值进行业务逻辑上的增强处理，例如： 123456789101112131415161718192021@Aspect@Componentpublic class LogAspectHandler { private final Logger logger = LoggerFactory.getLogger(this.getClass()); /** * 在上面定义的切面方法返回后执行该方法，可以捕获返回对象或者对返回对象进行增强 * @param joinPoint joinPoint * @param result result */ @AfterReturning(pointcut = \"pointCut()\", returning = \"result\") public void doAfterReturning(JoinPoint joinPoint, Object result) { Signature signature = joinPoint.getSignature(); String classMethod = signature.getName(); logger.info(\"方法{}执行完毕，返回参数为：{}\", classMethod, result); // 实际项目中可以根据业务做具体的返回值增强 logger.info(\"对返回参数进行业务上的增强：{}\", result + \"增强版\"); }} 需要注意的是：在 @AfterReturning注解 中，属性 returning 的值必须要和参数保持一致，否则会检测不到。该方法中的第二个入参就是被切方法的返回值，在 doAfterReturning 方法中可以对返回值进行增强，可以根据业务需要做相应的封装。我们重启一下服务，再测试一下（多余的 log 我不贴出来了）： 12方法testAop执行完毕，返回参数为：Hello CSDN 对返回参数进行业务上的增强：Hello CSDN增强版 2.2.5 @AfterThrowing 注解顾名思义，@AfterThrowing 注解是当被切方法执行时抛出异常时，会进入 @AfterThrowing 注解的方法中执行，在该方法中可以做一些异常的处理逻辑。要注意的是 throwing 属性的值必须要和参数一致，否则会报错。该方法中的第二个入参即为抛出的异常。 123456789101112131415161718192021222324/** * 使用AOP处理log * @author shengwu ni * @date 2018/05/04 20:24 */@Aspect@Componentpublic class LogAspectHandler { private final Logger logger = LoggerFactory.getLogger(this.getClass()); /** * 在上面定义的切面方法执行抛异常时，执行该方法 * @param joinPoint jointPoint * @param ex ex */ @AfterThrowing(pointcut = \"pointCut()\", throwing = \"ex\") public void afterThrowing(JoinPoint joinPoint, Throwable ex) { Signature signature = joinPoint.getSignature(); String method = signature.getName(); // 处理异常的逻辑 logger.info(\"执行方法{}出错，异常为：{}\", method, ex); }} 该方法我就不测试了，大家可以自行测试一下。 3. 总结本节课针对 Spring Boot 中的切面 AOP 做了详细的讲解，主要介绍了 Spring Boot 中 AOP 的引入，常用注解的使用，参数的使用，以及常用 api 的介绍。AOP 在实际项目中很有用，对切面方法执行前后都可以根据具体的业务，做相应的预处理或者增强处理，同时也可以用作异常捕获处理，可以根据具体业务场景，合理去使用 AOP。 课程源代码下载地址：戳我下载 欢迎关注我的为微信公众号：武哥聊编程 第10课：Spring Boot集成MyBatis1. MyBatis 介绍大家都知道，MyBatis 框架是一个持久层框架，是 Apache 下的顶级项目。Mybatis 可以让开发者的主要精力放在 sql 上，通过 Mybatis 提供的映射方式，自由灵活的生成满足需要的 sql 语句。使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs 映射成数据库中的记录，在国内可谓是占据了半壁江山。本节课程主要通过两种方式来对 Spring Boot 集成 MyBatis 做一讲解。重点讲解一下基于注解的方式。因为实际项目中使用注解的方式更多一点，更简洁一点，省去了很多 xml 配置（这不是绝对的，有些项目组中可能也在使用 xml 的方式）。 2. MyBatis 的配置2.1 依赖导入Spring Boot 集成 MyBatis，需要导入 mybatis-spring-boot-starter 和 mysql 的依赖，这里我们使用的版本时 1.3.2，如下： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 我们点开 mybatis-spring-boot-starter 依赖，可以看到我们之前使用 Spring 时候熟悉的依赖，就像我在课程的一开始介绍的那样，Spring Boot 致力于简化编码，使用 starter 系列将相关依赖集成在一起，开发者不需要关注繁琐的配置，非常方便。 123456789&lt;!-- 省去其他 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;&lt;/dependency&gt; 2.2 properties.yml配置我们再来看一下，集成 MyBatis 时需要在 properties.yml 配置文件中做哪些基本配置呢？ 12345678910111213141516171819202122232425# 服务端口号server: port: 8080# 数据库地址datasource: url: localhost:3306/blog_testspring: datasource: # 数据库配置 driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://${datasource.url}?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;maxReconnects=10 username: root password: 123456 hikari: maximum-pool-size: 10 # 最大连接池数 max-lifetime: 1770000mybatis: # 指定别名设置的包为所有entity type-aliases-package: com.itcodai.course10.entity configuration: map-underscore-to-camel-case: true # 驼峰命名规范 mapper-locations: # mapper映射文件位置 - classpath:mapper/*.xml 我们来简单介绍一下上面的这些配置：关于数据库的相关配置，我就不详细的解说了，这点相信大家已经非常熟练了，配置一下用户名、密码、数据库连接等等，这里使用的连接池是 Spring Boot 自带的 hikari，感兴趣的朋友可以去百度或者谷歌搜一搜，了解一下。 这里说明一下 map-underscore-to-camel-case: true， 用来开启驼峰命名规范，这个比较好用，比如数据库中字段名为：user_name， 那么在实体类中可以定义属性为 userName （甚至可以写成 username，也能映射上），会自动匹配到驼峰属性，如果不这样配置的话，针对字段名和属性名不同的情况，会映射不到。 3. 基于 xml 的整合使用原始的 xml 方式，需要新建 UserMapper.xml 文件，在上面的 application.yml 配置文件中，我们已经定义了 xml 文件的路径：classpath:mapper/*.xml，所以我们在 resources 目录下新建一个 mapper 文件夹，然后创建一个 UserMapper.xml 文件。 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.itcodai.course10.dao.UserMapper\"&gt; &lt;resultMap id=\"BaseResultMap\" type=\"com.itcodai.course10.entity.User\"&gt; &lt;id column=\"id\" jdbcType=\"BIGINT\" property=\"id\" /&gt; &lt;result column=\"user_name\" jdbcType=\"VARCHAR\" property=\"username\" /&gt; &lt;result column=\"password\" jdbcType=\"VARCHAR\" property=\"password\" /&gt; &lt;/resultMap&gt; &lt;select id=\"getUserByName\" resultType=\"User\" parameterType=\"String\"&gt; select * from user where user_name = #{username} &lt;/select&gt;&lt;/mapper&gt; 这和整合 Spring 一样的，namespace 中指定的是对应的 Mapper， &lt;resultMap&gt; 中指定对应的实体类，即 User。然后在内部指定表的字段和实体的属性相对应即可。这里我们写一个根据用户名查询用户的 sql。 实体类中有 id，username 和 password，我不在这贴代码，大家可以下载源码查看。UserMapper.java 文件中写一个接口即可： 1User getUserByName(String username); 中间省略 service 的代码，我们写一个 Controller 来测试一下： 1234567891011@RestControllerpublic class TestController { @Resource private UserService userService; @RequestMapping(\"/getUserByName/{name}\") public User getUserByName(@PathVariable String name) { return userService.getUserByName(name); }} 启动项目，在浏览器中输入：http://localhost:8080/getUserByName/CSDN 即可查询到数据库表中用户名为 CSDN 的用户信息（事先搞两个数据进去即可）： 1{\"id\":2,\"username\":\"CSDN\",\"password\":\"123456\"} 这里需要注意一下：Spring Boot 如何知道这个 Mapper 呢？一种方法是在上面的 mapper 层对应的类上面添加 @Mapper 注解即可，但是这种方法有个弊端，当我们有很多个 mapper 时，那么每一个类上面都得添加 @Mapper 注解。另一种比较简便的方法是在 Spring Boot 启动类上添加@MaperScan 注解，来扫描一个包下的所有 mapper。如下： 12345678@SpringBootApplication@MapperScan(\"com.itcodai.course10.dao\")public class Course10Application { public static void main(String[] args) { SpringApplication.run(Course10Application.class, args); }} 这样的话，com.itcodai.course10.dao 包下的所有 mapper 都会被扫描到了。 4. 基于注解的整合基于注解的整合就不需要 xml 配置文件了，MyBatis 主要提供了 @Select， @Insert， @Update， Delete 四个注解。这四个注解是用的非常多的，也很简单，注解后面跟上对应的 sql 语句即可，我们举个例子： 12@Select(\"select * from user where id = #{id}\")User getUser(Long id); 这跟 xml 文件中写 sql 语句是一样的，这样就不需要 xml 文件了，但是有个问题，有人可能会问，如果是两个参数呢？如果是两个参数，我们需要使用 @Param 注解来指定每一个参数的对应关系，如下： 12@Select(\"select * from user where id = #{id} and user_name=#{name}\")User getUserByIdAndName(@Param(\"id\") Long id, @Param(\"name\") String username); 可以看出，@Param 指定的参数应该要和 sql 中 #{} 取的参数名相同，不同则取不到。可以在 controller 中自行测试一下，接口都在源码中，文章中我就不贴测试代码和结果了。 有个问题需要注意一下，一般我们在设计表字段后，都会根据自动生成工具生成实体类，这样的话，基本上实体类是能和表字段对应上的，最起码也是驼峰对应的，由于在上面配置文件中开启了驼峰的配置，所以字段都是能对的上的。但是，万一有对不上的呢？我们也有解决办法，使用 @Results 注解来解决。 123456@Select(\"select * from user where id = #{id}\")@Results({ @Result(property = \"username\", column = \"user_name\"), @Result(property = \"password\", column = \"password\")})User getUser(Long id); @Results 中的 @Result 注解是用来指定每一个属性和字段的对应关系，这样的话就可以解决上面说的这个问题了。 当然了，我们也可以 xml 和注解相结合使用，目前我们实际的项目中也是采用混用的方式，因为有时候 xml 方便，有时候注解方便，比如就上面这个问题来说，如果我们定义了上面的这个 UserMapper.xml，那么我们完全可以使用 @ResultMap 注解来替代 @Results 注解，如下： 123@Select(\"select * from user where id = #{id}\")@ResultMap(\"BaseResultMap\")User getUser(Long id); @ResultMap 注解中的值从哪来呢？对应的是 UserMapper.xml 文件中定义的 &lt;resultMap&gt; 时对应的 id 值： 1&lt;resultMap id=\"BaseResultMap\" type=\"com.itcodai.course10.entity.User\"&gt; 这种 xml 和注解结合着使用的情况也很常见，而且也减少了大量的代码，因为 xml 文件可以使用自动生成工具去生成，也不需要人为手动敲，所以这种使用方式也很常见。 5. 总结本节课主要系统的讲解了 Spring Boot 集成 MyBatis 的过程，分为基于 xml 形式和基于注解的形式来讲解，通过实际配置手把手讲解了 Spring Boot 中 MyBatis 的使用方式，并针对注解方式，讲解了常见的问题已经解决方式，有很强的实战意义。在实际项目中，建议根据实际情况来确定使用哪种方式，一般 xml 和注解都在用。 课程源代码下载地址：戳我下载 欢迎关注我的为微信公众号：武哥聊编程 第11课：Spring Boot事务配置管理1. 事务相关场景：我们在开发企业应用时，由于数据操作在顺序执行的过程中，线上可能有各种无法预知的问题，任何一步操作都有可能发生异常，异常则会导致后续的操作无法完成。此时由于业务逻辑并未正确的完成，所以在之前操作过数据库的动作并不可靠，需要在这种情况下进行数据的回滚。 事务的作用就是为了保证用户的每一个操作都是可靠的，事务中的每一步操作都必须成功执行，只要有发生异常就回退到事务开始未进行操作的状态。这很好理解，转账、购票等等，必须整个事件流程全部执行完才能人为该事件执行成功，不能转钱转到一半，系统死了，转账人钱没了，收款人钱还没到。 事务管理是 Spring Boot 框架中最为常用的功能之一，我们在实际应用开发时，基本上在 service 层处理业务逻辑的时候都要加上事务，当然了，有时候可能由于场景需要，也不用加事务（比如我们就要往一个表里插数据，相互没有影响，插多少是多少，不能因为某个数据挂了，把之前插的全部回滚）。 2. Spring Boot 事务配置2.1 依赖导入在 Spring Boot 中使用事务，需要导入 mysql 依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 导入了 mysql 依赖后，Spring Boot 会自动注入 DataSourceTransactionManager，我们不需要任何其他的配置就可以用 @Transactional 注解进行事务的使用。关于 mybatis 的配置，在上一节课中已经说明了，这里还是使用上一节课中的 mybatis 配置即可。 2.2 事务的测试我们首先在数据库表中插入一条数据：|id|user_name|password||:–:|:–:|:–:||1|倪升武|123456| 然后我们写一个插入的 mapper： 12345public interface UserMapper { @Insert(\"insert into user (user_name, password) values (#{username}, #{password})\") Integer insertUser(User user);} OK，接下来我们来测试一下 Spring Boot 中的事务处理，在 service 层，我们手动抛出个异常来模拟实际中出现的异常，然后观察一下事务有没有回滚，如果数据库中没有新的记录，则说明事务回滚成功。 123456789101112131415@Servicepublic class UserServiceImpl implements UserService { @Resource private UserMapper userMapper; @Override @Transactional public void isertUser(User user) { // 插入用户信息 userMapper.insertUser(user); // 手动抛出异常 throw new RuntimeException(); }} 我们来测试一下： 12345678910111213141516@RestControllerpublic class TestController { @Resource private UserService userService; @PostMapping(\"/adduser\") public String addUser(@RequestBody User user) throws Exception { if (null != user) { userService.isertUser(user); return \"success\"; } else { return \"false\"; } }} 我们使用 postman 调用一下该接口，因为在程序中抛出了个异常，会造成事务回滚，我们刷新一下数据库，并没有增加一条记录，说明事务生效了。事务很简单，我们平时在使用的时候，一般不会有多少问题，但是并不仅仅如此…… 3. 常见问题总结从上面的内容中可以看出，Spring Boot 中使用事务非常简单，@Transactional 注解即可解决问题，说是这么说，但是在实际项目中，是有很多小坑在等着我们，这些小坑是我们在写代码的时候没有注意到，而且正常情况下不容易发现这些小坑，等项目写大了，某一天突然出问题了，排查问题非常困难，到时候肯定是抓瞎，需要费很大的精力去排查问题。 这一小节，我专门针对实际项目中经常出现的，和事务相关的细节做一下总结，希望读者在读完之后，能够落实到自己的项目中，能有所受益。 3.1 异常并没有被 ”捕获“ 到首先要说的，就是异常并没有被 ”捕获“ 到，导致事务并没有回滚。我们在业务层代码中，也许已经考虑到了异常的存在，或者编辑器已经提示我们需要抛出异常，但是这里面有个需要注意的地方：并不是说我们把异常抛出来了，有异常了事务就会回滚，我们来看一个例子： 123456789101112131415@Servicepublic class UserServiceImpl implements UserService { @Resource private UserMapper userMapper; @Override @Transactional public void isertUser2(User user) throws Exception { // 插入用户信息 userMapper.insertUser(user); // 手动抛出异常 throw new SQLException(\"数据库异常\"); }} 我们看上面这个代码，其实并没有什么问题，手动抛出一个 SQLException 来模拟实际中操作数据库发生的异常，在这个方法中，既然抛出了异常，那么事务应该回滚，实际却不如此，读者可以使用我源码中 controller 的接口，通过 postman 测试一下，就会发现，仍然是可以插入一条用户数据的。 那么问题出在哪呢？因为 Spring Boot 默认的事务规则是遇到运行异常（RuntimeException）和程序错误（Error）才会回滚。比如上面我们的例子中抛出的 RuntimeException 就没有问题，但是抛出 SQLException 就无法回滚了。针对非运行时异常，如果要进行事务回滚的话，可以在 @Transactional 注解中使用 rollbackFor 属性来指定异常，比如 @Transactional(rollbackFor = Exception.class)，这样就没有问题了，所以在实际项目中，一定要指定异常。 3.2 异常被 ”吃“ 掉这个标题很搞笑，异常怎么会被吃掉呢？还是回归到现实项目中去，我们在处理异常时，有两种方式，要么抛出去，让上一层来捕获处理；要么把异常 try catch 掉，在异常出现的地方给处理掉。就因为有这中 try…catch，所以导致异常被 ”吃“ 掉，事务无法回滚。我们还是看上面那个例子，只不过简单修改一下代码： 12345678910111213141516171819@Servicepublic class UserServiceImpl implements UserService { @Resource private UserMapper userMapper; @Override @Transactional(rollbackFor = Exception.class) public void isertUser3(User user) { try { // 插入用户信息 userMapper.insertUser(user); // 手动抛出异常 throw new SQLException(\"数据库异常\"); } catch (Exception e) { // 异常处理逻辑 } }} 读者可以使用我源码中 controller 的接口，通过 postman 测试一下，就会发现，仍然是可以插入一条用户数据，说明事务并没有因为抛出异常而回滚。这个细节往往比上面那个坑更难以发现，因为我们的思维很容易导致 try…catch 代码的产生，一旦出现这种问题，往往排查起来比较费劲，所以我们平时在写代码时，一定要多思考，多注意这种细节，尽量避免给自己埋坑。 那这种怎么解决呢？直接往上抛，给上一层来处理即可，千万不要在事务中把异常自己 ”吃“ 掉。 3.3 事务的范围事务范围这个东西比上面两个坑埋的更深！我之所以把这个也写上，是因为这是我之前在实际项目中遇到的，该场景在这个课程中我就不模拟了，我写一个 demo 让大家看一下，把这个坑记住即可，以后在写代码时，遇到并发问题，就会注意这个坑了，那么这节课也就有价值了。 我来写个 demo： 12345678910111213@Servicepublic class UserServiceImpl implements UserService { @Resource private UserMapper userMapper; @Override @Transactional(rollbackFor = Exception.class) public synchronized void isertUser4(User user) { // 实际中的具体业务…… userMapper.insertUser(user); }} 可以看到，因为要考虑并发问题，我在业务层代码的方法上加了个 synchronized 关键字。我举个实际的场景，比如一个数据库中，针对某个用户，只有一条记录，下一个插入动作过来，会先判断该数据库中有没有相同的用户，如果有就不插入，就更新，没有才插入，所以理论上，数据库中永远就一条同一用户信息，不会出现同一数据库中插入了两条相同用户的信息。 但是在压测时，就会出现上面的问题，数据库中确实有两条同一用户的信息，分析其原因，在于事务的范围和锁的范围问题。 从上面方法中可以看到，方法上是加了事务的，那么也就是说，在执行该方法开始时，事务启动，执行完了后，事务关闭。但是 synchronized 没有起作用，其实根本原因是因为事务的范围比锁的范围大。也就是说，在加锁的那部分代码执行完之后，锁释放掉了，但是事务还没结束，此时另一个线程进来了，事务没结束的话，第二个线程进来时，数据库的状态和第一个线程刚进来是一样的。即由于mysql Innodb引擎的默认隔离级别是可重复读（在同一个事务里，SELECT的结果是事务开始时时间点的状态），线程二事务开始的时候，线程一还没提交完成，导致读取的数据还没更新。第二个线程也做了插入动作，导致了脏数据。 这个问题可以避免，第一，把事务去掉即可（不推荐）；第二，在调用该 service 的地方加锁，保证锁的范围比事务的范围大即可。 4. 总结本章主要总结了 Spring Boot 中如何使用事务，只要使用 @Transactional 注解即可使用，非常简单方便。除此之外，重点总结了三个在实际项目中可能遇到的坑点，这非常有意义，因为事务这东西不出问题还好，出了问题比较难以排查，所以总结的这三点注意事项，希望能帮助到开发中的朋友。 课程源代码下载地址：戳我下载 欢迎关注我的为微信公众号：武哥聊编程 第12课：Spring Boot中使用监听器1. 监听器介绍什么是 web 监听器？web 监听器是一种 Servlet 中特殊的类，它们能帮助开发者监听 web 中特定的事件，比如 ServletContext, HttpSession, ServletRequest 的创建和销毁；变量的创建、销毁和修改等。可以在某些动作前后增加处理，实现监控。 2. Spring Boot中监听器的使用web 监听器的使用场景很多，比如监听 servlet 上下文用来初始化一些数据、监听 http session 用来获取当前在线的人数、监听客户端请求的 servlet request 对象来获取用户的访问信息等等。这一节中，我们主要通过这三个实际的使用场景来学习一下 Spring Boot 中监听器的使用。 2.1 监听Servlet上下文对象监听 servlet 上下文对象可以用来初始化数据，用于缓存。什么意思呢？我举一个很常见的场景，比如用户在点击某个站点的首页时，一般都会展现出首页的一些信息，而这些信息基本上或者大部分时间都保持不变的，但是这些信息都是来自数据库。如果用户的每次点击，都要从数据库中去获取数据的话，用户量少还可以接受，如果用户量非常大的话，这对数据库也是一笔很大的开销。 针对这种首页数据，大部分都不常更新的话，我们完全可以把它们缓存起来，每次用户点击的时候，我们都直接从缓存中拿，这样既可以提高首页的访问速度，又可以降低服务器的压力。如果做的更加灵活一点，可以再加个定时器，定期的来更新这个首页缓存。就类似与 CSDN 个人博客首页中排名的变化一样。 下面我们针对这个功能，来写一个 demo，在实际中，读者可以完全套用该代码，来实现自己项目中的相关逻辑。首先写一个 Service，模拟一下从数据库查询数据： 123456789101112@Servicepublic class UserService { /** * 获取用户信息 * @return */ public User getUser() { // 实际中会根据具体的业务场景，从数据库中查询对应的信息 return new User(1L, \"倪升武\", \"123456\"); }} 然后写一个监听器，实现 ApplicationListener&lt;ContextRefreshedEvent&gt; 接口，重写 onApplicationEvent 方法，将 ContextRefreshedEvent 对象传进去。如果我们想在加载或刷新应用上下文时，也重新刷新下我们预加载的资源，就可以通过监听 ContextRefreshedEvent 来做这样的事情。如下： 1234567891011121314151617181920/** * 使用ApplicationListener来初始化一些数据到application域中的监听器 * @author shengni ni * @date 2018/07/05 */@Componentpublic class MyServletContextListener implements ApplicationListener&lt;ContextRefreshedEvent&gt; { @Override public void onApplicationEvent(ContextRefreshedEvent contextRefreshedEvent) { // 先获取到application上下文 ApplicationContext applicationContext = contextRefreshedEvent.getApplicationContext(); // 获取对应的service UserService userService = applicationContext.getBean(UserService.class); User user = userService.getUser(); // 获取application域对象，将查到的信息放到application域中 ServletContext application = applicationContext.getBean(ServletContext.class); application.setAttribute(\"user\", user); }} 正如注释中描述的一样，首先通过 contextRefreshedEvent 来获取 application 上下文，再通过 application 上下文来获取 UserService 这个 bean，项目中可以根据实际业务场景，也可以获取其他的 bean，然后再调用自己的业务代码获取相应的数据，最后存储到 application 域中，这样前端在请求相应数据的时候，我们就可以直接从 application 域中获取信息，减少数据库的压力。下面写一个 Controller 直接从 application 域中获取 user 信息来测试一下。 12345678910@RestController@RequestMapping(\"/listener\")public class TestController { @GetMapping(\"/user\") public User getUser(HttpServletRequest request) { ServletContext application = request.getServletContext(); return (User) application.getAttribute(\"user\"); }} 启动项目，在浏览器中输入 http://localhost:8080/listener/user 测试一下即可，如果正常返回 user 信息，那么说明数据已经缓存成功。不过 application 这种是缓存在内存中，对内存会有消耗，后面的课程中我会讲到 redis，到时候再给大家介绍一下 redis 的缓存。 2.2 监听HTTP会话 Session对象监听器还有一个比较常用的地方就是用来监听 session 对象，来获取在线用户数量，现在有很多开发者都有自己的网站，监听 session 来获取当前在下用户数量是个很常见的使用场景，下面来介绍一下如何来使用。 1234567891011121314151617181920212223242526272829/** * 使用HttpSessionListener统计在线用户数的监听器 * @author shengwu ni * @date 2018/07/05 */@Componentpublic class MyHttpSessionListener implements HttpSessionListener { private static final Logger logger = LoggerFactory.getLogger(MyHttpSessionListener.class); /** * 记录在线的用户数量 */ public Integer count = 0; @Override public synchronized void sessionCreated(HttpSessionEvent httpSessionEvent) { logger.info(\"新用户上线了\"); count++; httpSessionEvent.getSession().getServletContext().setAttribute(\"count\", count); } @Override public synchronized void sessionDestroyed(HttpSessionEvent httpSessionEvent) { logger.info(\"用户下线了\"); count--; httpSessionEvent.getSession().getServletContext().setAttribute(\"count\", count); }} 可以看出，首先该监听器需要实现 HttpSessionListener 接口，然后重写 sessionCreated 和 sessionDestroyed 方法，在 sessionCreated 方法中传递一个 HttpSessionEvent 对象，然后将当前 session 中的用户数量加1，sessionDestroyed 方法刚好相反，不再赘述。然后我们写一个 Controller 来测试一下。 123456789101112131415@RestController@RequestMapping(\"/listener\")public class TestController { /** * 获取当前在线人数，该方法有bug * @param request * @return */ @GetMapping(\"/total\") public String getTotalUser(HttpServletRequest request) { Integer count = (Integer) request.getSession().getServletContext().getAttribute(\"count\"); return \"当前在线人数：\" + count; }} 该 Controller 中是直接获取当前 session 中的用户数量，启动服务器，在浏览器中输入 localhost:8080/listener/total 可以看到返回的结果是1，再打开一个浏览器，请求相同的地址可以看到 count 是 2 ，这没有问题。但是如果关闭一个浏览器再打开，理论上应该还是2，但是实际测试却是 3。原因是 session 销毁的方法没有执行（可以在后台控制台观察日志打印情况），当重新打开时，服务器找不到用户原来的 session，于是又重新创建了一个 session，那怎么解决该问题呢？我们可以将上面的 Controller 方法改造一下： 12345678910111213141516@GetMapping(\"/total2\")public String getTotalUser(HttpServletRequest request, HttpServletResponse response) { Cookie cookie; try { // 把sessionId记录在浏览器中 cookie = new Cookie(\"JSESSIONID\", URLEncoder.encode(request.getSession().getId(), \"utf-8\")); cookie.setPath(\"/\"); //设置cookie有效期为2天，设置长一点 cookie.setMaxAge( 48*60 * 60); response.addCookie(cookie); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } Integer count = (Integer) request.getSession().getServletContext().getAttribute(\"count\"); return \"当前在线人数：\" + count;} 可以看出，该处理逻辑是让服务器记得原来那个 session，即把原来的 sessionId 记录在浏览器中，下次再打开时，把这个 sessionId 传过去，这样服务器就不会重新再创建了。重启一下服务器，在浏览器中再次测试一下，即可避免上面的问题。 2.3 监听客户端请求Servlet Request对象使用监听器获取用户的访问信息比较简单，实现 ServletRequestListener 接口即可，然后通过 request 对象获取一些信息。如下： 1234567891011121314151617181920212223242526272829/** * 使用ServletRequestListener获取访问信息 * @author shengwu ni * @date 2018/07/05 */@Componentpublic class MyServletRequestListener implements ServletRequestListener { private static final Logger logger = LoggerFactory.getLogger(MyServletRequestListener.class); @Override public void requestInitialized(ServletRequestEvent servletRequestEvent) { HttpServletRequest request = (HttpServletRequest) servletRequestEvent.getServletRequest(); logger.info(\"session id为：{}\", request.getRequestedSessionId()); logger.info(\"request url为：{}\", request.getRequestURL()); request.setAttribute(\"name\", \"倪升武\"); } @Override public void requestDestroyed(ServletRequestEvent servletRequestEvent) { logger.info(\"request end\"); HttpServletRequest request = (HttpServletRequest) servletRequestEvent.getServletRequest(); logger.info(\"request域中保存的name值为：{}\", request.getAttribute(\"name\")); }} 这个比较简单，不再赘述，接下来写一个 Controller 测试一下即可。 12345@GetMapping(\"/request\")public String getRequestInfo(HttpServletRequest request) { System.out.println(\"requestListener中的初始化的name数据：\" + request.getAttribute(\"name\")); return \"success\";} 3. Spring Boot中自定义事件监听在实际项目中，我们往往需要自定义一些事件和监听器来满足业务场景，比如在微服务中会有这样的场景：微服务 A 在处理完某个逻辑之后，需要通知微服务 B 去处理另一个逻辑，或者微服务 A 处理完某个逻辑之后，需要将数据同步到微服务 B，这种场景非常普遍，这个时候，我们可以自定义事件以及监听器来监听，一旦监听到微服务 A 中的某事件发生，就去通知微服务 B 处理对应的逻辑。 3.1 自定义事件自定义事件需要继承 ApplicationEvent 对象，在事件中定义一个 User 对象来模拟数据，构造方法中将 User 对象传进来初始化。如下： 12345678910111213141516/** * 自定义事件 * @author shengwu ni * @date 2018/07/05 */public class MyEvent extends ApplicationEvent { private User user; public MyEvent(Object source, User user) { super(source); this.user = user; } // 省去get、set方法} 3.2 自定义监听器接下来，自定义一个监听器来监听上面定义的 MyEvent 事件，自定义监听器需要实现 ApplicationListener 接口即可。如下： 1234567891011121314151617/** * 自定义监听器，监听MyEvent事件 * @author shengwu ni * @date 2018/07/05 */@Componentpublic class MyEventListener implements ApplicationListener&lt;MyEvent&gt; { @Override public void onApplicationEvent(MyEvent myEvent) { // 把事件中的信息获取到 User user = myEvent.getUser(); // 处理事件，实际项目中可以通知别的微服务或者处理其他逻辑等等 System.out.println(\"用户名：\" + user.getUsername()); System.out.println(\"密码：\" + user.getPassword()); }} 然后重写 onApplicationEvent 方法，将自定义的 MyEvent 事件传进来，因为该事件中，我们定义了 User 对象（该对象在实际中就是需要处理的数据，在下文来模拟），然后就可以使用该对象的信息了。 OK，定义好了事件和监听器之后，需要手动发布事件，这样监听器才能监听到，这需要根据实际业务场景来触发，针对本文的例子，我写个触发逻辑，如下： 12345678910111213141516171819202122/** * UserService * @author shengwu ni */@Servicepublic class UserService { @Resource private ApplicationContext applicationContext; /** * 发布事件 * @return */ public User getUser2() { User user = new User(1L, \"倪升武\", \"123456\"); // 发布事件 MyEvent event = new MyEvent(this, user); applicationContext.publishEvent(event); return user; }} 在 service 中注入 ApplicationContext，在业务代码处理完之后，通过 ApplicationContext 对象手动发布 MyEvent 事件，这样我们自定义的监听器就能监听到，然后处理监听器中写好的业务逻辑。 最后，在 Controller 中写一个接口来测试一下： 12345@GetMapping(\"/request\")public String getRequestInfo(HttpServletRequest request) { System.out.println(\"requestListener中的初始化的name数据：\" + request.getAttribute(\"name\")); return \"success\";} 在浏览器中输入 http://localhost:8080/listener/publish，然后观察一下控制台打印的用户名和密码，即可说明自定义监听器已经生效。 4. 总结本课系统的介绍了监听器原理，以及在 Spring Boot 中如何使用监听器，列举了监听器的三个常用的案例，有很好的实战意义。最后讲解了项目中如何自定义事件和监听器，并结合微服务中常见的场景，给出具体的代码模型，均能运用到实际项目中去，希望读者认真消化。 课程源代码下载地址：戳我下载 欢迎关注我的为微信公众号：武哥聊编程 第13课：Spring Boot中使用拦截器拦截器的原理很简单，是 AOP 的一种实现，专门拦截对动态资源的后台请求，即拦截对控制层的请求。使用场景比较多的是判断用户是否有权限请求后台，更拔高一层的使用场景也有，比如拦截器可以结合 websocket 一起使用，用来拦截 websocket 请求，然后做相应的处理等等。拦截器不会拦截静态资源，Spring Boot 的默认静态目录为 resources/static，该目录下的静态页面、js、css、图片等等，不会被拦截（也要看如何实现，有些情况也会拦截，我在下文会指出）。 1. 拦截器的快速使用使用拦截器很简单，只需要两步即可：定义拦截器和配置拦截器。在配置拦截器中，Spring Boot 2.0 以后的版本和之前的版本有所不同，我会重点讲解一下这里可能出现的坑。 1.1 定义拦截器定义拦截器，只需要实现 HandlerInterceptor 接口，HandlerInterceptor 接口是所有自定义拦截器或者 Spring Boot 提供的拦截器的鼻祖，所以，首先来了解下该接口。该接口中有三个方法： preHandle(……)、postHandle(……) 和 afterCompletion(……) 。 preHandle(……) 方法：该方法的执行时机是，当某个 url 已经匹配到对应的 Controller 中的某个方法，且在这个方法执行之前。所以 preHandle(……) 方法可以决定是否将请求放行，这是通过返回值来决定的，返回 true 则放行，返回 false 则不会向后执行。postHandle(……) 方法：该方法的执行时机是，当某个 url 已经匹配到对应的 Controller 中的某个方法，且在执行完了该方法，但是在 DispatcherServlet 视图渲染之前。所以在这个方法中有个 ModelAndView 参数，可以在此做一些修改动作。afterCompletion(……) 方法：顾名思义，该方法是在整个请求处理完成后（包括视图渲染）执行，这时做一些资源的清理工作，这个方法只有在 preHandle(……) 被成功执行后并且返回 true 才会被执行。 了解了该接口，接下来自定义一个拦截器。 123456789101112131415161718192021222324252627282930/** * 自定义拦截器 * @author shengwu ni * @date 2018/08/03 */public class MyInterceptor implements HandlerInterceptor { private static final Logger logger = LoggerFactory.getLogger(MyInterceptor.class); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { HandlerMethod handlerMethod = (HandlerMethod) handler; Method method = handlerMethod.getMethod(); String methodName = method.getName(); logger.info(\"====拦截到了方法：{}，在该方法执行之前执行====\", methodName); // 返回true才会继续执行，返回false则取消当前请求 return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { logger.info(\"执行完方法之后进执行(Controller方法调用之后)，但是此时还没进行视图渲染\"); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { logger.info(\"整个请求都处理完咯，DispatcherServlet也渲染了对应的视图咯，此时我可以做一些清理的工作了\"); }} OK，到此为止，拦截器已经定义完成，接下来就是对该拦截器进行拦截配置。 1.2 配置拦截器在 Spring Boot 2.0 之前，我们都是直接继承 WebMvcConfigurerAdapter 类，然后重写 addInterceptors 方法来实现拦截器的配置。但是在 Spring Boot 2.0 之后，该方法已经被废弃了（当然，也可以继续用），取而代之的是 WebMvcConfigurationSupport 方法，如下： 123456789@Configurationpublic class MyInterceptorConfig extends WebMvcConfigurationSupport { @Override protected void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new MyInterceptor()).addPathPatterns(\"/**\"); super.addInterceptors(registry); }} 在该配置中重写 addInterceptors 方法，将我们上面自定义的拦截器添加进去，addPathPatterns 方法是添加要拦截的请求，这里我们拦截所有的请求。这样就配置好拦截器了，接下来写一个 Controller 测试一下： 123456789@Controller@RequestMapping(\"/interceptor\")public class InterceptorController { @RequestMapping(\"/test\") public String test() { return \"hello\"; }} 让其跳转到 hello.html 页面，直接在 hello.html 中输出 hello interceptor 即可。启动项目，在浏览器中输入 localhost:8080/interceptor/test 看一下控制台的日志： 123====拦截到了方法：test，在该方法执行之前执行==== 执行完方法之后进执行(Controller方法调用之后)，但是此时还没进行视图渲染 整个请求都处理完咯，DispatcherServlet也渲染了对应的视图咯，此时我可以做一些清理的工作了 可以看出拦截器已经生效，并能看出其执行顺序。 1.3 解决静态资源被拦截问题上文中已经介绍了拦截器的定义和配置，但是这样是否就没问题了呢？其实不然，如果使用上面这种配置的话，我们会发现一个缺陷，那就是静态资源被拦截了。可以在 resources/static/ 目录下放置一个图片资源或者 html 文件，然后启动项目直接访问，即可看到无法访问的现象。 也就是说，虽然 Spring Boot 2.0 废弃了WebMvcConfigurerAdapter，但是 WebMvcConfigurationSupport 又会导致默认的静态资源被拦截，这就需要我们手动将静态资源放开。 如何放开呢？除了在 MyInterceptorConfig 配置类中重写 addInterceptors 方法外，还需要再重写一个方法：addResourceHandlers，将静态资源放开： 123456789/** * 用来指定静态资源不被拦截，否则继承WebMvcConfigurationSupport这种方式会导致静态资源无法直接访问 * @param registry */@Overrideprotected void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(\"/**\").addResourceLocations(\"classpath:/static/\"); super.addResourceHandlers(registry);} 这样配置好之后，重启项目，静态资源也可以正常访问了。如果你是个善于学习或者研究的人，那肯定不会止步于此，没错，上面这种方式的确能解决静态资源无法访问的问题，但是，还有更方便的方式来配置。 我们不继承 WebMvcConfigurationSupport 类，直接实现 WebMvcConfigurer 接口，然后重写 addInterceptors 方法，将自定义的拦截器添加进去即可，如下： 12345678@Configurationpublic class MyInterceptorConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { // 实现WebMvcConfigurer不会导致静态资源被拦截 registry.addInterceptor(new MyInterceptor()).addPathPatterns(\"/**\"); }} 这样就非常方便了，实现 WebMvcConfigure 接口的话，不会拦截 Spring Boot 默认的静态资源。 这两种方式都可以，具体他们之间的细节，感兴趣的读者可以做进一步的研究，由于这两种方式的不同，继承 WebMvcConfigurationSupport 类的方式可以用在前后端分离的项目中，后台不需要访问静态资源（就不需要放开静态资源了）；实现 WebMvcConfigure 接口的方式可以用在非前后端分离的项目中，因为需要读取一些图片、css、js文件等等。 2. 拦截器使用实例2.1 判断用户有没有登录一般用户登录功能我们可以这么做，要么往 session 中写一个 user，要么针对每个 user 生成一个 token，第二种要更好一点，那么针对第二种方式，如果用户登录成功了，每次请求的时候都会带上该用户的 token，如果未登录，则没有该 token，服务端可以检测这个 token 参数的有无来判断用户有没有登录，从而实现拦截功能。我们改造一下 preHandle 方法，如下： 123456789101112131415161718@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { HandlerMethod handlerMethod = (HandlerMethod) handler; Method method = handlerMethod.getMethod(); String methodName = method.getName(); logger.info(\"====拦截到了方法：{}，在该方法执行之前执行====\", methodName); // 判断用户有没有登陆，一般登陆之后的用户都有一个对应的token String token = request.getParameter(\"token\"); if (null == token || \"\".equals(token)) { logger.info(\"用户未登录，没有权限执行……请登录\"); return false; } // 返回true才会继续执行，返回false则取消当前请求 return true;} 重启项目，在浏览器中输入 localhost:8080/interceptor/test 后查看控制台日志，发现被拦截，如果在浏览器中输入 localhost:8080/interceptor/test?token=123 即可正常往下走。 2.2 取消拦截操作根据上文，如果我要拦截所有 /admin 开头的 url 请求的话，需要在拦截器配置中添加这个前缀，但是在实际项目中，可能会有这种场景出现：某个请求也是 /admin 开头的，但是不能拦截，比如 /admin/login 等等，这样的话又需要去配置。那么，可不可以做成一个类似于开关的东西，哪里不需要拦截，我就在哪里弄个开关上去，做成这种灵活的可插拔的效果呢？ 是可以的，我们可以定义一个注解，该注解专门用来取消拦截操作，如果某个 Controller 中的方法我们不需要拦截掉，即可在该方法上加上我们自定义的注解即可，下面先定义一个注解： 1234567/** * 该注解用来指定某个方法不用拦截 */@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface UnInterception {} 然后在 Controller 中的某个方法上添加该注解，在拦截器处理方法中添加该注解取消拦截的逻辑，如下： 1234567891011121314151617@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { HandlerMethod handlerMethod = (HandlerMethod) handler; Method method = handlerMethod.getMethod(); String methodName = method.getName(); logger.info(\"====拦截到了方法：{}，在该方法执行之前执行====\", methodName); // 通过方法，可以获取该方法上的自定义注解，然后通过注解来判断该方法是否要被拦截 // @UnInterception 是我们自定义的注解 UnInterception unInterception = method.getAnnotation(UnInterception.class); if (null != unInterception) { return true; } // 返回true才会继续执行，返回false则取消当前请求 return true;} Controller 中的方法代码可以参见源码，重启项目在浏览器中输入 http://localhost:8080/interceptor/test2?token=123 测试一下，可以看出，加了该注解的方法不会被拦截。 3. 总结本节主要介绍了 Spring Boot 中拦截器的使用，从拦截器的创建、配置，到拦截器对静态资源的影响，都做了详细的分析。Spring Boot 2.0 之后拦截器的配置支持两种方式，可以根据实际情况选择不同的配置方式。最后结合实际中的使用，举了两个常用的场景，希望读者能够认真消化，掌握拦截器的使用。 课程源代码下载地址：戳我下载 欢迎关注我的为微信公众号：武哥聊编程 第14课：Spring Boot 中集成Redis1. Redis 介绍Redis 是一种非关系型数据库（NoSQL），NoSQL 是以 key-value 的形式存储的，和传统的关系型数据库不一样，不一定遵循传统数据库的一些基本要求，比如说 SQL 标准，ACID 属性，表结构等等，这类数据库主要有以下特点：非关系型的、分布式的、开源的、水平可扩展的。NoSQL 使用场景有：对数据高并发读写、对海量数据的高效率存储和访问、对数据的高可扩展性和高可用性等等。Redis 的 key 可以是字符串、哈希、链表、集合和有序集合。value 类型很多，包括 String、list、set、zset。这些数据类型都支持 push/pop、add/remove、取交集和并集以及更多更丰富的操作，Redis 也支持各种不同方式的排序。为了保证效率，数据都是在缓存在内存中，它也可以周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件中。 有了 redis 有哪些好处呢？举个比较简单的例子，看下图： Redis 集群和 Mysql 是同步的，首先会从 redis 中获取数据，如果 redis 挂了，再从 mysql 中获取数据，这样网站就不会挂掉。更多关于 redis 的介绍以及使用场景，可以谷歌和百度，在这就不赘述了。 2. Redis 安装本课程是在 vmvare 虚拟机中来安装的 redis （centos 7），学习的时候如果有自己的阿里云服务器，也可以在阿里云中来安装 redis，都可以。只要能 ping 的通云主机或者虚拟机的 ip，然后在虚拟机或者云主机中放行对应的端口（或者关掉防火墙）即可访问 redis。下面来介绍一下 redis 的安装过程： 安装 gcc 编译 因为后面安装redis的时候需要编译，所以事先得先安装gcc编译。阿里云主机已经默认安装了 gcc，如果是自己安装的虚拟机，那么需要先安装一下 gcc： 1yum install gcc-c++ 下载 redis 有两种方式下载安装包，一种是去官网上下载（https://redis.io），然后将安装包考到 centos 中，另种方法是直接使用 wget 来下载： 1wget http://download.redis.io/releases/redis-3.2.8.tar.gz 如果没有安装过 wget，可以通过如下命令安装： 1yum install wget 解压安装 解压安装包： 1tar –vzxf redis-3.2.8.tar.gz 然后将解压的文件夹 redis-3.2.8 放到 /usr/local/ 下，一般安装软件都放在 /usr/local 下。然后进入 /usr/local/redis-3.2.8/ 文件夹下，执行 make 命令即可完成安装。【注】如果 make 失败，可以尝试如下命令： 12make MALLOC=libcmake install 修改配置文件 安装成功之后，需要修改一下配置文件，包括允许接入的 ip，允许后台执行，设置密码等等。打开 redis 配置文件：vi redis.conf在命令模式下输入 /bind 来查找 bind 配置，按 n 来查找下一个，找到配置后，将 bind 配置成 0.0.0.0，允许任意服务器来访问 redis，即： 1bind 0.0.0.0 使用同样的方法，将 daemonize 改成 yes （默认为 no），允许 redis 在后台执行。将 requirepass 注释打开，并设置密码为 123456（密码自己设置）。 启动 redis 在 redis-3.2.8 目录下，指定刚刚修改好的配置文件 redis.conf 来启动 redis： 1redis-server ./redis.conf 再启动 redis 客户端： 1redis-cli 由于我们设置了密码，在启动客户端之后，输入 auth 123456 即可登录进入客户端。然后我们来测试一下，往 redis 中插入一个数据： 1set name CSDN 然后来获取 name 1get name 如果正常获取到 CSDN，则说明没有问题。 3. Spring Boot 集成 Redis3.1 依赖导入Spring Boot 集成 redis 很方便，只需要导入一个 redis 的 starter 依赖即可。如下： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--阿里巴巴fastjson --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.35&lt;/version&gt;&lt;/dependency&gt; 这里也导入阿里巴巴的 fastjson 是为了在后面我们要存一个实体，为了方便把实体转换成 json 字符串存进去。 3.2 Redis 配置导入了依赖之后，我们在 application.yml 文件里配置 redis： 123456789101112131415161718192021server: port: 8080spring: #redis相关配置 redis: database: 5 # 配置redis的主机地址，需要修改成自己的 host: 192.168.48.190 port: 6379 password: 123456 timeout: 5000 jedis: pool: # 连接池中的最大空闲连接，默认值也是8。 max-idle: 500 # 连接池中的最小空闲连接，默认值也是0。 min-idle: 50 # 如果赋值为-1，则表示不限制；如果pool已经分配了maxActive个jedis实例，则此时pool的状态为exhausted(耗尽) max-active: 1000 # 等待可用连接的最大时间，单位毫秒，默认值为-1，表示永不超时。如果超过等待时间，则直接抛出JedisConnectionException max-wait: 2000 3.3 常用 api 介绍Spring Boot 对 redis 的支持已经非常完善了，丰富的 api 已经足够我们日常的开发，这里我介绍几个最常用的供大家学习，其他 api 希望大家自己多学习，多研究。用到会去查即可。 有两个 redis 模板：RedisTemplate 和 StringRedisTemplate。我们不使用 RedisTemplate，RedisTemplate 提供给我们操作对象，操作对象的时候，我们通常是以 json 格式存储，但在存储的时候，会使用 Redis 默认的内部序列化器；导致我们存进里面的是乱码之类的东西。当然了，我们可以自己定义序列化，但是比较麻烦，所以使用 StringRedisTemplate 模板。StringRedisTemplate 主要给我们提供字符串操作，我们可以将实体类等转成 json 字符串即可，在取出来后，也可以转成相应的对象，这就是上面我导入了阿里 fastjson 的原因。 3.3.1 redis:string 类型新建一个 RedisService，注入 StringRedisTemplate，使用 stringRedisTemplate.opsForValue() 可以获取 ValueOperations&lt;String, String&gt; 对象，通过该对象即可读写 redis 数据库了。如下： 1234567891011121314151617181920212223public class RedisService { @Resource private StringRedisTemplate stringRedisTemplate; /** * set redis: string类型 * @param key key * @param value value */ public void setString(String key, String value){ ValueOperations&lt;String, String&gt; valueOperations = stringRedisTemplate.opsForValue(); valueOperations.set(key, value); } /** * get redis: string类型 * @param key key * @return */ public String getString(String key){ return stringRedisTemplate.opsForValue().get(key); } 该对象操作的是 string，我们也可以存实体类，只需要将实体类转换成 json 字符串即可。下面来测试一下： 123456789101112131415161718192021@RunWith(SpringRunner.class)@SpringBootTestpublic class Course14ApplicationTests { private static final Logger logger = LoggerFactory.getLogger(Course14ApplicationTests.class); @Resource private RedisService redisService; @Test public void contextLoads() { //测试redis的string类型 redisService.setString(\"weichat\",\"程序员私房菜\"); logger.info(\"我的微信公众号为：{}\", redisService.getString(\"weichat\")); // 如果是个实体，我们可以使用json工具转成json字符串， User user = new User(\"CSDN\", \"123456\"); redisService.setString(\"userInfo\", JSON.toJSONString(user)); logger.info(\"用户信息：{}\", redisService.getString(\"userInfo\")); }} 先启动 redis，然后运行这个测试用例，观察控制台打印的日志如下： 12我的微信公众号为：程序员私房菜用户信息：{&quot;password&quot;:&quot;123456&quot;,&quot;username&quot;:&quot;CSDN&quot;} 3.3.2 redis:hash 类型hash 类型其实原理和 string 一样的，但是有两个 key，使用 stringRedisTemplate.opsForHash() 可以获取 HashOperations&lt;String, Object, Object&gt; 对象。比如我们要存储订单信息，所有订单信息都放在 order 下，针对不同用户的订单实体，可以通过用户的 id 来区分，这就相当于两个 key 了。 123456789101112131415161718192021222324252627@Servicepublic class RedisService { @Resource private StringRedisTemplate stringRedisTemplate; /** * set redis: hash类型 * @param key key * @param filedKey filedkey * @param value value */ public void setHash(String key, String filedKey, String value){ HashOperations&lt;String, Object, Object&gt; hashOperations = stringRedisTemplate.opsForHash(); hashOperations.put(key,filedKey, value); } /** * get redis: hash类型 * @param key key * @param filedkey filedkey * @return */ public String getHash(String key, String filedkey){ return (String) stringRedisTemplate.opsForHash().get(key, filedkey); }} 可以看出，hash 和 string 没啥两样，只不过多了个参数，Spring Boot 中操作 redis 非常简单方便。来测试一下： 123456789101112131415@SpringBootTestpublic class Course14ApplicationTests { private static final Logger logger = LoggerFactory.getLogger(Course14ApplicationTests.class); @Resource private RedisService redisService; @Test public void contextLoads() { //测试redis的hash类型 redisService.setHash(\"user\", \"name\", JSON.toJSONString(user)); logger.info(\"用户姓名：{}\", redisService.getHash(\"user\",\"name\")); }} 3.3.3 redis:list 类型使用 stringRedisTemplate.opsForList() 可以获取 ListOperations&lt;String, String&gt; listOperations redis 列表对象，该列表是个简单的字符串列表，可以支持从左侧添加，也可以支持从右侧添加，一个列表最多包含 2 ^ 32 -1 个元素。 12345678910111213141516171819202122232425262728@Servicepublic class RedisService { @Resource private StringRedisTemplate stringRedisTemplate; /** * set redis:list类型 * @param key key * @param value value * @return */ public long setList(String key, String value){ ListOperations&lt;String, String&gt; listOperations = stringRedisTemplate.opsForList(); return listOperations.leftPush(key, value); } /** * get redis:list类型 * @param key key * @param start start * @param end end * @return */ public List&lt;String&gt; getList(String key, long start, long end){ return stringRedisTemplate.opsForList().range(key, start, end); }} 可以看出，这些 api 都是一样的形式，方便记忆也方便使用。具体的 api 细节我就不展开了，大家可以自己看 api 文档。其实，这些 api 根据参数和返回值也能知道它们是做什么用的。来测试一下： 1234567891011121314151617181920@RunWith(SpringRunner.class)@SpringBootTestpublic class Course14ApplicationTests { private static final Logger logger = LoggerFactory.getLogger(Course14ApplicationTests.class); @Resource private RedisService redisService; @Test public void contextLoads() { //测试redis的list类型 redisService.setList(\"list\", \"football\"); redisService.setList(\"list\", \"basketball\"); List&lt;String&gt; valList = redisService.getList(\"list\",0,-1); for(String value :valList){ logger.info(\"list中有：{}\", value); } }} 4. 总结本节主要介绍了 redis 的使用场景、安装过程，以及 Spring Boot 中集成 redis 的详细步骤。在实际项目中，通常都用 redis 作为缓存，在查询数据库的时候，会先从 redis 中查找，如果有信息，则从 redis 中取；如果没有，则从数据库中查，并且同步到 redis 中，下次 redis 中就有了。更新和删除也是如此，都需要同步到 redis。redis 在高并发场景下运用的很多。 课程源代码下载地址：戳我下载 欢迎关注我的为微信公众号：武哥聊编程 第15课： Spring Boot中集成ActiveMQ1. JMS 和 ActiveMQ 介绍1.1 JMS 是啥百度百科的解释： JMS 即 Java 消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的 API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java 消息服务是一个与具体平台无关的 API，绝大多数 MOM 提供商都对 JMS 提供支持。 JMS 只是接口，不同的提供商或者开源组织对其有不同的实现，ActiveMQ 就是其中之一，它支持JMS，是 Apache 推出的。JMS 中有几个对象模型： 连接工厂：ConnectionFactoryJMS连接：ConnectionJMS会话：SessionJMS目的：DestinationJMS生产者：ProducerJMS消费者：ConsumerJMS消息两种类型：点对点和发布/订阅。 可以看出 JMS 实际上和 JDBC 有点类似，JDBC 是可以用来访问许多不同关系数据库的 API，而 JMS 则提供同样与厂商无关的访问方法，以访问消息收发服务。本文主要使用 ActiveMQ。 1.2 ActiveMQActiveMQ 是 Apache 的一个能力强劲的开源消息总线。ActiveMQ 完全支持JMS1.1和J2EE 1.4规范，尽管 JMS 规范出台已经是很久的事情了，但是 JMS 在当今的 Java EE 应用中间仍然扮演着特殊的地位。ActiveMQ 用在异步消息的处理上，所谓异步消息即消息发送者无需等待消息接收者的处理以及返回，甚至无需关心消息是否发送成功。 异步消息主要有两种目的地形式，队列（queue）和主题（topic），队列用于点对点形式的消息通信，主题用于发布/订阅式的消息通信。本章节主要来学习一下在 Spring Boot 中如何使用这两种形式的消息。 2. ActiveMQ安装使用 ActiveMQ 首先需要去官网下载，官网地址为：http://activemq.apache.org/本课程使用的版本是 apache-activemq-5.15.3，下载后解压缩会有一个名为 apache-activemq-5.15.3 的文件夹，没错，这就安装好了，非常简单，开箱即用。打开文件夹会看到里面有个 activemq-all-5.15.3.jar，这个 jar 我们是可以加进工程里的，但是使用 maven 的话，这个 jar 我们不需要。 在使用 ActiveMQ 之前，首先得先启动，刚才解压后的目录中有个 bin 目录，里面有 win32 和 win64 两个目录，根据自己电脑选择其中一个打开运行里面的 activemq.bat 即可启动 ActiveMQ。消息生产者生产消息发布到queue中，然后消息消费者从queue中取出，并且消费消息。这里需要注意：消息被消费者消费以后，queue中不再有存储，所以消息消费者不可消费到已经被消费的消息。Queue支持存在多个消息消费者，但是对一个消息而言，只会有一个消费者可以消费启动完成后，在浏览器中输入 http://127.0.0.1:8161/admin/ 来访问 ActiveMQ 的服务器，用户名和密码是 admin/admin。如下： 我们可以看到有 Queues 和 Topics 这两个选项，这两个选项分别是点对点消息和发布/订阅消息的查看窗口。何为点对点消息和发布/订阅消息呢？ 点对点消息：消息生产者生产消息发布到 queue 中，然后消息消费者从 queue 中取出，并且消费消息。这里需要注意：消息被消费者消费以后，queue 中不再有存储，所以消息消费者不可消费到已经被消费的消息。Queue 支持存在多个消息消费者，但是对一个消息而言，只会有一个消费者可以消费。 发布/订阅消息：消息生产者（发布）将消息发布到 topic 中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到 topic 的消息会被所有订阅者消费。下面分析具体的实现方式。 3. ActiveMQ集成3.1 依赖导入和配置在 Spring Boot 中集成 ActiveMQ 需要导入如下 starter 依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt;&lt;/dependency&gt; 然后在 application.yml 配置文件中，对 activemq 做一下配置： 12345678spring: activemq: # activemq url broker-url: tcp://localhost:61616 in-memory: true pool: # 如果此处设置为true，需要添加activemq-pool的依赖包，否则会自动配置失败，无法注入JmsMessagingTemplate enabled: false 3.2 Queue 和 Topic 的创建首先我们需要创建两种消息 Queue 和 Topic，这两种消息的创建，我们放到 ActiveMqConfig 中来创建，如下： 12345678910111213141516171819202122232425/** * activemq的配置 * @author shengwu ni */@Configurationpublic class ActiveMqConfig { /** * 发布/订阅模式队列名称 */ public static final String TOPIC_NAME = \"activemq.topic\"; /** * 点对点模式队列名称 */ public static final String QUEUE_NAME = \"activemq.queue\"; @Bean public Destination topic() { return new ActiveMQTopic(TOPIC_NAME); } @Bean public Destination queue() { return new ActiveMQQueue(QUEUE_NAME); }} 可以看出创建 Queue 和 Topic 两种消息，分别使用 new ActiveMQQueue 和 new ActiveMQTopic 来创建，分别跟上对应消息的名称即可。这样在其他地方就可以直接将这两种消息作为组件注入进来了。 3.3 消息的发送接口在 Spring Boot 中，我们只要注入 JmsMessagingTemplate 模板即可快速发送消息，如下： 1234567891011121314/** * 消息发送者 * @author shengwu ni */@Servicepublic class MsgProducer { @Resource private JmsMessagingTemplate jmsMessagingTemplate; public void sendMessage(Destination destination, String msg) { jmsMessagingTemplate.convertAndSend(destination, msg); }} convertAndSend 方法中第一个参数是消息发送的目的地，第二个参数是具体的消息内容。 3.4 点对点消息生产与消费3.4.1 点对点消息的生产消息的生产，我们放到 Controller 中来做，由于上面已经生成了 Queue 消息的组件，所以在 Controller 中我们直接注入进来即可。然后调用上文的消息发送方法 sendMessage 即可成功生产一条消息。 1234567891011121314151617181920212223/** * ActiveMQ controller * @author shengwu ni */@RestController@RequestMapping(\"/activemq\")public class ActiveMqController { private static final Logger logger = LoggerFactory.getLogger(ActiveMqController.class); @Resource private MsgProducer producer; @Resource private Destination queue; @GetMapping(\"/send/queue\") public String sendQueueMessage() { logger.info(\"===开始发送点对点消息===\"); producer.sendMessage(queue, \"Queue: hello activemq!\"); return \"success\"; }} 3.4.2 点对点消息的消费点对点消息的消费很简单，只要我们指定目的地即可，jms 监听器一直在监听是否有消息过来，如果有，则消费。 12345678910111213141516/** * 消息消费者 * @author shengwu ni */@Servicepublic class QueueConsumer { /** * 接收点对点消息 * @param msg */ @JmsListener(destination = ActiveMqConfig.QUEUE_NAME) public void receiveQueueMsg(String msg) { System.out.println(\"收到的消息为：\" + msg); }} 可以看出，使用 @JmsListener 注解来指定要监听的目的地，在消息接收方法内部，我们可以根据具体的业务需求做相应的逻辑处理即可。 3.4.3 测试一下启动项目，在浏览器中输入：http://localhost:8081/activemq/send/queue，观察控制台的输出日志，出现下面的日志说明消息发送和消费成功。 1收到的消息为：Queue: hello activemq! 3.5 发布/订阅消息的生产和消费3.5.1 发布/订阅消息的生产和点对点消息一样，我们注入 topic 并调用 producer 的 sendMessage 方法即可发送订阅消息，如下，不再赘述： 12345678910111213141516171819@RestController@RequestMapping(\"/activemq\")public class ActiveMqController { private static final Logger logger = LoggerFactory.getLogger(ActiveMqController.class); @Resource private MsgProducer producer; @Resource private Destination topic; @GetMapping(\"/send/topic\") public String sendTopicMessage() { logger.info(\"===开始发送订阅消息===\"); producer.sendMessage(topic, \"Topic: hello activemq!\"); return \"success\"; }} 3.5.2 发布/订阅消息的消费发布/订阅消息的消费和点对点不同，订阅消息支持多个消费者一起消费。其次，Spring Boot 中默认的时点对点消息，所以在使用 topic 时，会不起作用，我们需要在配置文件 application.yml 中添加一个配置： 123spring: jms: pub-sub-domain: true 该配置是 false 的话，则为点对点消息，也是 Spring Boot 默认的。这样是可以解决问题，但是如果这样配置的话，上面提到的点对点消息又不能正常消费了。所以二者不可兼得，这并非一个好的解决办法。 比较好的解决办法是，我们定义一个工厂，@JmsListener 注解默认只接收 queue 消息，如果要接收 topic 消息，需要设置一下 containerFactory。我们还在上面的那个 ActiveMqConfig 配置类中添加： 123456789101112131415161718192021/** * activemq的配置 * * @author shengwu ni */@Configurationpublic class ActiveMqConfig { // 省略其他内容 /** * JmsListener注解默认只接收queue消息,如果要接收topic消息,需要设置containerFactory */ @Bean public JmsListenerContainerFactory topicListenerContainer(ConnectionFactory connectionFactory) { DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory(); factory.setConnectionFactory(connectionFactory); // 相当于在application.yml中配置：spring.jms.pub-sub-domain=true factory.setPubSubDomain(true); return factory; }} 经过这样的配置之后，我们在消费的时候，在 @JmsListener 注解中指定这个容器工厂即可消费 topic 消息。如下： 1234567891011121314151617/** * Topic消息消费者 * @author shengwu ni */@Servicepublic class TopicConsumer1 { /** * 接收订阅消息 * @param msg */ @JmsListener(destination = ActiveMqConfig.TOPIC_NAME, containerFactory = \"topicListenerContainer\") public void receiveTopicMsg(String msg) { System.out.println(\"收到的消息为：\" + msg); }} 指定 containerFactory 属性为上面我们自己配置的 topicListenerContainer 即可。由于 topic 消息可以多个消费，所以该消费的类可以拷贝几个一起测试一下，这里我就不贴代码了，可以参考我的源码测试。 3.5.3 测试一下启动项目，在浏览器中输入：http://localhost:8081/activemq/send/topic，观察控制台的输出日志，出现下面的日志说明消息发送和消费成功。 12收到的消息为：Topic: hello activemq!收到的消息为：Topic: hello activemq! 4. 总结本章主要介绍了 jms 和 activemq 的相关概念、activemq 的安装与启动。详细分析了 Spring Boot 中点对点消息和发布/订阅消息两种方式的配置、消息生产和消费方式。ActiveMQ 是能力强劲的开源消息总线，在异步消息的处理上很有用，希望大家好好消化一下。 课程源代码下载地址：戳我下载 欢迎关注我的为微信公众号：武哥聊编程 第16课：Spring Boot中集成 ShiroShiro 是一个强大、简单易用的 Java 安全框架，主要用来更便捷的认证，授权，加密，会话管等等，可为任何应用提供安全保障。本课程主要来介绍 Shiro 的认证和授权功能。 1. Shiro 三大核心组件Shiro 有三大核心的组件：Subject、SecurityManager 和 Realm。先来看一下它们之间的关系。 Subject：认证主体。它包含两个信息：Principals 和 Credentials。看一下这两个信息具体是什么。 Principals：身份。可以是用户名，邮件，手机号码等等，用来标识一个登录主体身份；Credentials：凭证。常见有密码，数字证书等等。 说白了，就是需要认证的东西，最常见的就是用户名密码了，比如用户在登录的时候，Shiro 需要去进行身份认证，就需要 Subject 认证主体。 SecurityManager：安全管理员。这是 Shiro 架构的核心，它就像 Shiro 内部所有原件的保护伞一样。我们在项目中一般都会配置 SecurityManager，开发人员大部分精力主要是在 Subject 认证主体上面。我们在与 Subject 进行交互的时候，实际上是 SecurityManager 在背后做一些安全操作。 Realms：Realms 是一个域，它是连接 Shiro 和具体应用的桥梁，当需要与安全数据交互的时候，比如用户账户、访问控制等，Shiro 就会从一个或多个 Realms 中去查找。我们一般会自己定制 Realm，这在下文会详细说明。 1. Shiro 身份和权限认证1.2 Shiro 身份认证我们来分析一下 Shiro 身份认证的过程，看一下官方的一个认证图： Step1：应用程序代码在调用 Subject.login(token) 方法后，传入代表最终用户的身份和凭证的 AuthenticationToken 实例 token。 Step2：将 Subject 实例委托给应用程序的 SecurityManager（Shiro的安全管理）来开始实际的认证工作。这里开始真正的认证工作了。 Step3，4，5：然后 SecurityManager 就会根据具体的 realm 去进行安全认证了。 从图中可以看出，realm 可以自定义（Custom Realm）。 1.3 Shiro 权限认证权限认证，也就是访问控制，即在应用中控制谁能访问哪些资源。在权限认证中，最核心的三个要素是：权限，角色和用户。 权限（permission）：即操作资源的权利，比如访问某个页面，以及对某个模块的数据的添加，修改，删除，查看的权利；角色（role）：指的是用户担任的的角色，一个角色可以有多个权限；用户（user）：在 Shiro 中，代表访问系统的用户，即上面提到的 Subject 认证主体。 它们之间的的关系可以用下图来表示： 一个用户可以有多个角色，而不同的角色可以有不同的权限，也可由有相同的权限。比如说现在有三个角色，1是普通角色，2也是普通角色，3是管理员，角色1只能查看信息，角色2只能添加信息，管理员都可以，而且还可以删除信息，类似于这样。 2. Spring Boot 集成 Shiro 过程2.1 依赖导入Spring Boot 2.0.3 集成 Shiro 需要导入如下 starter 依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt;&lt;/dependency&gt; 2.2 数据库表数据初始化这里主要涉及到三张表：用户表、角色表和权限表，其实在 demo 中，我们完全可以自己模拟一下，不用建表，但是为了更加接近实际情况，我们还是加入 mybatis，来操作数据库。下面是数据库表的脚本。 123456789101112131415161718192021222324CREATE TABLE `t_role` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键', `rolename` varchar(20) DEFAULT NULL COMMENT '角色名称', PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8CREATE TABLE `t_user` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '用户主键', `username` varchar(20) NOT NULL COMMENT '用户名', `password` varchar(20) NOT NULL COMMENT '密码', `role_id` int(11) DEFAULT NULL COMMENT '外键关联role表', PRIMARY KEY (`id`), KEY `role_id` (`role_id`), CONSTRAINT `t_user_ibfk_1` FOREIGN KEY (`role_id`) REFERENCES `t_role` (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8CREATE TABLE `t_permission` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键', `permissionname` varchar(50) NOT NULL COMMENT '权限名', `role_id` int(11) DEFAULT NULL COMMENT '外键关联role', PRIMARY KEY (`id`), KEY `role_id` (`role_id`), CONSTRAINT `t_permission_ibfk_1` FOREIGN KEY (`role_id`) REFERENCES `t_role` (`id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 其中，t_user，t_role 和 t_permission，分别存储用户信息，角色信息和权限信息，表建立好了之后，我们往表里插入一些测试数据。t_user 表：|id|username|password|role_id||:–:|:–:|:–:|:–:||1|csdn1|123456|1||2|csdn2|123456|2||3|csdn3|123456|3| t_role 表：|id|rolename||:–:|:–:||1|admin||2|teacher||3|student| t_permission 表：|id|permissionname|role_id||:–:|:–:|:–:||1|user:*|1||2|student:*|2| 解释一下这里的权限：user:*表示权限可以是 user:create 或者其他，* 处表示一个占位符，我们可以自己定义，具体的会在下文 Shiro 配置那里说明。 2.2 自定义 Realm有了数据库表和数据之后，我们开始自定义 realm，自定义 realm 需要继承 AuthorizingRealm 类，因为该类封装了很多方法，它也是一步步继承自 Realm 类的，继承了 AuthorizingRealm 类后，需要重写两个方法： doGetAuthenticationInfo() 方法：用来验证当前登录的用户，获取认证信息doGetAuthorizationInfo() 方法：用来为当前登陆成功的用户授予权限和角色 具体实现如下，相关的解释我放在代码的注释中，这样更加方便直观： 1234567891011121314151617181920212223242526272829303132333435363738/** * 自定义realm * @author shengwu ni */public class MyRealm extends AuthorizingRealm { @Resource private UserService userService; @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) { // 获取用户名 String username = (String) principalCollection.getPrimaryPrincipal(); SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo(); // 给该用户设置角色，角色信息存在t_role表中取 authorizationInfo.setRoles(userService.getRoles(username)); // 给该用户设置权限，权限信息存在t_permission表中取 authorizationInfo.setStringPermissions(userService.getPermissions(username)); return authorizationInfo; } @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException { // 根据token获取用户名，如果您不知道该该token怎么来的，先可以不管，下文会解释 String username = (String) authenticationToken.getPrincipal(); // 根据用户名从数据库中查询该用户 User user = userService.getByUsername(username); if(user != null) { // 把当前用户存到session中 SecurityUtils.getSubject().getSession().setAttribute(\"user\", user); // 传入用户名和密码进行身份认证，并返回认证信息 AuthenticationInfo authcInfo = new SimpleAuthenticationInfo(user.getUsername(), user.getPassword(), \"myRealm\"); return authcInfo; } else { return null; } }} 从上面两个方法中可以看出：验证身份的时候是根据用户输入的用户名先从数据库中查出该用户名对应的用户，这时候并没有涉及到密码，也就是说到这一步的时候，即使用户输入的密码不对，也是可以查出来该用户的，然后将该用户的正确信息封装到 authcInfo 中返回给 Shiro，接下来就是Shiro的事了，它会根据这里面的真实信息与用户前台输入的用户名和密码进行校验， 这个时候也要校验密码了，如果校验通过就让用户登录，否则跳转到指定页面。同理，权限验证的时候也是先根据用户名从数据库中获取与该用户名有关的角色和权限，然后封装到 authorizationInfo 中返回给 Shiro。 2.3 Shiro 配置自定义的 realm 写好了，接下来需要对 Shiro 进行配置了。我们主要配置三个东西：自定义 realm、安全管理器 SecurityManager 和 Shiro 过滤器。如下： 配置自定义 realm： 12345678910111213141516@Configurationpublic class ShiroConfig { private static final Logger logger = LoggerFactory.getLogger(ShiroConfig.class); /** * 注入自定义的realm * @return MyRealm */ @Bean public MyRealm myAuthRealm() { MyRealm myRealm = new MyRealm(); logger.info(\"====myRealm注册完成=====\"); return myRealm; }} 配置安全管理器 SecurityManager： 1234567891011121314151617@Configurationpublic class ShiroConfig { private static final Logger logger = LoggerFactory.getLogger(ShiroConfig.class); /** * 注入安全管理器 * @return SecurityManager */ @Bean public SecurityManager securityManager() { // 将自定义realm加进来 DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(myAuthRealm()); logger.info(\"====securityManager注册完成====\"); return securityManager; }} 配置 SecurityManager 时，需要将上面的自定义 realm 添加进来，这样的话 Shiro 才会走到自定义的 realm 中。 配置 Shiro 过滤器： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Configurationpublic class ShiroConfig { private static final Logger logger = LoggerFactory.getLogger(ShiroConfig.class); /** * 注入Shiro过滤器 * @param securityManager 安全管理器 * @return ShiroFilterFactoryBean */ @Bean public ShiroFilterFactoryBean shiroFilter(SecurityManager securityManager) { // 定义shiroFactoryBean ShiroFilterFactoryBean shiroFilterFactoryBean=new ShiroFilterFactoryBean(); // 设置自定义的securityManager shiroFilterFactoryBean.setSecurityManager(securityManager); // 设置默认登录的url，身份认证失败会访问该url shiroFilterFactoryBean.setLoginUrl(\"/login\"); // 设置成功之后要跳转的链接 shiroFilterFactoryBean.setSuccessUrl(\"/success\"); // 设置未授权界面，权限认证失败会访问该url shiroFilterFactoryBean.setUnauthorizedUrl(\"/unauthorized\"); // LinkedHashMap是有序的，进行顺序拦截器配置 Map&lt;String,String&gt; filterChainMap = new LinkedHashMap&lt;&gt;(); // 配置可以匿名访问的地址，可以根据实际情况自己添加，放行一些静态资源等，anon表示放行 filterChainMap.put(\"/css/**\", \"anon\"); filterChainMap.put(\"/imgs/**\", \"anon\"); filterChainMap.put(\"/js/**\", \"anon\"); filterChainMap.put(\"/swagger-*/**\", \"anon\"); filterChainMap.put(\"/swagger-ui.html/**\", \"anon\"); // 登录url 放行 filterChainMap.put(\"/login\", \"anon\"); // “/user/admin” 开头的需要身份认证，authc表示要身份认证 filterChainMap.put(\"/user/admin*\", \"authc\"); // “/user/student” 开头的需要角色认证，是“admin”才允许 filterChainMap.put(\"/user/student*/**\", \"roles[admin]\"); // “/user/teacher” 开头的需要权限认证，是“user:create”才允许 filterChainMap.put(\"/user/teacher*/**\", \"perms[\\\"user:create\\\"]\"); // 配置logout过滤器 filterChainMap.put(\"/logout\", \"logout\"); // 设置shiroFilterFactoryBean的FilterChainDefinitionMap shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainMap); logger.info(\"====shiroFilterFactoryBean注册完成====\"); return shiroFilterFactoryBean; }} 配置 Shiro 过滤器时会传入一个安全管理器，可以看出，这是一环套一环，reaml -&gt; SecurityManager -&gt; filter。在过滤器中，我们需要定义一个 shiroFactoryBean，然后将 SecurityManager 添加进来，结合上面代码可以看出，要配置的东西主要有： 默认登录的 url：身份认证失败会访问该 url认证成功之后要跳转的 url权限认证失败会访问该 url需要拦截或者放行的 url：这些都放在一个 map 中 从上述代码中可以看出，在 map 中，针对不同的 url，有不同的权限要求，这里总结一下常用的几个权限。|Filter|说明||:–:|:–:||anon|开放权限，可以理解为匿名用户或游客，可以直接访问的||authc|需要身份认证的||logout|注销，执行后会直接跳转到 shiroFilterFactoryBean.setLoginUrl(); 设置的 url，即登录页面||roles[admin]|参数可写多个，表示是某个或某些角色才能通过，多个参数时写 roles[“admin，user”]，当有多个参数时必须每个参数都通过才算通过||perms[user]|参数可写多个，表示需要某个或某些权限才能通过，多个参数时写 perms[“user, admin”]，当有多个参数时必须每个参数都通过才算通过| 2.4 使用 Shiro 进行认证到这里，我们对 Shiro 的准备工作都做完了，接下来开始使用 Shiro 进行认证工作。我们首先来设计几个接口： 接口一： 使用 http://localhost:8080/user/admin 来验证身份认证接口二： 使用 http://localhost:8080/user/student 来验证角色认证接口三： 使用 http://localhost:8080/user/teacher 来验证权限认证接口四： 使用 http://localhost:8080/user/login 来实现用户登录 然后来一下认证的流程： 流程一： 直接访问接口一（此时还未登录），认证失败，跳转到 login.html 页面让用户登录，登录会请求接口四，实现用户登录功能，此时 Shiro 已经保存了用户信息了。流程二： 再次访问接口一（此时用户已经登录），认证成功，跳转到 success.html 页面，展示用户信息。流程三： 访问接口二，测试角色认证是否成功。流程四： 访问接口三，测试权限认证是否成功。 2.4.1 身份、角色、权限认证接口1234567891011121314151617181920212223242526272829303132333435@Controller@RequestMapping(\"/user\")public class UserController { /** * 身份认证测试接口 * @param request * @return */ @RequestMapping(\"/admin\") public String admin(HttpServletRequest request) { Object user = request.getSession().getAttribute(\"user\"); return \"success\"; } /** * 角色认证测试接口 * @param request * @return */ @RequestMapping(\"/student\") public String student(HttpServletRequest request) { return \"success\"; } /** * 权限认证测试接口 * @param request * @return */ @RequestMapping(\"/teacher\") public String teacher(HttpServletRequest request) { return \"success\"; }} 这三个接口很简单，直接返回到指定页面展示即可，只要认证成功就会正常跳转，如果认证失败，就会跳转到上文 ShrioConfig 中配置的页面进行展示。 2.4.2 用户登录接口123456789101112131415161718192021222324252627282930@Controller@RequestMapping(\"/user\")public class UserController { /** * 用户登录接口 * @param user user * @param request request * @return string */ @PostMapping(\"/login\") public String login(User user, HttpServletRequest request) { // 根据用户名和密码创建token UsernamePasswordToken token = new UsernamePasswordToken(user.getUsername(), user.getPassword()); // 获取subject认证主体 Subject subject = SecurityUtils.getSubject(); try{ // 开始认证，这一步会跳到我们自定义的realm中 subject.login(token); request.getSession().setAttribute(\"user\", user); return \"success\"; }catch(Exception e){ e.printStackTrace(); request.getSession().setAttribute(\"user\", user); request.setAttribute(\"error\", \"用户名或密码错误！\"); return \"login\"; } }} 我们重点分析一下这个登录接口，首先会根据前端传过来的用户名和密码，创建一个 token，然后使用 SecurityUtils 来创建一个认证主体，接下来开始调用 subject.login(token) 开始进行身份认证了，注意这里传了刚刚创建的 token，就如注释中所述，这一步会跳转到我们自定义的 realm 中，进入 doGetAuthenticationInfo 方法，所以到这里，您就会明白该方法中那个参数 token 了。然后就是上文分析的那样，开始进行身份认证。 2.4.3 测试一下最后，启动项目，测试一下：浏览器请求 http://localhost:8080/user/admin 会进行身份认证，因为此时未登录，所以会跳转到 IndexController 中的 /login 接口，然后跳转到 login.html 页面让我们登录，使用用户名密码为 csdn/123456 登录之后，我们在浏览器中请求 http://localhost:8080/user/student 接口，会进行角色认证，因为数据库中 csdn1 的用户角色是 admin，所以和配置中的吻合，认证通过；我们再请求 http://localhost:8080/user/teacher 接口，会进行权限认证，因为数据库中 csdn1 的用户权限为 user:*，满足配置中的 user:create，所以认证通过。 接下来，我们点退出，系统会注销重新让我们登录，我们使用 csdn2 这个用户来登录，重复上述操作，当在进行角色认证和权限认证这两步时，就认证不通过了，因为数据库中 csdn2 这个用户存的角色和权限与配置中的不同，所以认证不通过。 3. 总结本节主要介绍了 Shiro 安全框架与 Spring Boot 的整合。先介绍了 Shiro 的三大核心组件已经它们的作用；然后介绍了 Shiro 的身份认证、角色认证和权限认证；最后结合代码，详细介绍了 Spring Boot 中是如何整合 Shiro 的，并设计了一套测试流程，逐步分析 Shiro 的工作流程和原理，让读者更直观地体会出 Shiro 的整套工作流程。Shiro 使用的很广泛，希望读者将其掌握，并能运用到实际项目中。 课程源代码下载地址：戳我下载 欢迎关注我的为微信公众号：武哥聊编程 第17课：Spring Boot中集成Lucence1. Lucence 和全文检索Lucene 是什么？看一下百度百科： Lucene是一套用于全文检索和搜寻的开源程式库，由 Apache 软件基金会支持和提供。Lucene 提供了一个简单却强大的应用程式接口，能够做全文索引和搜寻。在 Java 开发环境里 Lucene 是一个成熟的免费开源工具。就其本身而言，Lucene 是当前以及最近几年最受欢迎的免费 Java 信息检索程序库。——《百度百科》 1.1 全文检索这里提到了全文检索的概念，我们先来分析一下什么是全文检索，理解了全文检索之后，再理解 Lucene 的原理就非常简单了。 何为全文检索？举个例子，比如现在要在一个文件中查找某个字符串，最直接的想法就是从头开始检索，查到了就OK，这种对于小数据量的文件来说，很实用，但是对于大数据量的文件来说，就有点吃力了。或者说找包含某个字符串的文件，也是这样，如果在一个拥有几十个 G 的硬盘中找那效率可想而知，是很低的。 文件中的数据是属于非结构化数据，也就是说它没有什么结构可言，要解决上面提到的效率问题，首先我们得将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对这些有一定结构的数据进行搜索，从而达到搜索相对较快的目的。这就叫全文搜索。即先建立索引，再对索引进行搜索的过程。 1.2 Lucene 建立索引的方式那么 Lucene 中是如何建立索引的呢？假设现在有两篇文章，内容如下： 文章1的内容为：Tom lives in Guangzhou, I live in Guangzhou too.文章2的内容为：He once lived in Shanghai. 首先第一步是将文档传给分词组件（Tokenizer），分词组件会将文档分成一个个单词，并去除标点符号和停词。所谓的停词指的是没有特别意义的词，比如英文中的 a，the，too 等。经过分词后，得到词元（Token） 。如下： 文章1经过分词后的结果：[Tom] [lives] [Guangzhou] [I] [live] [Guangzhou]文章2经过分词后的结果：[He] [lives] [Shanghai] 然后将词元传给语言处理组件（Linguistic Processor），对于英语，语言处理组件一般会将字母变为小写，将单词缩减为词根形式，如 ”lives” 到 ”live” 等，将单词转变为词根形式，如 ”drove” 到 ”drive” 等。然后得到词（Term）。如下： 文章1经过处理后的结果：[tom] [live] [guangzhou] [i] [live] [guangzhou]文章2经过处理后的结果：[he] [live] [shanghai] 最后将得到的词传给索引组件（Indexer），索引组件经过处理，得到下面的索引结构： 关键词 文章号[出现频率] 出现位置 guangzhou 1[2] 3,6 he 2[1] 1 i 1[1] 4 live 1[2],2[1] 2,5,2 shanghai 2[1] 3 tom 1[1] 1 以上就是Lucene 索引结构中最核心的部分。它的关键字是按字符顺序排列的，因此 Lucene 可以用二元搜索算法快速定位关键词。实现时 Lucene 将上面三列分别作为词典文件（Term Dictionary）、频率文件（frequencies）和位置文件（positions）保存。其中词典文件不仅保存有每个关键词，还保留了指向频率文件和位置文件的指针，通过指针可以找到该关键字的频率信息和位置信息。搜索的过程是先对词典二元查找、找到该词，通过指向频率文件的指针读出所有文章号，然后返回结果，然后就可以在具体的文章中根据出现位置找到该词了。所以 Lucene 在第一次建立索引的时候可能会比较慢，但是以后就不需要每次都建立索引了，就快了。 理解了 Lucene 的分词原理，接下来我们在 Spring Boot 中集成 Lucene 并实现索引和搜索的功能。 2. Spring Boot 中集成 Lucence2.1 依赖导入首先需要导入 Lucene 的依赖，它的依赖有好几个，如下： 12345678910111213141516171819202122232425262728293031323334&lt;!-- Lucence核心包 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;lucene-core&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Lucene查询解析包 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;lucene-queryparser&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 常规的分词（英文） --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;lucene-analyzers-common&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--支持分词高亮 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;lucene-highlighter&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--支持中文分词 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.lucene&lt;/groupId&gt; &lt;artifactId&gt;lucene-analyzers-smartcn&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt;&lt;/dependency&gt; 最后一个依赖是用来支持中文分词的，因为默认是支持英文的。那个高亮的分词依赖是最后我要做一个搜索，然后将搜到的内容高亮显示，模拟当前互联网上的做法，大家可以运用到实际项目中去。 2.2 快速入门根据上文的分析，全文检索有两个步骤，先建立索引，再检索。所以为了测试这个过程，我新建两个 java 类，一个用来建立索引的，另一个用来检索。 2.2.1 建立索引我们自己弄几个文件，放到 D:\\lucene\\data 目录下，新建一个 Indexer 类来实现建立索引功能。首先在构造方法中初始化标准分词器和写索引实例。 12345678910111213141516171819202122public class Indexer { /** * 写索引实例 */ private IndexWriter writer; /** * 构造方法，实例化IndexWriter * @param indexDir * @throws Exception */ public Indexer(String indexDir) throws Exception { Directory dir = FSDirectory.open(Paths.get(indexDir)); //标准分词器，会自动去掉空格啊，is a the等单词 Analyzer analyzer = new StandardAnalyzer(); //将标准分词器配到写索引的配置中 IndexWriterConfig config = new IndexWriterConfig(analyzer); //实例化写索引对象 writer = new IndexWriter(dir, config); }} 在构造放发中传一个存放索引的文件夹路径，然后构建标准分词器（这是英文的），再使用标准分词器来实例化写索引对象。接下来就开始建立索引了，我将解释放到代码注释里，方便大家跟进。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 索引指定目录下的所有文件 * @param dataDir * @return * @throws Exception */public int indexAll(String dataDir) throws Exception { // 获取该路径下的所有文件 File[] files = new File(dataDir).listFiles(); if (null != files) { for (File file : files) { //调用下面的indexFile方法，对每个文件进行索引 indexFile(file); } } //返回索引的文件数 return writer.numDocs();}/** * 索引指定的文件 * @param file * @throws Exception */private void indexFile(File file) throws Exception { System.out.println(\"索引文件的路径：\" + file.getCanonicalPath()); //调用下面的getDocument方法，获取该文件的document Document doc = getDocument(file); //将doc添加到索引中 writer.addDocument(doc);}/** * 获取文档，文档里再设置每个字段，就类似于数据库中的一行记录 * @param file * @return * @throws Exception */private Document getDocument(File file) throws Exception { Document doc = new Document(); //开始添加字段 //添加内容 doc.add(new TextField(\"contents\", new FileReader(file))); //添加文件名，并把这个字段存到索引文件里 doc.add(new TextField(\"fileName\", file.getName(), Field.Store.YES)); //添加文件路径 doc.add(new TextField(\"fullPath\", file.getCanonicalPath(), Field.Store.YES)); return doc;} 这样就建立好索引了，我们在该类中写一个 main 方法测试一下： 1234567891011121314151617181920212223242526272829public static void main(String[] args) { //索引保存到的路径 String indexDir = \"D:\\\\lucene\"; //需要索引的文件数据存放的目录 String dataDir = \"D:\\\\lucene\\\\data\"; Indexer indexer = null; int indexedNum = 0; //记录索引开始时间 long startTime = System.currentTimeMillis(); try { // 开始构建索引 indexer = new Indexer(indexDir); indexedNum = indexer.indexAll(dataDir); } catch (Exception e) { e.printStackTrace(); } finally { try { if (null != indexer) { indexer.close(); } } catch (Exception e) { e.printStackTrace(); } } //记录索引结束时间 long endTime = System.currentTimeMillis(); System.out.println(\"索引耗时\" + (endTime - startTime) + \"毫秒\"); System.out.println(\"共索引了\" + indexedNum + \"个文件\"); } 我搞了两个 tomcat 相关的文件放到 D:\\lucene\\data 下了，执行完之后，看到控制台输出： 1234索引文件的路径：D:\\lucene\\data\\catalina.properties索引文件的路径：D:\\lucene\\data\\logging.properties索引耗时882毫秒共索引了2个文件 然后我们去 D:\\lucene\\ 目录下可以看到一些索引文件，这些文件不能删除，删除了就需要重新构建索引，否则没了索引，就无法去检索内容了。 ####2.2.2 检索内容 上面把这两个文件的索引建立好了，接下来我们就可以写检索程序了，在这两个文件中查找特定的词。 1234567891011121314151617181920212223242526272829303132333435public class Searcher { public static void search(String indexDir, String q) throws Exception { //获取要查询的路径，也就是索引所在的位置 Directory dir = FSDirectory.open(Paths.get(indexDir)); IndexReader reader = DirectoryReader.open(dir); //构建IndexSearcher IndexSearcher searcher = new IndexSearcher(reader); //标准分词器，会自动去掉空格啊，is a the等单词 Analyzer analyzer = new StandardAnalyzer(); //查询解析器 QueryParser parser = new QueryParser(\"contents\", analyzer); //通过解析要查询的String，获取查询对象，q为传进来的待查的字符串 Query query = parser.parse(q); //记录索引开始时间 long startTime = System.currentTimeMillis(); //开始查询，查询前10条数据，将记录保存在docs中 TopDocs docs = searcher.search(query, 10); //记录索引结束时间 long endTime = System.currentTimeMillis(); System.out.println(\"匹配\" + q + \"共耗时\" + (endTime-startTime) + \"毫秒\"); System.out.println(\"查询到\" + docs.totalHits + \"条记录\"); //取出每条查询结果 for(ScoreDoc scoreDoc : docs.scoreDocs) { //scoreDoc.doc相当于docID,根据这个docID来获取文档 Document doc = searcher.doc(scoreDoc.doc); //fullPath是刚刚建立索引的时候我们定义的一个字段，表示路径。也可以取其他的内容，只要我们在建立索引时有定义即可。 System.out.println(doc.get(\"fullPath\")); } reader.close(); }} ok，这样我们检索的代码就写完了，每一步解释我写在代码中的注释上了，下面写个 main 方法来测试一下： 12345678910public static void main(String[] args) { String indexDir = \"D:\\\\lucene\"; //查询这个字符串 String q = \"security\"; try { search(indexDir, q); } catch (Exception e) { e.printStackTrace(); }} 查一下 security 这个字符串，执行一下看控制台打印的结果： 123匹配security共耗时23毫秒查询到1条记录D:\\lucene\\data\\catalina.properties 可以看出，耗时了23毫秒在两个文件中找到了 security 这个字符串，并输出了文件的名称。上面的代码我写的很详细，这个代码已经比较全了，可以用在生产环境上。 2.3 中文分词检索高亮实战上文已经写了建立索引和检索的代码，但是在实际项目中，我们往往是结合页面做一些查询结果的展示，比如我要查某个关键字，查到了之后，将相关的信息点展示出来，并将查询的关键字高亮等等。这种需求在实际项目中非常常见，而且大多数网站中都会有这种效果。所以这一小节我们就使用 Lucene 来实现这种效果。 2.3.1 中文分词我们新建一个 ChineseIndexer 类来建立中文索引，建立过程和英文索引一样的，不同的地方在于使用的是中文分词器。除此之外，这里我们不用通过读取文件去建立索引，我们模拟一下用字符串来建立，因为在实际项目中，绝大部分情况是获取到一些文本字符串，然后根据一些关键字去查询相关内容等等。代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class ChineseIndexer { /** * 存放索引的位置 */ private Directory dir; //准备一下用来测试的数据 //用来标识文档 private Integer ids[] = {1, 2, 3}; private String citys[] = {\"上海\", \"南京\", \"青岛\"}; private String descs[] = { \"上海是个繁华的城市。\", \"南京是一个文化的城市南京，简称宁，是江苏省会，地处中国东部地区，长江下游，濒江近海。全市下辖11个区，总面积6597平方公里，2013年建成区面积752.83平方公里，常住人口818.78万，其中城镇人口659.1万人。[1-4] “江南佳丽地，金陵帝王州”，南京拥有着6000多年文明史、近2600年建城史和近500年的建都史，是中国四大古都之一，有“六朝古都”、“十朝都会”之称，是中华文明的重要发祥地，历史上曾数次庇佑华夏之正朔，长期是中国南方的政治、经济、文化中心，拥有厚重的文化底蕴和丰富的历史遗存。[5-7] 南京是国家重要的科教中心，自古以来就是一座崇文重教的城市，有“天下文枢”、“东南第一学”的美誉。截至2013年，南京有高等院校75所，其中211高校8所，仅次于北京上海；国家重点实验室25所、国家重点学科169个、两院院士83人，均居中国第三。[8-10] 。\", \"青岛是一个美丽的城市。\" }; /** * 生成索引 * @param indexDir * @throws Exception */ public void index(String indexDir) throws Exception { dir = FSDirectory.open(Paths.get(indexDir)); // 先调用 getWriter 获取IndexWriter对象 IndexWriter writer = getWriter(); for(int i = 0; i &lt; ids.length; i++) { Document doc = new Document(); // 把上面的数据都生成索引，分别用id、city和desc来标识 doc.add(new IntField(\"id\", ids[i], Field.Store.YES)); doc.add(new StringField(\"city\", citys[i], Field.Store.YES)); doc.add(new TextField(\"desc\", descs[i], Field.Store.YES)); //添加文档 writer.addDocument(doc); } //close了才真正写到文档中 writer.close(); } /** * 获取IndexWriter实例 * @return * @throws Exception */ private IndexWriter getWriter() throws Exception { //使用中文分词器 SmartChineseAnalyzer analyzer = new SmartChineseAnalyzer(); //将中文分词器配到写索引的配置中 IndexWriterConfig config = new IndexWriterConfig(analyzer); //实例化写索引对象 IndexWriter writer = new IndexWriter(dir, config); return writer; } public static void main(String[] args) throws Exception { new ChineseIndexer().index(\"D:\\\\lucene2\"); }} 这里我们用 id、city、desc 分别代表 id、城市名称和城市描述，用他们作为关键字来建立索引，后面我们获取内容的时候，主要来获取城市描述。南京的描述我故意写的长一点，因为下文检索的时候，根据不同的关键字会检索到不同部分的信息，有个权重的概念在里面。然后执行一下 main 方法，将索引保存到 D:\\lucene2\\ 中。 2.3.2 中文分词查询中文分词查询代码逻辑和默认的查询差不多，有一些区别在于，我们需要将查询出来的关键字标红加粗等需要处理，需要计算出一个得分片段，这是什么意思呢？比如我搜索 “南京文化” 跟搜索 “南京文明”，这两个搜索结果应该根据关键字出现的位置，返回的结果不一样才对，这在下文会测试。我们先看一下代码和注释： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class ChineseSearch { private static final Logger logger = LoggerFactory.getLogger(ChineseSearch.class); public static List&lt;String&gt; search(String indexDir, String q) throws Exception { //获取要查询的路径，也就是索引所在的位置 Directory dir = FSDirectory.open(Paths.get(indexDir)); IndexReader reader = DirectoryReader.open(dir); IndexSearcher searcher = new IndexSearcher(reader); //使用中文分词器 SmartChineseAnalyzer analyzer = new SmartChineseAnalyzer(); //由中文分词器初始化查询解析器 QueryParser parser = new QueryParser(\"desc\", analyzer); //通过解析要查询的String，获取查询对象 Query query = parser.parse(q); //记录索引开始时间 long startTime = System.currentTimeMillis(); //开始查询，查询前10条数据，将记录保存在docs中 TopDocs docs = searcher.search(query, 10); //记录索引结束时间 long endTime = System.currentTimeMillis(); logger.info(\"匹配{}共耗时{}毫秒\", q, (endTime - startTime)); logger.info(\"查询到{}条记录\", docs.totalHits); //如果不指定参数的话，默认是加粗，即&lt;b&gt;&lt;b/&gt; SimpleHTMLFormatter simpleHTMLFormatter = new SimpleHTMLFormatter(\"&lt;b&gt;&lt;font color=red&gt;\",\"&lt;/font&gt;&lt;/b&gt;\"); //根据查询对象计算得分，会初始化一个查询结果最高的得分 QueryScorer scorer = new QueryScorer(query); //根据这个得分计算出一个片段 Fragmenter fragmenter = new SimpleSpanFragmenter(scorer); //将这个片段中的关键字用上面初始化好的高亮格式高亮 Highlighter highlighter = new Highlighter(simpleHTMLFormatter, scorer); //设置一下要显示的片段 highlighter.setTextFragmenter(fragmenter); //取出每条查询结果 List&lt;String&gt; list = new ArrayList&lt;&gt;(); for(ScoreDoc scoreDoc : docs.scoreDocs) { //scoreDoc.doc相当于docID,根据这个docID来获取文档 Document doc = searcher.doc(scoreDoc.doc); logger.info(\"city:{}\", doc.get(\"city\")); logger.info(\"desc:{}\", doc.get(\"desc\")); String desc = doc.get(\"desc\"); //显示高亮 if(desc != null) { TokenStream tokenStream = analyzer.tokenStream(\"desc\", new StringReader(desc)); String summary = highlighter.getBestFragment(tokenStream, desc); logger.info(\"高亮后的desc:{}\", summary); list.add(summary); } } reader.close(); return list; }} 每一步的注释我写的很详细，在这就不赘述了。接下来我们来测试一下效果。 2.3.3 测试一下这里我们使用 thymeleaf 来写个简单的页面来展示获取到的数据，并高亮展示。在 controller 中我们指定索引的目录和需要查询的字符串，如下： 1234567891011121314151617181920@Controller@RequestMapping(\"/lucene\")public class IndexController { @GetMapping(\"/test\") public String test(Model model) { // 索引所在的目录 String indexDir = \"D:\\\\lucene2\"; // 要查询的字符// String q = \"南京文明\"; String q = \"南京文化\"; try { List&lt;String&gt; list = ChineseSearch.search(indexDir, q); model.addAttribute(\"list\", list); } catch (Exception e) { e.printStackTrace(); } return \"result\"; }} 直接返回到 result.html 页面，该页面主要来展示一下 model 中的数据即可。 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div th:each=\"desc : ${list}\"&gt; &lt;div th:utext=\"${desc}\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 这里注意一下，不能使用 th:test，否则字符串中的 html 标签都会被转义，不会被渲染到页面。下面启动服务，在浏览器中输入 http://localhost:8080/lucene/test，测试一下效果，我们搜索的是 “南京文化”。 再将 controller 中的搜索关键字改成 “南京文明”，看下命中的效果。 可以看出，不同的关键词，它会计算一个得分片段，也就是说不同的关键字会命中不同位置的内容，然后将关键字根据我们自己设定的形式高亮显示。从结果中可以看出，Lucene 也可以很智能的将关键字拆分命中，这在实际项目中会很好用。 3. 总结本节课首先详细的分析了全文检索的理论规则，然后结合 Lucene，系统的讲述了在 Spring Boot 的集成步骤，首先快速带领大家从直观上感受 Lucene 如何建立索引已经如果检索，其次通过中文检索的具体实例，展示了 Lucene 在全文检索中的广泛应用。Lucene 不难，主要就是步骤比较多，代码不用死记硬背，拿到项目中根据实际情况做对应的修改即可。 课程源代码下载地址：戳我下载 欢迎关注我的为微信公众号：武哥聊编程 第18课：Spring Boot搭建实际项目开发中的架构前面的课程中，我主要给大家讲解了 Spring Boot 中常用的一些技术点，这些技术点在实际项目中可能不会全部用得到，因为不同的项目可能使用的技术不同，但是希望大家都能掌握如何使用，并能自己根据实际项目中的需求进行相应的扩展。 不知道大家了不了解单片机，单片机里有个最小系统，这个最小系统搭建好了之后，就可以在此基础上进行人为的扩展。这节课我们要做的就是搭建一个 “Spring Boot 最小系统架构” 。拿着这个架构，可以在此基础上根据实际需求做相应的扩展。 从零开始搭建一个环境，主要要考虑几点：统一封装的数据结构、可调式的接口、json的处理、模板引擎的使用（本文不写该项，因为现在大部分项目都前后端分离了，但是考虑到也还有非前后端分离的项目，所以我在源代码里也加上了 thymeleaf）、持久层的集成、拦截器（这个也是可选的）和全局异常处理。一般包括这些东西的话，基本上一个 Spring Boot 项目环境就差不多了，然后就是根据具体情况来扩展了。 结合前面的课程和以上的这些点，本节课手把手带领大家搭建一个实际项目开发中可用的 Spring Boot 架构。整个项目工程如下图所示，学习的时候，可以结合我的源码，这样效果会更好。 1. 统一的数据封装由于封装的 json 数据的类型不确定，所以在定义统一的 json 结构时，我们需要用到泛型。统一的 json 结构中属性包括数据、状态码、提示信息即可，构造方法可以根据实际业务需求做相应的添加即可，一般来说，应该有默认的返回结构，也应该有用户指定的返回结构。如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 统一返回对象 * @author shengwu ni * @param &lt;T&gt; */public class JsonResult&lt;T&gt; { private T data; private String code; private String msg; /** * 若没有数据返回，默认状态码为0，提示信息为：操作成功！ */ public JsonResult() { this.code = \"0\"; this.msg = \"操作成功！\"; } /** * 若没有数据返回，可以人为指定状态码和提示信息 * @param code * @param msg */ public JsonResult(String code, String msg) { this.code = code; this.msg = msg; } /** * 有数据返回时，状态码为0，默认提示信息为：操作成功！ * @param data */ public JsonResult(T data) { this.data = data; this.code = \"0\"; this.msg = \"操作成功！\"; } /** * 有数据返回，状态码为0，人为指定提示信息 * @param data * @param msg */ public JsonResult(T data, String msg) { this.data = data; this.code = \"0\"; this.msg = msg; } /** * 使用自定义异常作为参数传递状态码和提示信息 * @param msgEnum */ public JsonResult(BusinessMsgEnum msgEnum) { this.code = msgEnum.code(); this.msg = msgEnum.msg(); } // 省去get和set方法} 大家可以根据自己项目中所需要的一些东西，合理的修改统一结构中的字段信息。 2. json的处理Json 处理工具很多，比如阿里巴巴的 fastjson，不过 fastjson 对有些未知类型的 null 无法转成空字符串，这可能是 fastjson 自身的缺陷，可扩展性也不是太好，但是使用起来方便，使用的人也蛮多的。这节课里面我们主要集成 Spring Boot 自带的 jackson。主要是对 jackson 做一下对 null 的配置即可，然后就可以在项目中使用了。 1234567891011121314151617181920/** * jacksonConfig * @author shengwu ni */@Configurationpublic class JacksonConfig { @Bean @Primary @ConditionalOnMissingBean(ObjectMapper.class) public ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) { ObjectMapper objectMapper = builder.createXmlMapper(false).build(); objectMapper.getSerializerProvider().setNullValueSerializer(new JsonSerializer&lt;Object&gt;() { @Override public void serialize(Object o, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException { jsonGenerator.writeString(\"\"); } }); return objectMapper; }} 这里先不测试，等下面 swagger2 配置好了之后，我们一起来测试一下。 3. swagger2在线可调式接口有了 swagger，开发人员不需要给其他人员提供接口文档，只要告诉他们一个 Swagger 地址，即可展示在线的 API 接口文档，除此之外，调用接口的人员还可以在线测试接口数据，同样地，开发人员在开发接口时，同样也可以利用 Swagger 在线接口文档测试接口数据，这给开发人员提供了便利。使用 swagger 需要对其进行配置： 1234567891011121314151617181920212223242526272829303132333435363738/** * swagger配置 * @author shengwu ni */@Configuration@EnableSwagger2public class SwaggerConfig { @Bean public Docket createRestApi() { return new Docket(DocumentationType.SWAGGER_2) // 指定构建api文档的详细信息的方法：apiInfo() .apiInfo(apiInfo()) .select() // 指定要生成api接口的包路径，这里把controller作为包路径，生成controller中的所有接口 .apis(RequestHandlerSelectors.basePackage(\"com.itcodai.course18.controller\")) .paths(PathSelectors.any()) .build(); } /** * 构建api文档的详细信息 * @return */ private ApiInfo apiInfo() { return new ApiInfoBuilder() // 设置页面标题 .title(\"Spring Boot搭建实际项目中开发的架构\") // 设置接口描述 .description(\"跟武哥一起学Spring Boot第18课\") // 设置联系方式 .contact(\"倪升武，\" + \"微信公众号：程序员私房菜\") // 设置版本 .version(\"1.0\") // 构建 .build(); }} 到这里，可以先测试一下，写一个 Controller，弄一个静态的接口测试一下上面集成的内容。 1234567891011121314@RestController@Api(value = \"用户信息接口\")public class UserController { @Resource private UserService userService; @GetMapping(\"/getUser/{id}\") @ApiOperation(value = \"根据用户唯一标识获取用户信息\") public JsonResult&lt;User&gt; getUserInfo(@PathVariable @ApiParam(value = \"用户唯一标识\") Long id) { User user = new User(id, \"倪升武\", \"123456\"); return new JsonResult&lt;&gt;(user); }} 然后启动项目，在浏览器中输入 localhost:8080/swagger-ui.html 即可看到 swagger 接口文档页面，调用一下上面这个接口，即可看到返回的 json 数据。 4. 持久层集成每个项目中是必须要有持久层的，与数据库交互，这里我们主要来集成 mybatis，集成 mybatis 首先要在 application.yml 中进行配置。 12345678910111213141516171819202122232425# 服务端口号server: port: 8080# 数据库地址datasource: url: localhost:3306/blog_testspring: datasource: # 数据库配置 driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://${datasource.url}?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;allowMultiQueries=true&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;maxReconnects=10 username: root password: 123456 hikari: maximum-pool-size: 10 # 最大连接池数 max-lifetime: 1770000mybatis: # 指定别名设置的包为所有entity type-aliases-package: com.itcodai.course18.entity configuration: map-underscore-to-camel-case: true # 驼峰命名规范 mapper-locations: # mapper映射文件位置 - classpath:mapper/*.xml 配置好了之后，接下来我们来写一下 dao 层，实际中我们使用注解比较多，因为比较方便，当然也可以使用 xml 的方式，甚至两种同时使用都行，这里我们主要使用注解的方式来集成，关于 xml 的方式，大家可以查看前面课程，实际中根据项目情况来定。 123456789101112131415public interface UserMapper { @Select(\"select * from user where id = #{id}\") @Results({ @Result(property = \"username\", column = \"user_name\"), @Result(property = \"password\", column = \"password\") }) User getUser(Long id); @Select(\"select * from user where id = #{id} and user_name=#{name}\") User getUserByIdAndName(@Param(\"id\") Long id, @Param(\"name\") String username); @Select(\"select * from user\") List&lt;User&gt; getAll();} 关于 service 层我就不在文章中写代码了，大家可以结合我的源代码学习，这一节主要带领大家来搭建一个 Spring Boot 空架构。最后别忘了在启动类上添加注解扫描 @MapperScan(&quot;com.itcodai.course18.dao&quot;) 5. 拦截器拦截器在项目中使用的是非常多的（但不是绝对的），比如拦截一些置顶的 url，做一些判断和处理等等。除此之外，还需要将常用的静态页面或者 swagger 页面放行，不能将这些静态资源给拦截了。首先先自定义一个拦截器。 123456789101112131415161718192021public class MyInterceptor implements HandlerInterceptor { private static final Logger logger = LoggerFactory.getLogger(MyInterceptor.class); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { logger.info(\"执行方法之前执行(Controller方法调用之前)\"); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { logger.info(\"执行完方法之后进执行(Controller方法调用之后)，但是此时还没进行视图渲染\"); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { logger.info(\"整个请求都处理完咯，DispatcherServlet也渲染了对应的视图咯，此时我可以做一些清理的工作了\"); }} 然后将自定义的拦截器加入到拦截器配置中。 123456789101112@Configurationpublic class MyInterceptorConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { // 实现WebMvcConfigurer不会导致静态资源被拦截 registry.addInterceptor(new MyInterceptor()) // 拦截所有url .addPathPatterns(\"/**\") // 放行swagger .excludePathPatterns(\"/swagger-resources/**\"); }} 在 Spring Boot 中，我们通常会在如下目录里存放一些静态资源： classpath:/staticclasspath:/publicclasspath:/resourcesclasspath:/META-INF/resources 上面代码中配置的 /** 是对所有 url 都进行了拦截，但我们实现了 WebMvcConfigurer 接口，不会导致 Spring Boot 对上面这些目录下的静态资源实施拦截。但是我们平时访问的 swagger 会被拦截，所以要将其放行。swagger 页面在 swagger-resources 目录下，放行该目录下所有文件即可。 然后在浏览器中输入一下 swagger 页面，若能正常显示 swagger，说明放行成功。同时可以根据后台打印的日志判断代码执行的顺序。 6. 全局异常处理全局异常处理是每个项目中必须用到的东西，在具体的异常中，我们可能会做具体的处理，但是对于没有处理的异常，一般会有一个统一的全局异常处理。在异常处理之前，最好维护一个异常提示信息枚举类，专门用来保存异常提示信息的。如下： 123456789101112131415161718192021222324252627282930313233public enum BusinessMsgEnum { /** 参数异常 */ PARMETER_EXCEPTION(\"102\", \"参数异常!\"), /** 等待超时 */ SERVICE_TIME_OUT(\"103\", \"服务调用超时！\"), /** 参数过大 */ PARMETER_BIG_EXCEPTION(\"102\", \"输入的图片数量不能超过50张!\"), /** 500 : 发生异常 */ UNEXPECTED_EXCEPTION(\"500\", \"系统发生异常，请联系管理员！\"); /** * 消息码 */ private String code; /** * 消息内容 */ private String msg; private BusinessMsgEnum(String code, String msg) { this.code = code; this.msg = msg; } public String code() { return code; } public String msg() { return msg; }} 在全局统一异常处理类中，我们一般会对自定义的业务异常最先处理，然后去处理一些常见的系统异常，最后会来一个一劳永逸（Exception 异常）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344@ControllerAdvice@ResponseBodypublic class GlobalExceptionHandler { private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class); /** * 拦截业务异常，返回业务异常信息 * @param ex * @return */ @ExceptionHandler(BusinessErrorException.class) @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR) public JsonResult handleBusinessError(BusinessErrorException ex) { String code = ex.getCode(); String message = ex.getMessage(); return new JsonResult(code, message); } /** * 空指针异常 * @param ex NullPointerException * @return */ @ExceptionHandler(NullPointerException.class) @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR) public JsonResult handleTypeMismatchException(NullPointerException ex) { logger.error(\"空指针异常，{}\", ex.getMessage()); return new JsonResult(\"500\", \"空指针异常了\"); } /** * 系统异常 预期以外异常 * @param ex * @return */ @ExceptionHandler(Exception.class) @ResponseStatus(value = HttpStatus.INTERNAL_SERVER_ERROR) public JsonResult handleUnexpectedServer(Exception ex) { logger.error(\"系统异常：\", ex); return new JsonResult(BusinessMsgEnum.UNEXPECTED_EXCEPTION); }} 其中，BusinessErrorException 是自定义的业务异常，继承一下 RuntimeException 即可，具体可以看我的源代码，文章中就不贴代码了。在 UserController 中有个 testException 方法，用来测试全局异常的，打开 swagger 页面，调用一下该接口，可以看出返回用户提示信息：”系统发生异常，请联系管理员！“。当然了，实际情况中，需要根据不同的业务提示不同的信息。 7. 总结本文主要手把手带领大家快速搭建一个项目中可以使用的 Spring Boot 空架构，主要从统一封装的数据结构、可调式的接口、json的处理、模板引擎的使用（代码中体现）、持久层的集成、拦截器和全局异常处理。一般包括这些东西的话，基本上一个 Spring Boot 项目环境就差不多了，然后就是根据具体情况来扩展了。 课程源代码下载地址：戳我下载 欢迎关注我的为微信公众号：武哥聊编程 附：作者信息本课程首发于 CSDN GitChat 达人课，该文档为课程详细笔记作者：倪升武（武哥）微信公众号：武哥聊编程二维码： 版权申明：本课程已经免费，但版权属于 CSDN 和作者，未经允许，不得将该笔记用于商业用途，否则追究法律责任。 12 12","link":"/2020/02/17/SpringBoot%E7%BB%8F%E5%85%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[],"categories":[]}